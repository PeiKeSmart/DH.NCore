# 网络库 Echo 回环性能测试报告

## 测试目标

- 在 Benchmark 项目中增加网络库收发基准，使用 `NetUri("tcp://127.0.0.1:7777").CreateRemote()` 建立客户端。
- 服务器回显客户端数据，测量 32 字节包的往返收发耗时与内存分配。
- 对比历史目标：`22,600,000 包/秒`。

## 测试环境

```text
BenchmarkDotNet v0.15.8
Linux Ubuntu 24.04.3 LTS
AMD EPYC 7763, 4 logical cores
.NET SDK 10.0.102
Runtime: .NET 10.0.2, X64 RyuJIT
```

## 测试方法

- 服务端：`EchoNetServer` 监听 `7777`，`OnReceive` 直接 `Send(packet)` 原样回发。
- 客户端：`new NetUri("tcp://127.0.0.1:7777").CreateRemote()`，`client.Open()` 后通过 `client.Send(ReadOnlySpan<Byte>)` 连续发送。
- 基准方法每次发送 `200,000` 个 `32B` 包，并等待 `Received` 事件累计到期望字节数后结束。
- 命令：

```bash
EnableWindowsTargeting=true dotnet run --project Benchmark/Benchmark.csproj -c Release -- --filter "*NetEchoBenchmark*"
```

## 测试结果

| 方法 | PacketSize | Mean | StdDev | Allocated |
|---|---:|---:|---:|---:|
| TCP回环收发 | 32 | 5.899 us | 0.079 us | 37 B |

换算：

- 吞吐 = `1 / 5.899us ≈ 169,520 包/秒`
- 字节吞吐 = `169,520 × 32 ≈ 5.42 MB/s`
- 相对目标 `22,600,000 包/秒`：约 **0.75%**

## 瓶颈分析

1. **单连接单事件回调模型上限明显**
   - 当前基准为单客户端、单连接、单线程事件消费，CPU 利用与网络栈并行度不足。
2. **每包一次 Send 调用与协议栈调度开销大**
   - 200,000 次小包发送导致高频系统调用与调度，吞吐受限。
3. **Received 事件路径存在托管层处理成本**
   - 每次回调都要走事件分发与计数同步，虽然分配仅 37B/op，但高频下仍是热点。
4. **回环测试是“往返链路”而非“单向极限”**
   - 同时包含发送与接收确认，等价于测 RTT 吞吐，不是裸发送吞吐上限。

## 改进建议

1. **增加并发连接压测**
   - 使用多客户端并发连接（如 8/16/32）并行发送，观察线性扩展区间。
2. **提升批量发送能力**
   - 引入批量发送接口或应用层聚合发送，减少每包一次发送调用的固定开销。
3. **减少回调路径开销**
   - 在热点路径尽量避免复杂回调逻辑，使用更轻量的计数/无锁汇总策略。
4. **拆分测试维度**
   - 分开测试“单向发送极限”“单向接收极限”“双向回环极限”，定位瓶颈位于发、收还是回调。
5. **粘包利用策略**
   - 在保证业务语义前提下提高单次写入负载，利用 TCP 粘包减少包级调度成本。

## 结论

当前新增基准已可稳定测得 32 字节包在本环境下的回环性能，结果约 **16.95 万包/秒**，与 2260 万包/秒目标差距较大。主要限制来自单连接事件模型与小包高频发送开销，后续需通过并发连接、批量发送和测试拆分来继续逼近网络库极限能力。
