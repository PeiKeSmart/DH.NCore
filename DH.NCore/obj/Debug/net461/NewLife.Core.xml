<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NewLife.Core</name>
    </assembly>
    <members>
        <member name="T:NewLife.Algorithms.AlignModes">
            <summary>
            对齐模型。数据采样时X轴对齐
            </summary>
        </member>
        <member name="F:NewLife.Algorithms.AlignModes.None">
            <summary>
            不对齐，原始值
            </summary>
        </member>
        <member name="F:NewLife.Algorithms.AlignModes.Left">
            <summary>
            左对齐
            </summary>
        </member>
        <member name="F:NewLife.Algorithms.AlignModes.Center">
            <summary>
            中间对齐
            </summary>
        </member>
        <member name="F:NewLife.Algorithms.AlignModes.Right">
            <summary>
            右对齐
            </summary>
        </member>
        <member name="T:NewLife.Algorithms.AverageSampling">
            <summary>
            平均值采样算法
            </summary>
        </member>
        <member name="P:NewLife.Algorithms.AverageSampling.AlignMode">
            <summary>
            对齐模式。每个桶X轴对齐方式
            </summary>
        </member>
        <member name="P:NewLife.Algorithms.AverageSampling.Interpolation">
            <summary>
            插值填充算法
            </summary>
        </member>
        <member name="M:NewLife.Algorithms.AverageSampling.Down(NewLife.Data.TimePoint[],System.Int32)">
            <summary>
            降采样处理。保留边界两个点
            </summary>
            <param name="data">原始数据</param>
            <param name="threshold">阈值，采样数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Algorithms.AverageSampling.Process(NewLife.Data.TimePoint[],System.Int32,System.Int32)">
            <summary>
            混合处理，降采样和插值，不保留边界节点
            </summary>
            <param name="data">原始数据</param>
            <param name="size">桶大小。如60/3600/86400</param>
            <param name="offset">偏移量。时间不是对齐零点时使用</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Algorithms.IInterpolation">
            <summary>
            插值算法
            </summary>
        </member>
        <member name="M:NewLife.Algorithms.IInterpolation.Process(NewLife.Data.TimePoint[],System.Int32,System.Int32,System.Int64)">
            <summary>
            插值处理
            </summary>
            <param name="data">数据</param>
            <param name="prev">上一个点索引</param>
            <param name="next">下一个点索引</param>
            <param name="current">当前点时间值</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Algorithms.ISampling">
            <summary>
            采样接口。负责降采样和插值处理，用于处理时序数据
            </summary>
        </member>
        <member name="P:NewLife.Algorithms.ISampling.AlignMode">
            <summary>
            对齐模式。每个桶X轴对齐方式
            </summary>
        </member>
        <member name="P:NewLife.Algorithms.ISampling.Interpolation">
            <summary>
            插值填充算法
            </summary>
        </member>
        <member name="M:NewLife.Algorithms.ISampling.Down(NewLife.Data.TimePoint[],System.Int32)">
            <summary>
            降采样处理
            </summary>
            <param name="data">原始数据</param>
            <param name="threshold">阈值，采样数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Algorithms.ISampling.Process(NewLife.Data.TimePoint[],System.Int32,System.Int32)">
            <summary>
            混合处理，降采样和插值
            </summary>
            <param name="data">原始数据</param>
            <param name="size">桶大小。如60/3600/86400</param>
            <param name="offset">偏移量。时间不是对齐零点时使用</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Algorithms.SamplingHelper">
            <summary>
            采样助手
            </summary>
        </member>
        <member name="M:NewLife.Algorithms.SamplingHelper.SplitByAverage(System.Int32,System.Int32,System.Boolean)">
            <summary>
            按照指定桶数平均分，可指定保留头尾
            </summary>
            <param name="dataLength"></param>
            <param name="threshold"></param>
            <param name="retainEdge"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Algorithms.SamplingHelper.SplitByFixedSize(System.Int64[],System.Int32,System.Int32)">
            <summary>
            按照固定时间间隔，拆分数据轴为多个桶
            </summary>
            <param name="data">原始数据</param>
            <param name="size">桶大小。如60/3600/86400</param>
            <param name="offset">偏移量。时间不是对齐零点时使用</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Algorithms.LinearInterpolation">
            <summary>
            线性插值
            </summary>
        </member>
        <member name="M:NewLife.Algorithms.LinearInterpolation.Process(NewLife.Data.TimePoint[],System.Int32,System.Int32,System.Int64)">
            <summary>
            插值处理
            </summary>
            <param name="data">数据</param>
            <param name="prev">上一个点索引</param>
            <param name="next">下一个点索引</param>
            <param name="current">当前点时间值</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Cache">
            <summary>缓存</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Default">
            <summary>默认缓存</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Expire">
            <summary>默认过期时间。避免Set操作时没有设置过期时间，默认0秒表示不过期</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Item(System.String)">
            <summary>获取和设置缓存，使用默认过期时间</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Cache.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Keys">
            <summary>所有键</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.#ctor">
            <summary>构造函数</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.Init(System.String)">
            <summary>使用连接字符串初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.Cache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Set``1(System.String,``0,System.Int32)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Get``1(System.String)">
            <summary>获取缓存项</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Clear">
            <summary>清空所有缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间，秒</param>
        </member>
        <member name="M:NewLife.Caching.Cache.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒</param>
        </member>
        <member name="M:NewLife.Caching.Cache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取指定键，返回是否包含值。有可能缓存项刚好是默认值，或者只是反序列化失败</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值。即使有值也不一定能够返回，可能缓存项刚好是默认值，或者只是反序列化失败</param>
            <returns>返回是否包含值，即使反序列化失败</returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetOrAdd``1(System.String,System.Func{System.String,``0},System.Int32)">
            <summary>获取 或 添加 缓存数据，在数据不存在时执行委托请求数据</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="callback"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Commit">
            <summary>提交变更。部分提供者需要刷盘</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，单位毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.AcquireLock(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，申请加锁时如果遇到冲突则等待的最大时间，单位毫秒</param>
            <param name="msExpire">锁过期时间，超过该时间如果没有主动释放则自动释放锁，必须整数秒，单位毫秒</param>
            <param name="throwOnFailure">失败时是否抛出异常，如果不抛出异常，可通过返回null得知申请锁失败</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Bench(System.Boolean,System.Int32)">
            <summary>多线程性能测试</summary>
            <param name="rand">随机读写。顺序，每个线程多次操作一个key；随机，每个线程每次操作不同key</param>
            <param name="batch">批量操作。默认0不分批，分批仅针对随机读写，对顺序读写的单key操作没有意义</param>
            <remarks>
            Memory性能测试[顺序]，逻辑处理器 32 个 2,000MHz Intel(R) Xeon(R) CPU E5-2640 v2 @ 2.00GHz
            
            测试 10,000,000 项，  1 线程
            赋值 10,000,000 项，  1 线程，耗时   3,764ms 速度 2,656,748 ops
            读取 10,000,000 项，  1 线程，耗时   1,296ms 速度 7,716,049 ops
            删除 10,000,000 项，  1 线程，耗时   1,230ms 速度 8,130,081 ops
            
            测试 20,000,000 项，  2 线程
            赋值 20,000,000 项，  2 线程，耗时   3,088ms 速度 6,476,683 ops
            读取 20,000,000 项，  2 线程，耗时   1,051ms 速度 19,029,495 ops
            删除 20,000,000 项，  2 线程，耗时   1,011ms 速度 19,782,393 ops
            
            测试 40,000,000 项，  4 线程
            赋值 40,000,000 项，  4 线程，耗时   3,060ms 速度 13,071,895 ops
            读取 40,000,000 项，  4 线程，耗时   1,023ms 速度 39,100,684 ops
            删除 40,000,000 项，  4 线程，耗时     994ms 速度 40,241,448 ops
            
            测试 80,000,000 项，  8 线程
            赋值 80,000,000 项，  8 线程，耗时   3,124ms 速度 25,608,194 ops
            读取 80,000,000 项，  8 线程，耗时   1,171ms 速度 68,317,677 ops
            删除 80,000,000 项，  8 线程，耗时   1,199ms 速度 66,722,268 ops
            
            测试 320,000,000 项， 32 线程
            赋值 320,000,000 项， 32 线程，耗时  13,857ms 速度 23,093,021 ops
            读取 320,000,000 项， 32 线程，耗时   1,950ms 速度 164,102,564 ops
            删除 320,000,000 项， 32 线程，耗时   3,359ms 速度 95,266,448 ops
            
            测试 320,000,000 项， 64 线程
            赋值 320,000,000 项， 64 线程，耗时   9,648ms 速度 33,167,495 ops
            读取 320,000,000 项， 64 线程，耗时   1,974ms 速度 162,107,396 ops
            删除 320,000,000 项， 64 线程，耗时   1,907ms 速度 167,802,831 ops
            
            测试 320,000,000 项，256 线程
            赋值 320,000,000 项，256 线程，耗时  12,429ms 速度 25,746,238 ops
            读取 320,000,000 项，256 线程，耗时   1,907ms 速度 167,802,831 ops
            删除 320,000,000 项，256 线程，耗时   2,350ms 速度 136,170,212 ops
            </remarks>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchOne(System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchGet(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>读取测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchSet(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>赋值测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchRemove(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>删除测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchInc(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>累加测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.CacheLock">
            <summary>分布式锁</summary>
        </member>
        <member name="F:NewLife.Caching.CacheLock._hasLock">
            <summary>
            是否持有锁
            </summary>
        </member>
        <member name="P:NewLife.Caching.CacheLock.Key">
            <summary>键</summary>
        </member>
        <member name="M:NewLife.Caching.CacheLock.#ctor(NewLife.Caching.ICache,System.String)">
            <summary>实例化</summary>
            <param name="client"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.CacheLock.Acquire(System.Int32,System.Int32)">
            <summary>申请锁</summary>
            <param name="msTimeout">锁等待时间，申请加锁时如果遇到冲突则等待的最大时间，单位毫秒</param>
            <param name="msExpire">锁过期时间，超过该时间如果没有主动释放则自动释放锁，必须整数秒，单位毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.CacheLock.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Caching.CacheProvider">
            <summary>分布式缓存架构服务。提供基础缓存及队列服务</summary>
        </member>
        <member name="P:NewLife.Caching.CacheProvider.Cache">
            <summary>全局缓存。各功能模块跨进程共享数据，分布式部署时可用Redis，需要考虑序列化成本。默认单机使用内存缓存</summary>
        </member>
        <member name="P:NewLife.Caching.CacheProvider.InnerCache">
            <summary>应用内本地缓存。默认内存缓存，无需考虑对象序列化成本，缺点是不支持跨进程共享数据</summary>
        </member>
        <member name="M:NewLife.Caching.CacheProvider.#ctor">
            <summary>使用默认缓存实例化</summary>
        </member>
        <member name="M:NewLife.Caching.CacheProvider.GetQueue``1(System.String,System.String)">
            <summary>获取队列。各功能模块跨进程共用的队列</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="topic">主题</param>
            <param name="group">消费组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.CacheProvider.GetInnerQueue``1(System.String)">
            <summary>获取内部队列。默认内存队列</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="topic">主题</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.CacheProvider.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <param name="lockKey">要锁定的键值。建议加上应用模块等前缀以避免冲突</param>
            <param name="msTimeout">遇到冲突时等待的最大时间</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.ICache">
            <summary>缓存接口</summary>
            <remarks>
            文档 https://newlifex.com/core/icache
            </remarks>
        </member>
        <member name="P:NewLife.Caching.ICache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Expire">
            <summary>默认缓存时间。默认0秒表示不过期</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Item(System.String)">
            <summary>获取和设置缓存，永不过期</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.ICache.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Keys">
            <summary>所有键</summary>
        </member>
        <member name="M:NewLife.Caching.ICache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Set``1(System.String,``0,System.Int32)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.ICache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Get``1(System.String)">
            <summary>获取缓存项</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Clear">
            <summary>清空所有缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.ICache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
        </member>
        <member name="M:NewLife.Caching.ICache.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.ICache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.ICache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <remarks>
            常常配合Increment使用，用于累加到一定数后重置归零，又避免多线程冲突。
            </remarks>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取指定键，返回是否包含值。有可能缓存项刚好是默认值，或者只是反序列化失败，解决缓存穿透问题</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值。即使有值也不一定能够返回，可能缓存项刚好是默认值，或者只是反序列化失败</param>
            <returns>返回是否包含值，即使反序列化失败</returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetOrAdd``1(System.String,System.Func{System.String,``0},System.Int32)">
            <summary>获取 或 添加 缓存数据，在数据不存在时执行委托请求数据</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="callback"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Commit">
            <summary>提交变更。部分提供者需要刷盘</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，单位毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.AcquireLock(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，申请加锁时如果遇到冲突则等待的最大时间，单位毫秒</param>
            <param name="msExpire">锁过期时间，超过该时间如果没有主动释放则自动释放锁，必须整数秒，单位毫秒</param>
            <param name="throwOnFailure">失败时是否抛出异常，如果不抛出异常，可通过返回null得知申请锁失败</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Bench(System.Boolean,System.Int32)">
            <summary>多线程性能测试</summary>
            <param name="rand">随机读写。顺序，每个线程多次操作一个key；随机，每个线程每次操作不同key</param>
            <param name="batch">批量操作。默认0不分批，分批仅针对随机读写，对顺序读写的单key操作没有意义</param>
        </member>
        <member name="T:NewLife.Caching.ICacheProvider">
            <summary>分布式缓存架构服务。提供基础缓存及队列服务</summary>
            <remarks>
            文档 https://newlifex.com/core/icacheprovider
            根据实际开发经验，即使在分布式系统中，也有大量的数据是不需要跨进程共享的，因此本接口提供了两级缓存。
            进程内缓存使用<see cref="P:NewLife.Caching.ICacheProvider.InnerCache"/>，可以规避对象序列化成本，跨进程缓存使用<see cref="P:NewLife.Caching.ICacheProvider.Cache"/>。
            借助该缓存架构，可以实现各功能模块跨进程共享数据，分布式部署时可用Redis，需要考虑序列化成本。
            
            使用队列时，可根据是否设置消费组来决定使用简单队列还是完整队列。
            简单队列（如RedisQueue）可用作命令队列，Topic很多，但几乎没有消息。
            完整队列（如RedisStream）可用作消息队列，Topic很少，但消息很多，并且支持多消费组。
            </remarks>
        </member>
        <member name="P:NewLife.Caching.ICacheProvider.Cache">
            <summary>全局缓存。各功能模块跨进程共享数据，分布式部署时可用Redis，需要考虑序列化成本。默认单机使用内存缓存</summary>
        </member>
        <member name="P:NewLife.Caching.ICacheProvider.InnerCache">
            <summary>应用内本地缓存。默认内存缓存，无需考虑对象序列化成本，缺点是不支持跨进程共享数据</summary>
        </member>
        <member name="M:NewLife.Caching.ICacheProvider.GetQueue``1(System.String,System.String)">
            <summary>获取队列。各功能模块跨进程共用的队列</summary>
            <remarks>
            使用队列时，可根据是否设置消费组来决定使用简单队列还是完整队列。
            简单队列（如RedisQueue）可用作命令队列，Topic很多，但几乎没有消息。
            完整队列（如RedisStream）可用作消息队列，Topic很少，但消息很多，并且支持多消费组。
            </remarks>
            <typeparam name="T">消息类型。用于消息生产者时，可指定为Object</typeparam>
            <param name="topic">主题</param>
            <param name="group">消费组。未指定消费组时使用简单队列（如RedisQueue），指定消费组时使用完整队列（如RedisStream）</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICacheProvider.GetInnerQueue``1(System.String)">
            <summary>获取内部队列。默认内存队列</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="topic">主题</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICacheProvider.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <remarks>
            一般实现为Redis分布式锁，申请锁的具体表现为锁定某个key，锁维持时间为msTimeout，遇到冲突时等待msTimeout时间。
            如果在等待时间内获得锁，则返回一个IDisposable对象，离开using代码块时自动释放锁。
            如果在等待时间内没有获得锁，则抛出异常，需要自己处理锁冲突的情况。
            
            如果希望指定不同的维持时间和等待时间，可以使用<see cref="T:NewLife.Caching.ICache"/>接口的<see cref="M:NewLife.Caching.ICache.AcquireLock(System.String,System.Int32,System.Int32,System.Boolean)"/>方法。
            </remarks>
            <param name="lockKey">要锁定的键值。建议加上应用模块等前缀以避免冲突</param>
            <param name="msTimeout">遇到冲突时等待的最大时间，同时也是锁维持的时间</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.IProducerConsumer`1">
            <summary>轻量级生产者消费者接口</summary>
            <remarks>
            不一定支持Ack机制；也不支持消息体与消息键分离
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Caching.IProducerConsumer`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="P:NewLife.Caching.IProducerConsumer`1.IsEmpty">
            <summary>集合是否为空</summary>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Add(`0[])">
            <summary>生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Take(System.Int32)">
            <summary>消费获取一批</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.TakeOne(System.Int32)">
            <summary>消费获取一个</summary>
            <param name="timeout">超时。默认0秒，永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.TakeOneAsync(System.Int32)">
            <summary>异步消费获取一个</summary>
            <param name="timeout">超时。单位秒，0秒表示永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>异步消费获取一个</summary>
            <param name="timeout">超时。单位秒，0秒表示永久等待</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Acknowledge(System.String[])">
            <summary>确认消费</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.KeyEventArgs">
            <summary>缓存键事件参数</summary>
        </member>
        <member name="P:NewLife.Caching.KeyEventArgs.Key">
            <summary>缓存键</summary>
        </member>
        <member name="T:NewLife.Caching.MemoryCache">
            <summary>默认字典缓存</summary>
        </member>
        <member name="F:NewLife.Caching.MemoryCache._cache">
            <summary>缓存核心</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Capacity">
            <summary>容量。容量超标时，采用LRU机制删除，默认100_000</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Period">
            <summary>定时清理时间，默认60秒</summary>
        </member>
        <member name="E:NewLife.Caching.MemoryCache.KeyExpired">
            <summary>缓存键过期</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Instance">
            <summary>默认缓存</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.#ctor">
            <summary>实例化一个内存字典缓存</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Count">
            <summary>缓存项。原子计数</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Keys">
            <summary>所有键。实际返回只读列表新实例，数据量较大时注意性能</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Init(System.String)">
            <summary>初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAdd``1(System.String,``0,System.Int32)">
            <summary>获取或添加缓存项</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Set``1(System.String,``0,System.Int32)">
            <summary>添加缓存项，已存在时更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Get``1(System.String)">
            <summary>获取缓存项，不存在时返回默认值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns>实际移除个数</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Clear">
            <summary>清空所有缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期。已过期但未移除的键会重新激活</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
            <returns>设置是否成功</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetExpire(System.String)">
            <summary>获取缓存项有效期，不存在时返回Zero</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新，常用于锁争夺</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取指定键，返回是否包含值。有可能缓存项刚好是默认值，或者只是反序列化失败</summary>
            <remarks>
            在 MemoryCache 中，如果某个key过期，在清理之前仍然可以通过TryGet访问，并且更新访问时间，避免被清理。
            </remarks>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值。即使有值也不一定能够返回，可能缓存项刚好是默认值，或者只是反序列化失败</param>
            <returns>返回是否包含值，即使反序列化失败</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAdd``1(System.String,System.Func{System.String,``0},System.Int32)">
            <summary>获取 或 添加 缓存数据，在数据不存在时执行委托请求数据</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="callback"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <remarks>基于HashSet，非线程安全</remarks>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAddItem(System.String,System.Func{System.String,System.Object})">
            <summary>获取 或 添加 缓存项</summary>
            <param name="key"></param>
            <param name="valueFactory"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.MemoryCache.CacheItem">
            <summary>缓存项</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.Expired">
            <summary>是否过期</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.VisitTime">
            <summary>访问时间</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.#ctor(System.Object,System.Int32)">
            <summary>构造缓存项</summary>
            <param name="value"></param>
            <param name="expire"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Set(System.Object,System.Int32)">
            <summary>设置数值和过期时间</summary>
            <param name="value"></param>
            <param name="expire">过期时间，秒</param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Set(System.Object,System.TimeSpan)">
            <summary>设置数值和过期时间</summary>
            <param name="value"></param>
            <param name="expire">过期时间，秒</param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Visit">
            <summary>更新访问时间并返回数值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Inc(System.Int64)">
            <summary>递增</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Inc(System.Double)">
            <summary>递增</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Dec(System.Int64)">
            <summary>递减</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Dec(System.Double)">
            <summary>递减</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Caching.MemoryCache._clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.RemoveNotAlive(System.Object)">
            <summary>移除过期的缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.OnExpire(System.String)">
            <summary>缓存过期</summary>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Save(System.IO.Stream)">
            <summary>保存到数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Load(System.IO.Stream)">
            <summary>从数据流加载</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Save(System.String,System.Boolean)">
            <summary>保存到文件</summary>
            <param name="file"></param>
            <param name="compressed"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Load(System.String,System.Boolean)">
            <summary>从文件加载</summary>
            <param name="file"></param>
            <param name="compressed"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.BenchOne(System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="T:NewLife.Caching.MemoryQueue`1">
            <summary>生产者消费者</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.#ctor">
            <summary>实例化内存队列</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>实例化内存队列</summary>
            <param name="collection"></param>
        </member>
        <member name="P:NewLife.Caching.MemoryQueue`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryQueue`1.IsEmpty">
            <summary>集合是否为空</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Add(`0[])">
            <summary>生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Take(System.Int32)">
            <summary>消费获取</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.TakeOne(System.Int32)">
            <summary>消费一个</summary>
            <param name="timeout">超时。默认0秒，永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.TakeOneAsync(System.Int32)">
            <summary>消费获取，异步阻塞</summary>
            <param name="timeout">超时。单位秒，0秒表示永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>消费获取，异步阻塞</summary>
            <param name="timeout">超时。单位秒，0秒表示永久等待</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Acknowledge(System.String[])">
            <summary>确认消费</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.ConcurrentHashSet`1">
            <summary>并行哈希集合</summary>
            <remarks>
            主要用于频繁添加删除而又要遍历的场合
            </remarks>
        </member>
        <member name="P:NewLife.Collections.ConcurrentHashSet`1.IsEmpty">
            <summary>是否空集合</summary>
        </member>
        <member name="P:NewLife.Collections.ConcurrentHashSet`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.Contain(`0)">
            <summary>是否包含元素</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.TryAdd(`0)">
            <summary>尝试添加</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.TryRemove(`0)">
            <summary>尝试删除</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.IArrayPool`1">
            <summary>数组缓冲池</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.IArrayPool`1.Rent(System.Int32)">
            <summary>借出</summary>
            <param name="minimumLength"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.IArrayPool`1.Return(`0[],System.Boolean)">
            <summary>归还</summary>
            <param name="array"></param>
            <param name="clearArray"></param>
        </member>
        <member name="T:NewLife.Collections.ArrayPool">
            <summary>数组池</summary>
        </member>
        <member name="P:NewLife.Collections.ArrayPool.Empty">
            <summary>空数组</summary>
        </member>
        <member name="T:NewLife.Collections.ArrayPool`1">
            <summary>数组池</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.ArrayPool`1.Shared">
            <summary>共享实例</summary>
        </member>
        <member name="M:NewLife.Collections.ArrayPool`1.Create">
            <summary>创建数组池</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ArrayPool`1.Create(System.Int32,System.Int32)">
            <summary>创建数组池</summary>
            <param name="maxArrayLength"></param>
            <param name="maxArraysPerBucket"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ArrayPool`1.Rent(System.Int32)">
            <summary>借出</summary>
            <param name="minimumLength"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ArrayPool`1.Return(`0[],System.Boolean)">
            <summary>归还</summary>
            <param name="array"></param>
            <param name="clearArray"></param>
        </member>
        <member name="M:NewLife.Collections.ConfigurableArrayPool`1.Rent(System.Int32)">
            <summary>借出</summary>
            <param name="minimumLength"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConfigurableArrayPool`1.OnCreate(System.Int32)">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConfigurableArrayPool`1.Return(`0[],System.Boolean)">
            <summary>归还</summary>
            <param name="array"></param>
            <param name="clearArray"></param>
        </member>
        <member name="T:NewLife.Collections.IDictionarySource">
            <summary>
            字典数据源接口。定义该模型类支持输出名值字典，便于序列化传输
            </summary>
        </member>
        <member name="M:NewLife.Collections.IDictionarySource.ToDictionary">
            <summary>
            把对象转为名值字典，便于序列化传输
            </summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.IPool`1">
            <summary>对象池接口</summary>
            <remarks>
            文档 https://newlifex.com/core/object_pool
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.IPool`1.Max">
            <summary>对象池大小</summary>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Get">
            <summary>获取</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Return(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Clear">
            <summary>清空</summary>
        </member>
        <member name="T:NewLife.Collections.Pool">
            <summary>对象池扩展</summary>
            <remarks>
            文档 https://newlifex.com/core/object_pool
            </remarks>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilder">
            <summary>字符串构建器池</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.Put(System.Text.StringBuilder,System.Boolean)">
            <summary>归还一个字符串构建器到对象池</summary>
            <param name="sb"></param>
            <param name="requireResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.Return(System.Text.StringBuilder,System.Boolean)">
            <summary>归还一个字符串构建器到对象池</summary>
            <param name="sb"></param>
            <param name="returnResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Pool.StringBuilderPool">
            <summary>字符串构建器池</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilderPool.InitialCapacity">
            <summary>初始容量。默认100个</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilderPool.MaximumCapacity">
            <summary>最大容量。超过该大小时不进入池内，默认4k</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.StringBuilderPool.OnCreate">
            <summary>创建</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.StringBuilderPool.Put(System.Text.StringBuilder)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.StringBuilderPool.Return(System.Text.StringBuilder)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStream">
            <summary>内存流池</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.Put(System.IO.MemoryStream,System.Boolean)">
            <summary>归还一个内存流到对象池</summary>
            <param name="ms"></param>
            <param name="requireResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.Return(System.IO.MemoryStream,System.Boolean)">
            <summary>归还一个内存流到对象池</summary>
            <param name="ms"></param>
            <param name="returnResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Pool.MemoryStreamPool">
            <summary>内存流池</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStreamPool.InitialCapacity">
            <summary>初始容量。默认1024个</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStreamPool.MaximumCapacity">
            <summary>最大容量。超过该大小时不进入池内，默认64k</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.MemoryStreamPool.OnCreate">
            <summary>创建</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.MemoryStreamPool.Put(System.IO.MemoryStream)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.MemoryStreamPool.Return(System.IO.MemoryStream)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.Pool.Shared">
            <summary>字节数组共享存储</summary>
        </member>
        <member name="T:NewLife.Collections.NullableDictionary`2">
            <summary>可空字典。获取数据时如果指定键不存在可返回空而不是抛出异常</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor">
            <summary>实例化一个可空字典</summary>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>指定比较器实例化一个可空字典</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>实例化一个可空字典</summary>
            <param name="dic"></param>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个可空字典</summary>
            <param name="dic"></param>
            <param name="comparer"></param>
        </member>
        <member name="P:NewLife.Collections.NullableDictionary`2.Item(`0)">
            <summary>获取 或 设置 数据</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.ObjectPool`1">
            <summary>资源池。支持空闲释放，主要用于数据库连接池和网络连接池</summary>
            <remarks>
            文档 https://newlifex.com/core/object_pool
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.FreeCount">
            <summary>空闲个数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.BusyCount">
            <summary>繁忙个数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Max">
            <summary>最大个数。默认100，0表示无上限</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Min">
            <summary>最小个数。默认1</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.IdleTime">
            <summary>空闲清理时间。最小个数之上的资源超过空闲时间时被清理，默认10s</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.AllIdleTime">
            <summary>完全空闲清理时间。最小个数之下的资源超过空闲时间时被清理，默认0s永不清理</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._free">
            <summary>基础空闲集合。只保存最小个数，最热部分</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._free2">
            <summary>扩展空闲集合。保存最小个数以外部分</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._busy">
            <summary>借出去的放在这</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.#ctor">
            <summary>实例化一个资源池</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Item.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Item.LastTime">
            <summary>过期时间</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Get">
            <summary>借出</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnGet(`0)">
            <summary>借出时是否可用</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.GetItem">
            <summary>申请资源包装项，Dispose时自动归还到池中</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnPut(`0)">
            <summary>归还时是否可用</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Return(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnReturn(`0)">
            <summary>归还时是否可用</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Clear">
            <summary>清空已有对象</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnDispose(`0)">
            <summary>销毁</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Total">
            <summary>总请求数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Success">
            <summary>成功数</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._NewCount">
            <summary>新创建数</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._ReleaseCount">
            <summary>释放数</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1.Cost">
            <summary>平均耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Collections.PoolItem`1">
            <summary>资源池包装项，自动归还资源到池中</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.PoolItem`1.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.PoolItem`1.Pool">
            <summary>池</summary>
        </member>
        <member name="M:NewLife.Collections.PoolItem`1.#ctor(NewLife.Collections.IPool{`0},`0)">
            <summary>包装项</summary>
            <param name="pool"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.PoolItem`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Collections.Pool`1">
            <summary>轻量级对象池。数组无锁实现，高性能</summary>
            <remarks>
            文档 https://newlifex.com/core/object_pool
            内部 1+N 的存储结果，保留最热的一个对象在外层，便于快速存取。
            数组具有极快的查找速度，结构体确保没有GC操作。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.Pool`1.Max">
            <summary>对象池大小。默认CPU*2，初始化后改变无效</summary>
        </member>
        <member name="M:NewLife.Collections.Pool`1.#ctor(System.Int32)">
            <summary>实例化对象池。默认大小CPU*2</summary>
            <param name="max"></param>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Get">
            <summary>获取</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Return(`0)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Clear">
            <summary>清空</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.IDisposable2">
            <summary>具有是否已释放和释放后事件的接口</summary>
        </member>
        <member name="P:NewLife.IDisposable2.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.IDisposable2.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="T:NewLife.DisposeBase">
            <summary>具有销毁资源处理的抽象基类</summary>
            <remarks>
            文档 https://newlifex.com/core/disposebase
            </remarks>
            <example>
            <code>
            /// &lt;summary&gt;子类重载实现资源释放逻辑时必须首先调用基类方法&lt;/summary&gt;
            /// &lt;param name="disposing"&gt;从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            /// 因为该方法只会被调用一次，所以该参数的意义不太大。&lt;/param&gt;
            protected override void Dispose(bool disposing)
            {
                base.OnDispose(disposing);
            
                if (disposing)
                {
                    // 如果是析构函数进来，不执行这里的代码
                }
            }
            </code>
            </example>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="P:NewLife.DisposeBase.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.DisposeBase.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose(System.Boolean)">
            <summary>释放资源，参数表示是否由Dispose调用。重载时先调用基类方法</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.DisposeBase.Finalize">
            <summary>析构函数</summary>
            <remarks>
            如果忘记调用Dispose，这里会释放非托管资源。
            如果曾经调用过Dispose，因为GC.SuppressFinalize(this)，不会再调用该析构函数。
            在 .NET 中，析构函数（Finalizer）不应该抛出未捕获的异常。如果析构函数引发未捕获的异常，它将导致应用程序崩溃或进程退出。
            </remarks>
        </member>
        <member name="T:NewLife.DisposeHelper">
            <summary>销毁助手。扩展方法专用</summary>
        </member>
        <member name="M:NewLife.DisposeHelper.TryDispose(System.Object)">
            <summary>尝试销毁对象，如果有<see cref="T:System.IDisposable"/>则调用</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IMachineInfo">
            <summary>机器信息接口</summary>
            <remarks>用于扩展MachineInfo功能，具体应用自定义各字段获取方式</remarks>
        </member>
        <member name="M:NewLife.IMachineInfo.Init(NewLife.MachineInfo)">
            <summary>初始化静态数据</summary>
        </member>
        <member name="M:NewLife.IMachineInfo.Refresh(NewLife.MachineInfo)">
            <summary>刷新动态数据</summary>
        </member>
        <member name="T:NewLife.MachineInfo">
            <summary>机器信息</summary>
            <remarks>
            文档 https://newlifex.com/core/machine_info
            
            刷新信息成本较高，建议采用单例模式
            </remarks>
        </member>
        <member name="P:NewLife.MachineInfo.OSName">
            <summary>系统名称</summary>
        </member>
        <member name="P:NewLife.MachineInfo.OSVersion">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Product">
            <summary>产品名称</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Vendor">
            <summary>制造商</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Processor">
            <summary>处理器型号</summary>
        </member>
        <member name="P:NewLife.MachineInfo.UUID">
            <summary>硬件唯一标识。取主板编码，部分品牌存在重复</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Guid">
            <summary>软件唯一标识。系统标识，操作系统重装后更新，Linux系统的machine_id，Android的android_id，Ghost系统存在重复</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Serial">
            <summary>计算机序列号。适用于品牌机，跟笔记本标签显示一致</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Board">
            <summary>主板。序列号或家族信息</summary>
        </member>
        <member name="P:NewLife.MachineInfo.DiskID">
            <summary>磁盘序列号</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Memory">
            <summary>内存总量。单位Byte</summary>
        </member>
        <member name="P:NewLife.MachineInfo.AvailableMemory">
            <summary>可用内存。单位Byte</summary>
        </member>
        <member name="P:NewLife.MachineInfo.CpuRate">
            <summary>CPU占用率</summary>
        </member>
        <member name="P:NewLife.MachineInfo.UplinkSpeed">
            <summary>网络上行速度。字节每秒，初始化后首次读取为0</summary>
        </member>
        <member name="P:NewLife.MachineInfo.DownlinkSpeed">
            <summary>网络下行速度。字节每秒，初始化后首次读取为0</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Temperature">
            <summary>温度。单位度</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Battery">
            <summary>电池剩余。小于1的小数，常用百分比表示</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Item(System.String)">
            <summary>获取 或 设置 扩展属性数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.MachineInfo.Current">
            <summary>当前机器信息。默认null，在RegisterAsync后才能使用</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Provider">
            <summary>机器信息提供者。外部实现可修改部分行为</summary>
        </member>
        <member name="M:NewLife.MachineInfo.RegisterAsync">
            <summary>异步注册一个初始化后的机器信息实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.GetCurrent">
            <summary>获取当前信息，如果未设置则等待异步注册结果</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.Resolve">
            <summary>从对象容器中获取一个已注册机器信息实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.Init">
            <summary>初始化静态数据。可能是实例化后执行，也可能是Json反序列化后执行</summary>
        </member>
        <member name="M:NewLife.MachineInfo.Refresh">
            <summary>获取实时数据，如CPU、内存、温度</summary>
        </member>
        <member name="M:NewLife.MachineInfo.RefreshSpeed">
            <summary>刷新网络速度</summary>
        </member>
        <member name="M:NewLife.MachineInfo.GetLinuxName">
            <summary>获取Linux发行版名称</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.ReadInfo(System.String,System.Char)">
            <summary>读取文件信息，分割为字典</summary>
            <param name="file"></param>
            <param name="separate"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.ReadPowerShell(System.String)">
            <summary>
            通过 PowerShell 命令读取信息
            </summary>
        </member>
        <member name="M:NewLife.MachineInfo.ReadWmic(System.String,System.String[])">
            <summary>通过WMIC命令读取信息</summary>
            <param name="type"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.ReadDeviceInfo">
            <summary>
            获取设备信息。用于Xamarin
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.ReadDeviceBattery">
            <summary>
            获取设备电量。用于 Xamarin
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.GetFreeSpace(System.String)">
            <summary>获取指定目录所在盘可用空间，默认当前目录</summary>
            <param name="path"></param>
            <returns>返回可用空间，字节，获取失败返回-1</returns>
        </member>
        <member name="M:NewLife.MachineInfo.GetFiles(System.String,System.Boolean)">
            <summary>获取指定目录下文件名，支持去掉后缀的去重，主要用于Linux</summary>
            <param name="path"></param>
            <param name="trimSuffix"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.GetInfo(System.String,System.String,System.String)">
            <summary>获取WMI信息</summary>
            <param name="path"></param>
            <param name="property"></param>
            <param name="nameSpace"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Common.PinYin">
            <summary>汉字拼音转换类</summary>
            <remarks>
            文档 https://newlifex.com/core/pinyin
            </remarks>
        </member>
        <member name="F:NewLife.Common.PinYin._py2">
            <summary>二级汉字数组</summary>
        </member>
        <member name="F:NewLife.Common.PinYin._pyValue2">
            <summary>二级汉字对应拼音数组</summary>
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirst(System.Char)">
            <summary>取字符的拼音首字母</summary>        
            <param name="ch"></param>        
            <returns></returns>        
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirst(System.String)">
            <summary>取字符串各字符的拼音首字母</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.Get(System.Char)">
            <summary>获取单字拼音</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.GetAll(System.String)">
            <summary>把汉字转换成拼音(全拼)</summary>
            <param name="str">汉字字符串</param>
            <returns>转换后的拼音(全拼)字符串</returns>
        </member>
        <member name="M:NewLife.Common.PinYin.Get(System.String)">
            <summary>把汉字转换成拼音(全拼)</summary>
            <param name="str">汉字字符串</param>
            <returns>转换后的拼音(全拼)字符串</returns>
        </member>
        <member name="T:NewLife.Common.SysConfig">
            <summary>系统设置。提供系统名称、版本等基本设置</summary>
            <remarks>
            文档 https://newlifex.com/core/sysconfig
            </remarks>
        </member>
        <member name="P:NewLife.Common.SysConfig.Name">
            <summary>系统名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Version">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.DisplayName">
            <summary>显示名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Company">
            <summary>公司</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Instance">
            <summary>应用实例。单应用多实例部署时用于唯一标识实例节点</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Develop">
            <summary>开发者模式</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.InstallTime">
            <summary>安装时间</summary>
        </member>
        <member name="M:NewLife.Common.SysConfig.OnLoaded">
            <summary>加载后触发</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.SysAssembly">
            <summary>系统主程序集</summary>
        </member>
        <member name="T:NewLife.Runtime">
            <summary>运行时</summary>
            <remarks>
            文档 https://newlifex.com/core/runtime
            </remarks>
        </member>
        <member name="P:NewLife.Runtime.IsConsole">
            <summary>是否控制台。用于判断是否可以执行一些控制台操作。</summary>
        </member>
        <member name="P:NewLife.Runtime.Container">
            <summary>是否在容器中运行</summary>
        </member>
        <member name="P:NewLife.Runtime.Mono">
            <summary>是否Mono环境</summary>
        </member>
        <member name="P:NewLife.Runtime.IsWeb">
            <summary>是否Web环境</summary>
        </member>
        <member name="P:NewLife.Runtime.Windows">
            <summary>是否Windows环境</summary>
        </member>
        <member name="P:NewLife.Runtime.Linux">
            <summary>是否Linux环境</summary>
        </member>
        <member name="P:NewLife.Runtime.OSX">
            <summary>是否OSX环境</summary>
        </member>
        <member name="P:NewLife.Runtime.TickCount64">
            <summary>系统启动以来的毫秒数</summary>
        </member>
        <member name="M:NewLife.Runtime.GetEnvironmentVariable(System.String)">
            <summary>
            获取环境变量。不区分大小写
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Runtime.GetEnvironmentVariables">
            <summary>
            获取环境变量集合。不区分大小写
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Runtime.CreateConfigOnMissing">
            <summary>默认配置。配置文件不存在时，是否生成默认配置文件</summary>
        </member>
        <member name="T:NewLife.Configuration.ApolloConfigProvider">
            <summary>阿波罗配置中心提供者</summary>
        </member>
        <member name="P:NewLife.Configuration.ApolloConfigProvider.NameSpace">
            <summary>命名空间。Apollo专用，多个命名空间用逗号或分号隔开</summary>
        </member>
        <member name="M:NewLife.Configuration.ApolloConfigProvider.ToString">
            <summary>已重载。输出友好信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ApolloConfigProvider.SetApollo(System.String)">
            <summary>设置阿波罗服务端</summary>
            <param name="nameSpaces">命名空间。多个命名空间用逗号或分号隔开</param>
        </member>
        <member name="M:NewLife.Configuration.ApolloConfigProvider.LoadApollo(System.String,System.String)">
            <summary>从本地配置文件读取阿波罗地址，并得到阿波罗配置提供者</summary>
            <param name="fileName">阿波罗配置文件名，默认appsettings.json</param>
            <param name="path">加载路径，默认apollo</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ApolloConfigProvider.GetAll">
            <summary>获取所有配置</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ApolloConfigProvider.SetAll(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>设置配置项，保存到服务端</summary>
            <param name="configs"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.CommandParser">
            <summary>命令分析器</summary>
        </member>
        <member name="P:NewLife.Configuration.CommandParser.IgnoreCase">
            <summary>不区分大小写</summary>
        </member>
        <member name="P:NewLife.Configuration.CommandParser.TrimStart">
            <summary>去除前导横杠。默认true</summary>
        </member>
        <member name="M:NewLife.Configuration.CommandParser.Parse(System.String[])">
            <summary>分析参数数组，得到名值字段</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.CommandParser.TrimQuote(System.String)">
            <summary>去除两头的双引号</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.CommandParser.Split(System.String)">
            <summary>把字符串分割为参数数组，支持双引号</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.CompositeConfigProvider">
            <summary>复合配置提供者。常用于本地配置与网络配置的混合</summary>
        </member>
        <member name="P:NewLife.Configuration.CompositeConfigProvider.Configs">
            <summary>日志提供者集合</summary>
            <remarks>为了线程安全，使用数组</remarks>
        </member>
        <member name="P:NewLife.Configuration.CompositeConfigProvider.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Configuration.CompositeConfigProvider.Root">
            <summary>根元素</summary>
        </member>
        <member name="P:NewLife.Configuration.CompositeConfigProvider.Keys">
            <summary>所有键</summary>
        </member>
        <member name="P:NewLife.Configuration.CompositeConfigProvider.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="P:NewLife.Configuration.CompositeConfigProvider.GetConfig">
            <summary>返回获取配置的委托</summary>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.#ctor(NewLife.Configuration.IConfigProvider,NewLife.Configuration.IConfigProvider)">
            <summary>实例化</summary>
            <param name="configProvider1"></param>
            <param name="configProvider2"></param>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.Add(NewLife.Configuration.IConfigProvider[])">
            <summary>添加</summary>
            <param name="configProviders"></param>
        </member>
        <member name="P:NewLife.Configuration.CompositeConfigProvider.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.GetSection(System.String)">
            <summary>查找配置项。可得到子级和配置</summary>
            <param name="key">配置名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.LoadAll">
            <summary>从数据源加载数据到配置树</summary>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.Load``1(System.String)">
            <summary>加载配置到模型</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.Save``1(``0,System.String)">
            <summary>保存模型实例</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="path">路径。配置树位置</param>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.Bind``1(``0,System.String,System.Action{NewLife.Configuration.IConfigSection})">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
            <param name="onChange">配置改变时执行的委托</param>
        </member>
        <member name="M:NewLife.Configuration.CompositeConfigProvider.NotifyChange">
            <summary>通知绑定对象，配置数据有改变</summary>
        </member>
        <member name="E:NewLife.Configuration.CompositeConfigProvider.Changed">
            <summary>配置改变事件。执行了某些动作，可能导致配置数据发生改变时触发</summary>
        </member>
        <member name="T:NewLife.Configuration.Config`1">
            <summary>配置文件基类</summary>
            <remarks>
            标准用法：TConfig.Current
            
            配置实体类通过<see cref="T:NewLife.Configuration.ConfigAttribute"/>特性指定配置文件路径。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="P:NewLife.Configuration.Config`1.Provider">
            <summary>当前使用的提供者</summary>
        </member>
        <member name="P:NewLife.Configuration.Config`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="P:NewLife.Configuration.Config`1.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Configuration.Config`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Configuration.Config`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="T:NewLife.Configuration.ConfigAttribute">
            <summary>配置特性</summary>
            <remarks>
            声明配置模型使用哪一种配置提供者，以及所需要的文件名和分类名。
            如未指定提供者，则使用全局默认，此时将根据全局代码配置或环境变量配置使用不同提供者，实现配置信息整体转移。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.ConfigAttribute.Provider">
            <summary>提供者。内置ini/xml/json/http，一般不指定，使用全局默认</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigAttribute.Name">
            <summary>配置名。可以是文件名或分类名</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigAttribute.#ctor(System.String,System.String)">
            <summary>指定配置名</summary>
            <param name="name">配置名。可以是文件名或分类名</param>
            <param name="provider">提供者。内置ini/xml/json/http，一般不指定，使用全局默认</param>
        </member>
        <member name="T:NewLife.Configuration.HttpConfigAttribute">
            <summary>http配置特性</summary>
            <remarks>
            声明配置模型使用哪一种配置提供者，以及所需要的文件名和分类名。
            如未指定提供者，则使用全局默认，此时将根据全局代码配置或环境变量配置使用不同提供者，实现配置信息整体转移。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigAttribute.Server">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigAttribute.Action">
            <summary>服务操作</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigAttribute.AppId">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigAttribute.Secret">
            <summary>应用密钥</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigAttribute.Scope">
            <summary>作用域。获取指定作用域下的配置值，生产、开发、测试 等</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigAttribute.CacheLevel">
            <summary>本地缓存配置数据。即使网络断开，仍然能够加载使用本地数据，默认Encrypted</summary>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigAttribute.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,NewLife.Configuration.ConfigCacheLevel)">
            <summary>指定配置名</summary>
            <param name="server">服务器地址</param>
            <param name="action">服务操作</param>
            <param name="name">配置名。可以是文件名或分类名</param>
            <param name="appId">应用标识</param>
            <param name="secret">应用密钥</param>
            <param name="scope">作用域。获取指定作用域下的配置值，生产、开发、测试 等</param>
            <param name="cacheLevel">本地缓存配置数据。即使网络断开，仍然能够加载使用本地数据，默认Encrypted</param>
        </member>
        <member name="T:NewLife.Configuration.ConfigCacheLevel">
            <summary>配置数据缓存等级</summary>
        </member>
        <member name="F:NewLife.Configuration.ConfigCacheLevel.NoCache">
            <summary>不缓存</summary>
        </member>
        <member name="F:NewLife.Configuration.ConfigCacheLevel.Json">
            <summary>Json格式缓存</summary>
        </member>
        <member name="F:NewLife.Configuration.ConfigCacheLevel.Encrypted">
            <summary>加密缓存</summary>
        </member>
        <member name="T:NewLife.Configuration.ConfigHelper">
            <summary>配置助手</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.Find(NewLife.Configuration.IConfigSection,System.String,System.Boolean)">
            <summary>查找配置项。可得到子级和配置</summary>
            <param name="section"></param>
            <param name="key"></param>
            <param name="createOnMiss"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.AddChild(NewLife.Configuration.IConfigSection,System.String)">
            <summary>添加子节点</summary>
            <param name="section"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.GetOrAddChild(NewLife.Configuration.IConfigSection,System.String)">
            <summary>查找或添加子节点</summary>
            <param name="section"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.SetValue(NewLife.Configuration.IConfigSection,System.Object)">
            <summary>设置节点值。格式化友好字符串</summary>
            <param name="section"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.MapTo(NewLife.Configuration.IConfigSection,System.Object,NewLife.Configuration.IConfigProvider)">
            <summary>映射配置树到实例公有属性</summary>
            <param name="section">数据源</param>
            <param name="model">模型</param>
            <param name="provider">提供者</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.MapFrom(NewLife.Configuration.IConfigSection,System.Object)">
            <summary>从实例公有属性映射到配置树</summary>
            <param name="section"></param>
            <param name="model"></param>
        </member>
        <member name="T:NewLife.Configuration.FileConfigProvider">
            <summary>文件配置提供者</summary>
            <remarks>
            每个提供者实例对应一个配置文件，支持热更新
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.FileConfigProvider.FileName">
            <summary>文件名。最高优先级，优先于模型特性指定的文件名</summary>
        </member>
        <member name="P:NewLife.Configuration.FileConfigProvider.Period">
            <summary>更新周期。默认5秒</summary>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.ToString">
            <summary>已重载。输出友好信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.LoadAll">
            <summary>加载配置</summary>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Save``1(``0,System.String)">
            <summary>保存模型实例</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="path">路径。配置树位置</param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.OnWrite(System.String,NewLife.Configuration.IConfigSection)">
            <summary>写入配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="T:NewLife.Configuration.GetConfigCallback">
            <summary>获取配置委托。便于集成配置中心</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.HttpConfigProvider">
            <summary>配置中心提供者</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.Server">
            <summary>服务器</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.Action">
            <summary>服务操作 默认:Config/GetAll</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.AppId">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.Secret">
            <summary>应用密钥</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.ClientId">
            <summary>实例。应用可能多实例部署，ip@proccessid</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.Scope">
            <summary>作用域。获取指定作用域下的配置值，生产、开发、测试 等</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.CacheLevel">
            <summary>本地缓存配置数据。即使网络断开，仍然能够加载使用本地数据，默认Encrypted</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.Period">
            <summary>更新周期。默认60秒，0秒表示不做自动更新</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.Client">
            <summary>Api客户端</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.Info">
            <summary>服务器信息。配置中心最后一次接口响应，包含配置数据以外的其它内容</summary>
        </member>
        <member name="P:NewLife.Configuration.HttpConfigProvider.IgnoreChangedKeys">
            <summary>需要忽略改变的键。这些键的改变不产生改变事件</summary>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.#ctor">
            <summary>实例化Http配置提供者，对接星尘和阿波罗等配置中心</summary>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.ToString">
            <summary>已重载。输出友好信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.GetClient">
            <summary>获取客户端</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.GetAll">
            <summary>获取所有配置</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.SetAll(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>设置配置项，保存到服务端</summary>
            <param name="configs"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.Init(System.String)">
            <summary>初始化提供者，如有必要，此时加载缓存文件</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.Build(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>加载配置字典为配置树</summary>
            <param name="configs"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.LoadAll">
            <summary>加载配置</summary>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="F:NewLife.Configuration.HttpConfigProvider._timer">
            <summary>定时器</summary>
        </member>
        <member name="M:NewLife.Configuration.HttpConfigProvider.DoRefresh(System.Object)">
            <summary>定时刷新配置</summary>
            <param name="state"></param>
        </member>
        <member name="T:NewLife.Configuration.IConfigMapping">
            <summary>配置映射接口。用于自定义映射配置树到当前对象</summary>
            <remarks>
            整体配置数据改变时触发调用该接口，但不表示当前对象所绑定路径的配置数据有改变，用户需要自己判断所属配置数据是否已改变。
            </remarks>
        </member>
        <member name="M:NewLife.Configuration.IConfigMapping.MapConfig(NewLife.Configuration.IConfigProvider,NewLife.Configuration.IConfigSection)">
            <summary>映射配置树到当前对象</summary>
            <param name="provider">配置提供者</param>
            <param name="section">配置数据段</param>
        </member>
        <member name="T:NewLife.Configuration.IConfigProvider">
            <summary>配置提供者</summary>
            <remarks>
            建立树状配置数据体系，以分布式配置中心为核心，支持基于key的索引读写，也支持Load/Save/Bind的实体模型转换。
            key索引支持冒号分隔的多层结构，在配置中心中不同命名空间使用不同提供者实例，在文件配置中不同文件使用不同提供者实例。
            
            一个配置类，支持从不同持久化提供者读取，可根据需要选择配置持久化策略。
            例如，小系统采用ini/xml/json文件配置，分布式系统采用配置中心。
            
            可通过实现IConfigMapping接口来自定义映射配置到模型实例。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Root">
            <summary>根元素</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Keys">
            <summary>所有键</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">配置名，支持冒号分隔的多级名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.GetSection(System.String)">
            <summary>查找配置项。可得到子级和配置</summary>
            <param name="key">配置名</param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Configuration.IConfigProvider.Changed">
            <summary>配置改变事件。执行了某些动作，可能导致配置数据发生改变时触发</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.GetConfig">
            <summary>返回获取配置的委托</summary>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.LoadAll">
            <summary>从数据源加载数据到配置树</summary>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Load``1(System.String)">
            <summary>加载配置到模型</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Save``1(``0,System.String)">
            <summary>保存模型实例</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Bind``1(``0,System.String,System.Action{NewLife.Configuration.IConfigSection})">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
            <param name="onChange">配置改变时执行的委托</param>
        </member>
        <member name="T:NewLife.Configuration.ConfigProvider">
            <summary>配置提供者基类</summary>
            <remarks>
            同时也是基于Items字典的内存配置提供者。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Root">
            <summary>根元素</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Keys">
            <summary>所有键</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.UsedKeys">
            <summary>已使用的键</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.MissedKeys">
            <summary>缺失的键</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.GetConfig">
            <summary>返回获取配置的委托</summary>
        </member>
        <member name="E:NewLife.Configuration.ConfigProvider.Changed">
            <summary>配置改变事件。执行了某些动作，可能导致配置数据发生改变时触发</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.#ctor">
            <summary>构造函数</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.GetSection(System.String)">
            <summary>查找配置项。可得到子级和配置</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Find(System.String,System.Boolean)">
            <summary>查找配置项，可指定是否创建</summary>
            <remarks>配置提供者可以重载该方法以实现增强功能。例如星尘配置从注册中心读取数据</remarks>
            <param name="key"></param>
            <param name="createOnMiss"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Init(System.String)">
            <summary>初始化提供者</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.LoadAll">
            <summary>从数据源加载数据到配置树</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Load``1(System.String)">
            <summary>加载配置到模型</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Save``1(``0,System.String)">
            <summary>保存模型实例</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="path">路径。配置树位置</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Bind``1(``0,System.String,System.Action{NewLife.Configuration.IConfigSection})">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
            <param name="onChange">配置改变时执行的委托</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.NotifyChange">
            <summary>通知绑定对象，配置数据有改变</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.DefaultProvider">
            <summary>默认提供者。默认xml</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Register``1(System.String)">
            <summary>注册提供者</summary>
            <typeparam name="TProvider"></typeparam>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Create(System.String)">
            <summary>根据指定名称创建提供者</summary>
            <remarks>
            如果是文件名，根据后缀确定使用哪一种提供者。
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.IConfigSection">
            <summary>配置对象</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Key">
            <summary>配置名</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Value">
            <summary>配置值</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Comment">
            <summary>注释</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Childs">
            <summary>子级</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">配置名，支持冒号分隔的多级名称</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.ConfigSection">
            <summary>配置项</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Key">
            <summary>配置名</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Value">
            <summary>配置值</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Comment">
            <summary>注释</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Childs">
            <summary>子级</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigSection.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.InIConfigProvider">
            <summary>Ini文件配置提供者</summary>
            <remarks>
            支持从不同配置文件加载到不同配置模型
            </remarks>
        </member>
        <member name="M:NewLife.Configuration.InIConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.InIConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.InIConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.JsonConfigProvider">
            <summary>Json文件配置提供者</summary>
            <remarks>
            支持从不同配置文件加载到不同配置模型
            </remarks>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.LoadAppSettings(System.String)">
            <summary>加载本地配置文件得到配置提供者</summary>
            <param name="fileName">配置文件名，默认appsettings.json</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.Map(System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Configuration.IConfigSection)">
            <summary>字典映射到配置树</summary>
            <param name="src"></param>
            <param name="section"></param>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.Map(NewLife.Configuration.IConfigSection,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>配置树映射到字典</summary>
            <param name="section"></param>
            <param name="dst"></param>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.TrimComment(System.String)">
            <summary>
            清理json字符串中的注释，避免json解析错误
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.XmlConfigProvider">
            <summary>Xml文件配置提供者</summary>
            <remarks>
            支持从不同配置文件加载到不同配置模型
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.XmlConfigProvider.RootName">
            <summary>根元素名称</summary>
        </member>
        <member name="M:NewLife.Configuration.XmlConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.XmlConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.XmlConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.DbRow">
            <summary>数据行</summary>
            <remarks>
            文档 https://newlifex.com/core/dbtable
            </remarks>
            <remarks>构造数据行</remarks>
            <param name="table"></param>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Data.DbRow.#ctor(NewLife.Data.DbTable,System.Int32)">
            <summary>数据行</summary>
            <remarks>
            文档 https://newlifex.com/core/dbtable
            </remarks>
            <remarks>构造数据行</remarks>
            <param name="table"></param>
            <param name="index"></param>
        </member>
        <member name="P:NewLife.Data.DbRow.Table">
            <summary>数据表</summary>
        </member>
        <member name="P:NewLife.Data.DbRow.Index">
            <summary>行索引</summary>
        </member>
        <member name="P:NewLife.Data.DbRow.Item(System.Int32)">
            <summary>基于列索引访问</summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Data.DbRow.Item(System.String)">
            <summary>基于列名访问</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbRow.Get``1(System.String)">
            <summary>读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.DbTable">
            <summary>数据表</summary>
            <remarks>
            文档 https://newlifex.com/core/dbtable
            </remarks>
        </member>
        <member name="P:NewLife.Data.DbTable.Columns">
            <summary>数据列</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Types">
            <summary>数据列类型</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Rows">
            <summary>数据行</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Total">
            <summary>总行数</summary>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(System.Data.IDataReader)">
            <summary>读取数据</summary>
            <param name="dr"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadHeader(System.Data.IDataReader)">
            <summary>读取头部</summary>
            <param name="dr"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadData(System.Data.IDataReader,System.Int32[])">
            <summary>读取数据</summary>
            <param name="dr">数据读取器</param>
            <param name="fields">要读取的字段序列</param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadAsync(System.Data.Common.DbDataReader,System.Threading.CancellationToken)">
            <summary>读取数据</summary>
            <param name="dr"></param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadDataAsync(System.Data.Common.DbDataReader,System.Int32[],System.Threading.CancellationToken)">
            <summary>读取数据</summary>
            <param name="dr">数据读取器</param>
            <param name="fields">要读取的字段序列</param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(System.Data.DataTable)">
            <summary>从DataTable读取数据</summary>
            <param name="dataTable">数据表</param>
        </member>
        <member name="M:NewLife.Data.DbTable.ToDataTable">
            <summary>转换为DataTable</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Write(System.Data.DataTable)">
            <summary>转换为DataTable</summary>
            <param name="dataTable">数据表</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(System.IO.Stream)">
            <summary>从数据流读取</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadHeader(NewLife.Serialization.Binary)">
            <summary>读取头部</summary>
            <param name="bn"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadData(NewLife.Serialization.Binary,System.Int32)">
            <summary>读取数据</summary>
            <param name="bn"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(NewLife.Data.Packet)">
            <summary>读取</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.LoadFile(System.String,System.Boolean)">
            <summary>从文件加载</summary>
            <param name="file"></param>
            <param name="compressed">是否压缩</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Write(System.IO.Stream)">
            <summary>写入数据流</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteHeader(NewLife.Serialization.Binary)">
            <summary>写入头部到数据流</summary>
            <param name="bn"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteData(NewLife.Serialization.Binary)">
            <summary>写入数据部分到数据流</summary>
            <param name="bn"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteData(NewLife.Serialization.Binary,System.Int32[])">
            <summary>写入数据部分到数据流</summary>
            <param name="bn"></param>
            <param name="fields">要写入的字段序列</param>
        </member>
        <member name="M:NewLife.Data.DbTable.ToPacket">
            <summary>转数据包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.SaveFile(System.String,System.Boolean)">
            <summary>保存到文件</summary>
            <param name="file"></param>
            <param name="compressed">是否压缩</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToJson(System.Boolean,System.Boolean,System.Boolean)">
            <summary>转Json字符串</summary>
            <param name="indented">是否缩进。默认false</param>
            <param name="nullValue">是否写空值。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToDictionary">
            <summary>转为字典数组形式</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetXml">
            <summary>转Xml字符串</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteXml(System.IO.Stream)">
            <summary>以Xml格式写入数据流中</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.SaveCsv(System.String)">
            <summary>保存到Csv文件</summary>
            <param name="file"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.LoadCsv(System.String)">
            <summary>从Csv文件加载</summary>
            <param name="file"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteModels``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>写入模型列表</summary>
            <typeparam name="T"></typeparam>
            <param name="models"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadModels``1">
            <summary>数据表转模型列表。普通反射，便于DAL查询后转任意模型列表</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadModels(System.Type)">
            <summary>数据表转模型列表。普通反射，便于DAL查询后转任意模型列表</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Get``1(System.Int32,System.String)">
            <summary>读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="row"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.TryGet``1(System.Int32,System.String,``0@)">
            <summary>尝试读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="row"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetColumn(System.String)">
            <summary>根据名称找字段序号</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToString">
            <summary>数据集</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetRow(System.Int32)">
            <summary>获取数据行</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetEnumerator">
            <summary>获取枚举</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoHash">
            <summary>经纬坐标的一维编码表示</summary>
            <remarks>
            文档 https://newlifex.com/core/geo_hash
            
            一维编码表示一个矩形区域，前缀表示更大区域，例如北京wx4fbzdvs80包含在wx4fbzdvs里面。
            这个特性可以用于附近地点搜索。
            GeoHash编码位数及距离关系：
            1位，+-2500km；
            2位，+-630km；
            3位，+-78km；
            4位，+-20km；
            5位，+-2.4km；
            6位，+-610m；
            7位，+-76m；
            8位，+-19m；
            9位，+-2m；
            </remarks>
        </member>
        <member name="M:NewLife.Data.GeoHash.Encode(System.Double,System.Double,System.Int32)">
            <summary>编码坐标点为GeoHash字符串</summary>
            <param name="longitude">经度</param>
            <param name="latitude">纬度</param>
            <param name="charCount">字符个数。默认9位字符编码，精度2米</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.GeoHash.Decode(System.String)">
            <summary>解码GeoHash字符串为坐标点</summary>
            <param name="geohash"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IData">
            <summary>数据帧接口。用于网络通信领域，定义数据帧的必要字段</summary>
        </member>
        <member name="P:NewLife.Data.IData.Packet">
            <summary>原始数据包</summary>
        </member>
        <member name="P:NewLife.Data.IData.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Data.IData.Message">
            <summary>解码后的消息</summary>
        </member>
        <member name="P:NewLife.Data.IData.UserState">
            <summary>用户自定义数据</summary>
        </member>
        <member name="T:NewLife.Data.IExtend">
            <summary>具有可读写的扩展数据</summary>
            <remarks>
            仅限于扩展属性，不包括基本属性，区别于 IModel
            </remarks>
        </member>
        <member name="P:NewLife.Data.IExtend.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Data.IExtend.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IExtend2">
            <summary>具有扩展数据字典</summary>
            <remarks>
            仅限于扩展属性，不包括基本属性
            </remarks>
        </member>
        <member name="P:NewLife.Data.IExtend2.Keys">
            <summary>扩展数据键集合</summary>
        </member>
        <member name="T:NewLife.Data.IExtend3">
            <summary>具有扩展数据字典</summary>
            <remarks>
            仅限于扩展属性，不包括基本属性
            </remarks>
        </member>
        <member name="T:NewLife.Data.IFilter">
            <summary>数据过滤器</summary>
        </member>
        <member name="P:NewLife.Data.IFilter.Next">
            <summary>下一个过滤器</summary>
        </member>
        <member name="M:NewLife.Data.IFilter.Execute(NewLife.Data.FilterContext)">
            <summary>对封包执行过滤器</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Data.FilterContext">
            <summary>过滤器上下文</summary>
        </member>
        <member name="P:NewLife.Data.FilterContext.Packet">
            <summary>封包</summary>
        </member>
        <member name="T:NewLife.Data.FilterHelper">
            <summary>过滤器助手</summary>
        </member>
        <member name="M:NewLife.Data.FilterHelper.Find(NewLife.Data.IFilter,System.Type)">
            <summary>在链条里面查找指定类型的过滤器</summary>
            <param name="filter"></param>
            <param name="filterType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.FilterBase">
            <summary>数据过滤器基类</summary>
        </member>
        <member name="P:NewLife.Data.FilterBase.Next">
            <summary>下一个过滤器</summary>
        </member>
        <member name="M:NewLife.Data.FilterBase.Execute(NewLife.Data.FilterContext)">
            <summary>对封包执行过滤器</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Data.FilterBase.OnExecute(NewLife.Data.FilterContext)">
            <summary>执行过滤</summary>
            <param name="context"></param>
            <returns>返回是否执行下一个过滤器</returns>
        </member>
        <member name="T:NewLife.Data.IModel">
            <summary>模型数据接口，支持索引器读写属性</summary>
            <remarks>
            可借助反射取得属性列表成员，从而对实体模型属性进行读写操作，避免反射带来的负担。
            常用于WebApi模型类以及XCode数据实体类，也用于魔方接口拷贝。
            
            逐步替代 IExtend 的大部分使用场景
            </remarks>
        </member>
        <member name="P:NewLife.Data.IModel.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IndexRange">
            <summary>
            范围
            </summary>
        </member>
        <member name="F:NewLife.Data.IndexRange.Start">
            <summary>
            开始，包含
            </summary>
        </member>
        <member name="F:NewLife.Data.IndexRange.End">
            <summary>
            结束，不包含
            </summary>
        </member>
        <member name="M:NewLife.Data.IndexRange.ToString">
            <summary>
            已重载
            </summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IPacketEncoder">
            <summary>数据包编码器接口</summary>
        </member>
        <member name="M:NewLife.Data.IPacketEncoder.Encode(System.Object)">
            <summary>数值转数据包</summary>
            <param name="value">数值对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.IPacketEncoder.Decode(NewLife.Data.Packet,System.Type)">
            <summary>数据包转对象</summary>
            <param name="data">数据包</param>
            <param name="type">目标类型</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.PackerEncoderExtensions">
            <summary>编码器扩展</summary>
        </member>
        <member name="M:NewLife.Data.PackerEncoderExtensions.Decode``1(NewLife.Data.IPacketEncoder,NewLife.Data.Packet)">
            <summary>数据包转对象</summary>
            <typeparam name="T">目标类型</typeparam>
            <param name="encoder"></param>
            <param name="data">数据包</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.DefaultPacketEncoder">
            <summary>默认数据包编码器。基础类型直接转，复杂类型Json序列化</summary>
        </member>
        <member name="P:NewLife.Data.DefaultPacketEncoder.JsonHost">
            <summary>Json序列化主机</summary>
        </member>
        <member name="P:NewLife.Data.DefaultPacketEncoder.ThrowOnError">
            <summary>解码出错时抛出异常。默认false不抛出异常，仅返回默认值</summary>
        </member>
        <member name="M:NewLife.Data.DefaultPacketEncoder.Encode(System.Object)">
            <summary>数值转数据包</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DefaultPacketEncoder.Decode(NewLife.Data.Packet,System.Type)">
            <summary>数据包转对象</summary>
            <param name="data"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.Packet">
            <summary>数据包。表示数据区Data的指定范围（Offset, Count）。</summary>
            <remarks>
            文档 https://newlifex.com/core/packet
            设计于.NET2.0时代，功能上类似于NETCore的Span/Memory。
            Packet的设计目标就是网络库零拷贝，所以Slice切片是其最重要功能。
            </remarks>
        </member>
        <member name="P:NewLife.Data.Packet.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Offset">
            <summary>偏移</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Count">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Next">
            <summary>下一个链式包</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Total">
            <summary>总长度</summary>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>根据数据区实例化</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.ArraySegment{System.Byte})">
            <summary>根据数组段实例化</summary>
            <param name="seg"></param>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.IO.Stream)">
            <summary>从可扩展内存流实例化，尝试窃取内存流内部的字节数组，失败后拷贝</summary>
            <remarks>因数据包内数组窃取自内存流，需要特别小心，避免多线程共用。常用于内存流转数据包，而内存流不再使用</remarks>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.Data.Packet.Item(System.Int32)">
            <summary>获取/设置 指定位置的字节</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Set(System.Byte[],System.Int32,System.Int32)">
            <summary>设置新的数据区</summary>
            <param name="data">数据区</param>
            <param name="offset">偏移</param>
            <param name="count">字节个数</param>
        </member>
        <member name="M:NewLife.Data.Packet.Slice(System.Int32,System.Int32)">
            <summary>截取子数据区</summary>
            <param name="offset">相对偏移</param>
            <param name="count">字节个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.IndexOf(System.Byte[],System.Int32,System.Int32)">
            <summary>查找目标数组</summary>
            <param name="data">目标数组</param>
            <param name="offset">本数组起始偏移</param>
            <param name="count">本数组搜索个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Append(NewLife.Data.Packet)">
            <summary>附加一个包到当前包链的末尾</summary>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Data.Packet.ToArray">
            <summary>返回字节数组。无差别复制，一定返回新数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ReadBytes(System.Int32,System.Int32)">
            <summary>从封包中读取指定数据区，读取全部时直接返回缓冲区，以提升性能</summary>
            <param name="offset">相对于数据包的起始位置，实际上是数组的Offset+offset</param>
            <param name="count">字节个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToSegment">
            <summary>返回数据段</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToSegments">
            <summary>返回数据段集合</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.GetStream">
            <summary>获取封包的数据流形式</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.CopyTo(System.IO.Stream)">
            <summary>把封包写入到数据流</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.Packet.WriteTo(System.Byte[],System.Int32,System.Int32)">
            <summary>把封包写入到目标数组</summary>
            <param name="buffer">目标数组</param>
            <param name="offset">目标数组的偏移量</param>
            <param name="count">目标数组的字节数</param>
        </member>
        <member name="M:NewLife.Data.Packet.CopyToAsync(System.IO.Stream)">
            <summary>异步复制到目标数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>异步复制到目标数据流</summary>
            <param name="stream"></param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Clone">
            <summary>深度克隆一份数据包，拷贝数据区</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToStr(System.Text.Encoding,System.Int32,System.Int32)">
            <summary>以字符串表示</summary>
            <param name="encoding">字符串编码，默认URF-8</param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToHex(System.Int32,System.String,System.Int32)">
            <summary>以十六进制编码表示</summary>
            <param name="maxLength">最大显示多少个字节。默认-1显示全部</param>
            <param name="separate">分隔符</param>
            <param name="groupSize">分组大小，为0时对每个字节应用分隔符，否则对每个分组使用</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToBase64">
            <summary>转为Base64编码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ReadUInt16(System.Boolean)">
            <summary>读取无符号短整数</summary>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ReadUInt32(System.Boolean)">
            <summary>读取无符号整数</summary>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.op_Implicit(System.Byte[])~NewLife.Data.Packet">
            <summary>重载类型转换，字节数组直接转为Packet对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.op_Implicit(System.ArraySegment{System.Byte})~NewLife.Data.Packet">
            <summary>重载类型转换，一维数组直接转为Packet对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.op_Implicit(System.String)~NewLife.Data.Packet">
            <summary>重载类型转换，字符串直接转为Packet对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.PageParameter">
            <summary>分页参数信息。可携带统计和数据权限扩展查询等信息</summary>
            <remarks>
            文档 https://newlifex.com/core/page_parameter
            </remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.Sort">
            <summary>获取 或 设置 排序字段，前台接收，便于做SQL安全性校验</summary>
            <remarks>
            一般用于接收单个排序字段，可以带上Asc/Desc，这里会自动拆分。
            极少数情况下，前端需要传递多个字段排序，这时候可以使用OrderBy。
            
            OrderBy优先级更高，且支持手写复杂排序语句（不做SQL安全性校验）。
            如果设置Sort，OrderBy将被清空。
            </remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.Desc">
            <summary>获取 或 设置 是否降序</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageIndex">
            <summary>获取 或 设置 页面索引。从1开始，默认1</summary>
            <remarks>如果设定了开始行，分页时将不再使用PageIndex</remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageSize">
            <summary>获取 或 设置 页面大小。默认20，若为0表示不分页</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.TotalCount">
            <summary>获取 或 设置 总记录数</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageCount">
            <summary>获取 页数</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.OrderBy">
            <summary>获取 或 设置 自定义排序字句。常用于用户自定义排序，不经过SQL安全性校验</summary>
            <remarks>
            OrderBy优先级更高，且支持手写复杂排序语句（不做SQL安全性校验）。
            如果设置Sort，OrderBy将被清空。
            </remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.StartRow">
            <summary>获取 或 设置 开始行</summary>
            <remarks>如果设定了开始行，分页时将不再使用PageIndex</remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.RetrieveTotalCount">
            <summary>获取 或 设置 是否获取总记录数，默认false</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.State">
            <summary>获取 或 设置 状态。用于传递统计、扩展查询等用户数据</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.RetrieveState">
            <summary>获取 或 设置 是否获取统计，默认false</summary>
        </member>
        <member name="M:NewLife.Data.PageParameter.#ctor">
            <summary>实例化分页参数</summary>
        </member>
        <member name="M:NewLife.Data.PageParameter.#ctor(NewLife.Data.PageParameter)">
            <summary>通过另一个分页参数来实例化当前分页参数</summary>
            <param name="pm"></param>
        </member>
        <member name="M:NewLife.Data.PageParameter.CopyFrom(NewLife.Data.PageParameter)">
            <summary>从另一个分页参数拷贝到当前分页参数</summary>
            <param name="pm"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.PageParameter.GetKey">
            <summary>获取表示分页参数唯一性的键值，可用作缓存键</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.RingBuffer">
            <summary>环形缓冲区。用于协议组包设计</summary>
        </member>
        <member name="P:NewLife.Data.RingBuffer.Capacity">
            <summary>容量</summary>
        </member>
        <member name="P:NewLife.Data.RingBuffer.Head">
            <summary>头指针。写入位置</summary>
        </member>
        <member name="P:NewLife.Data.RingBuffer.Tail">
            <summary>尾指针。读取位置</summary>
        </member>
        <member name="P:NewLife.Data.RingBuffer.Length">
            <summary>数据长度</summary>
        </member>
        <member name="M:NewLife.Data.RingBuffer.#ctor">
            <summary>使用默认容量1024来初始化</summary>
        </member>
        <member name="M:NewLife.Data.RingBuffer.#ctor(System.Int32)">
            <summary>实例化环形缓冲区</summary>
            <param name="capacity">容量。合理的容量能够减少扩容</param>
        </member>
        <member name="M:NewLife.Data.RingBuffer.EnsureCapacity(System.Int32)">
            <summary>扩容，确保容量</summary>
            <param name="capacity"></param>
        </member>
        <member name="M:NewLife.Data.RingBuffer.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>写入数据</summary>
            <param name="data">数据</param>
            <param name="offset">偏移量</param>
            <param name="count">个数</param>
        </member>
        <member name="M:NewLife.Data.RingBuffer.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>读取数据</summary>
            <param name="data">数据</param>
            <param name="offset">偏移量</param>
            <param name="count">个数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.Snowflake">
            <summary>雪花算法。分布式Id，业务内必须确保单例</summary>
            <remarks>
            文档 https://newlifex.com/core/snow_flake
            
            使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增。
            1bit保留 + 41bit时间戳 + 10bit机器 + 12bit序列号
            
            内置自动选择机器workerId，IP+进程+线程，无法绝对保证唯一，从而导致整体生成的雪花Id有一定几率重复。
            如果想要绝对唯一，建议在外部设置唯一的workerId，再结合单例使用，此时确保最终生成的Id绝对不重复！
            高要求场合，推荐使用Redis自增序数作为workerId，在大型分布式系统中亦能保证绝对唯一。
            已提供JoinCluster方法，用于把当前对象加入集群，确保workerId唯一。
            
            务必请保证Snowflake对象的唯一性，Snowflake确保本对象生成的Id绝对唯一，但如果有多个Snowflake对象，可能会生成重复Id。
            特别在使用XCode等数据中间件时，要确保每张表只有一个Snowflake实例。
            </remarks>
        </member>
        <member name="P:NewLife.Data.Snowflake.StartTimestamp">
            <summary>开始时间戳。首次使用前设置，否则无效，默认1970-1-1</summary>
            <remarks>
            该时间戳默认已带有时区偏移，不管是为本地时间还是UTC时间生成雪花Id，都是一样的时间大小。
            默认值本质上就是UTC 1970-1-1，转本地时间是为了方便解析雪花Id时得到的时间就是本地时间，最大兼容已有业务。
            在星尘和IoT的自动分表场景中，一般需要用本地时间来作为分表依据，所以默认值是本地时间。
            </remarks>
        </member>
        <member name="P:NewLife.Data.Snowflake.WorkerId">
            <summary>机器Id，取10位</summary>
            <remarks>
            内置默认取IP+进程+线程，不能保证绝对唯一，要求高的场合建议外部保证workerId唯一。
            一般借助Redis自增序数作为workerId，确保绝对唯一。
            如果应用接入星尘，将自动从星尘配置中心获取workerId，确保全局唯一。
            </remarks>
        </member>
        <member name="P:NewLife.Data.Snowflake.Sequence">
            <summary>序列号，取12位。进程内静态，避免多个实例生成重复Id</summary>
        </member>
        <member name="P:NewLife.Data.Snowflake.GlobalWorkerId">
            <summary>全局机器Id。若设置，所有雪花实例都将使用该Id，可以由星尘配置中心提供本应用全局唯一机器码，且跨多环境唯一</summary>
        </member>
        <member name="P:NewLife.Data.Snowflake.Cluster">
            <summary>workerId分配集群。配置后可确保所有实例化的雪花对象得到唯一workerId，建议使用Redis</summary>
        </member>
        <member name="M:NewLife.Data.Snowflake.NewId">
            <summary>获取下一个Id</summary>
            <remarks>基于当前时间，转StartTimestamp所属时区后，生成Id</remarks>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.NewId(System.DateTime)">
            <summary>获取指定时间的Id，带上节点和序列号。可用于根据业务时间构造插入Id</summary>
            <remarks>
            基于指定时间，转StartTimestamp所属时区后，生成Id。
            
            如果为指定毫秒时间生成多个Id（超过4096），则可能重复。
            </remarks>
            <param name="time">时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.NewId(System.DateTime,System.Int32)">
            <summary>获取指定时间的Id，传入唯一业务id（取模为10位）。可用于物联网数据采集，每1024个传感器为一组，每组每毫秒多个Id</summary>
            <remarks>
            基于指定时间，转StartTimestamp所属时区后，生成Id。
            
            在物联网数据采集中，数据分析需要，更多希望能够按照采集时间去存储。
            为了避免主键重复，可以使用传感器id作为workerId。
            uid需要取模为10位，即按1024分组，每组每毫秒最多生成4096个Id。
            
            如果为指定分组在特定毫秒时间生成多个Id（超过4096），则可能重复。
            </remarks>
            <param name="time">时间</param>
            <param name="uid">唯一业务id。例如传感器id</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.NewId22(System.DateTime,System.Int32)">
            <summary>获取指定时间的Id，传入唯一业务id（22位）。可用于物联网数据采集，每4194304个传感器一组，每组每毫秒1个Id</summary>
            <remarks>
            基于指定时间，转StartTimestamp所属时区后，生成Id。
            
            在物联网数据采集中，数据分析需要，更多希望能够按照采集时间去存储。
            为了避免主键重复，可以使用传感器id作为workerId。
            再配合upsert写入数据，如果同一个毫秒内传感器有多行数据，则只会插入一行。
            
            如果为指定业务id在特定毫秒时间生成多个Id（超过1个），则可能重复。
            </remarks>
            <param name="time">时间</param>
            <param name="uid">唯一业务id。例如传感器id</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.GetId(System.DateTime)">
            <summary>时间转为Id，不带节点和序列号。可用于构建时间片段查询</summary>
            <remarks>
            基于指定时间，转StartTimestamp所属时区后，生成不带WorkerId和序列号的Id。
            一般用于构建时间片段查询，例如查询某个时间段内的数据，把时间片段转为雪花Id片段。
            </remarks>
            <param name="time">时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.TryParse(System.Int64,System.DateTime@,System.Int32@,System.Int32@)">
            <summary>解析雪花Id，得到时间、WorkerId和序列号</summary>
            <remarks>
            其中的时间是StartTimestamp所属时区的时间。
            </remarks>
            <param name="id"></param>
            <param name="time">时间</param>
            <param name="workerId">节点</param>
            <param name="sequence">序列号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.ConvertKind(System.DateTime)">
            <summary>把输入时间转为开始时间戳的类型，便于相减</summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.JoinCluster(NewLife.Caching.ICache,System.String)">
            <summary>加入集群。由集群统一分配WorkerId，确保唯一，从而保证生成的雪花Id绝对唯一</summary>
            <param name="cache"></param>
            <param name="key"></param>
        </member>
        <member name="T:NewLife.Data.TimePoint">
            <summary>
            时序点，用于时序数据计算
            </summary>
        </member>
        <member name="F:NewLife.Data.TimePoint.Time">
            <summary>
            时间
            </summary>
        </member>
        <member name="F:NewLife.Data.TimePoint.Value">
            <summary>
            数值
            </summary>
        </member>
        <member name="M:NewLife.Data.TimePoint.ToString">
            <summary>
            已重载
            </summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.EventArgs`1">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`1.Arg">
            <summary>参数</summary>
        </member>
        <member name="M:NewLife.EventArgs`1.#ctor(`0)">
            <summary>使用参数初始化</summary>
            <param name="arg"></param>
        </member>
        <member name="M:NewLife.EventArgs`1.Pop(`0@)">
            <summary>弹出</summary>
            <param name="arg"></param>
        </member>
        <member name="T:NewLife.EventArgs`2">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="M:NewLife.EventArgs`2.#ctor(`0,`1)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:NewLife.EventArgs`2.Pop(`0@,`1@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="T:NewLife.EventArgs`3">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="M:NewLife.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:NewLife.EventArgs`3.Pop(`0@,`1@,`2@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="T:NewLife.EventArgs`4">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg4">
            <summary>参数4</summary>
        </member>
        <member name="M:NewLife.EventArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="M:NewLife.EventArgs`4.Pop(`0@,`1@,`2@,`3@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="T:NewLife.WeakAction`1">
            <summary>弱引用Action</summary>
            <remarks>
            常见的事件和委托，都包括两部分：对象和方法，当然如果委托到静态方法上，对象是为空的。
            如果把事件委托到某个对象的方法上，同时就间接的引用了这个对象，导致其一直无法被回收，从而造成内存泄漏。
            弱引用Action，原理就是把委托拆分，然后弱引用对象部分，需要调用委托的时候，再把对象“拉”回来，如果被回收了，就没有必要再调用它的方法了。
            
            文档 https://newlifex.com/core/weak_action
            </remarks>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakAction`1.Target">
            <summary>目标对象。弱引用，使得调用方对象可以被GC回收</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Method">
            <summary>委托方法</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Handler">
            <summary>经过包装的新的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.UnHandler">
            <summary>取消注册的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Once">
            <summary>是否只使用一次，如果只使用一次，执行委托后马上取消注册</summary>
        </member>
        <member name="P:NewLife.WeakAction`1.IsAlive">
            <summary>是否可用</summary>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo)">
            <summary>实例化</summary>
            <param name="target">目标对象</param>
            <param name="method">目标方法</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo,System.Action{System.Action{`0}},System.Boolean)">
            <summary>实例化</summary>
            <param name="target">目标对象</param>
            <param name="method">目标方法</param>
            <param name="unHandler">取消注册回调</param>
            <param name="once">是否一次性事件</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate)">
            <summary>实例化</summary>
            <param name="handler">事件处理器</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate,System.Action{System.Action{`0}},System.Boolean)">
            <summary>使用事件处理器、取消注册回调、是否一次性事件来初始化</summary>
            <param name="handler">事件处理器</param>
            <param name="unHandler">取消注册回调</param>
            <param name="once">是否一次性事件</param>
        </member>
        <member name="M:NewLife.WeakAction`1.Invoke(`0)">
            <summary>调用委托</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.op_Implicit(NewLife.WeakAction{`0})~System.Action{`0}">
            <summary>把弱引用事件处理器转换为普通事件处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakAction`1.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.XException">
            <summary>X组件异常</summary>
        </member>
        <member name="M:NewLife.XException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="innerException"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="T:NewLife.ExceptionEventArgs">
            <summary>异常事件参数</summary>
        </member>
        <member name="P:NewLife.ExceptionEventArgs.Action">
            <summary>发生异常时进行的动作</summary>
        </member>
        <member name="P:NewLife.ExceptionEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="M:NewLife.ExceptionEventArgs.#ctor(System.String,System.Exception)">
            <summary>实例化</summary>
            <param name="action"></param>
            <param name="ex"></param>
        </member>
        <member name="T:NewLife.ExceptionHelper">
            <summary>异常助手</summary>
        </member>
        <member name="M:NewLife.ExceptionHelper.IsDisposed(System.Exception)">
            <summary>是否对象已被释放异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.BitHelper">
            <summary>数据位助手</summary>
        </member>
        <member name="M:NewLife.BitHelper.SetBit(System.UInt16,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.SetBits(System.UInt16,System.Int32,System.Int32,System.UInt16)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="length"></param>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.SetBit(System.Byte,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.GetBit(System.UInt16,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.GetBits(System.UInt16,System.Int32,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.GetBit(System.Byte,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.EnumHelper">
            <summary>枚举类型助手类</summary>
        </member>
        <member name="M:NewLife.EnumHelper.Has(System.Enum,System.Enum)">
            <summary>枚举变量是否包含指定标识</summary>
            <param name="value">枚举变量</param>
            <param name="flag">要判断的标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.Set``1(System.Enum,``0,System.Boolean)">
            <summary>设置标识位</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="flag"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.GetDescription(System.Enum)">
            <summary>获取枚举字段的注释</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.GetDescriptions``1">
            <summary>获取枚举类型的所有字段注释</summary>
            <typeparam name="TEnum"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.GetDescriptions(System.Type)">
            <summary>获取枚举类型的所有字段注释</summary>
            <param name="enumType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.ProcessHelper">
            <summary>进程助手类</summary>
            <remarks>
            文档 https://newlifex.com/core/string_helper
            </remarks>
        </member>
        <member name="M:NewLife.ProcessHelper.GetProcessName(System.Diagnostics.Process)">
            <summary>获取进程名。dotnet/java进程取文件名，Windows系统中比较耗时</summary>
            <param name="process"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.GetProcessName2(System.Diagnostics.Process)">
            <summary>获取二级进程名。默认一级，如果是dotnet/java则取二级</summary>
            <param name="process"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.GetCommandLine(System.Int32)">
            <summary>获取指定进程的命令行参数</summary>
            <param name="processId"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.GetCommandLineArgs(System.Int32)">
            <summary>获取指定进程的命令行参数</summary>
            <param name="processId"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.SafetyKill(System.Diagnostics.Process,System.Int32,System.Int32,System.Int32)">
            <summary>安全退出进程，目标进程还有机会执行退出代码</summary>
            <remarks>
            Linux系统下，使用kill命令发送信号，等待一段时间后再Kill。
            Windows系统下，使用taskkill命令，等待一段时间后再Kill。
            </remarks>
            <param name="process">目标进程</param>
            <param name="msWait">等待退出的时间。默认5000毫秒</param>
            <param name="times">重试次数</param>
            <param name="interval">间隔时间，毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.ForceKill(System.Diagnostics.Process,System.Int32)">
            <summary>强制结束进程树，包含子进程</summary>
            <param name="process">目标进程</param>
            <param name="msWait">等待退出的时间。默认5000毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.GetHasExited(System.Diagnostics.Process)">
            <summary>获取进程是否终止</summary>
        </member>
        <member name="M:NewLife.ProcessHelper.Run(System.String,System.String,System.Int32,System.Action{System.String},System.Action{System.Diagnostics.Process},System.String)">
            <summary>以隐藏窗口执行命令行</summary>
            <param name="cmd">文件名</param>
            <param name="arguments">命令参数</param>
            <param name="msWait">等待毫秒数</param>
            <param name="output">进程输出内容。默认为空时输出到日志</param>
            <param name="onExit">进程退出时执行</param>
            <param name="working">工作目录</param>
            <returns>进程退出代码</returns>
        </member>
        <member name="M:NewLife.ProcessHelper.ShellExecute(System.String,System.String,System.String)">
            <summary>
            在Shell上执行命令。目标进程不是子进程，不会随着当前进程退出而退出
            </summary>
            <param name="fileName">文件名</param>
            <param name="arguments">参数</param>
            <param name="workingDirectory">工作目录。目标进程的当前目录</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.Execute(System.String,System.String,System.Int32,System.Boolean)">
            <summary>执行命令并等待返回</summary>
            <param name="cmd">命令</param>
            <param name="arguments">命令参数</param>
            <param name="msWait">等待退出的时间。默认0毫秒不等待</param>
            <param name="returnError">没有标准输出时，是否返回错误内容。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.ProcessHelper.Execute(System.String,System.String,System.Int32,System.Boolean,System.Text.Encoding)">
            <summary>执行命令并等待返回</summary>
            <param name="cmd">命令</param>
            <param name="arguments">命令参数</param>
            <param name="msWait">等待退出的时间。默认0毫秒不等待</param>
            <param name="returnError">没有标准输出时，是否返回错误内容。默认false</param>
            <param name="outputEncoding">输出字符编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Extension.SpeakProvider.SpeakAsyncCancelAll">
            <summary>
            停止话音播报
            </summary>
        </member>
        <member name="T:NewLife.StringHelper">
            <summary>字符串助手类</summary>
            <remarks>
            文档 https://newlifex.com/core/string_helper
            </remarks>
        </member>
        <member name="M:NewLife.StringHelper.EqualIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串相等比较，判断是否与任意一个待比较字符串相等</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.StartsWithIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串开始比较，判断是否与任意一个待比较字符串开始</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.EndsWithIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串结束比较，判断是否以任意一个待比较字符串结束</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.IsNullOrEmpty(System.String)">
            <summary>指示指定的字符串是 null 还是 String.Empty 字符串</summary>
            <param name="value">字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.IsNullOrWhiteSpace(System.String)">
            <summary>是否空或者空白字符串</summary>
            <param name="value">字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Split(System.String,System.String[])">
            <summary>拆分字符串，过滤空格，无效时返回空数组</summary>
            <param name="value">字符串</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.SplitAsInt(System.String,System.String[])">
            <summary>拆分字符串成为整型数组，默认逗号分号分隔，无效时返回空数组</summary>
            <remarks>过滤空格、过滤无效、不过滤重复</remarks>
            <param name="value">字符串</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.SplitAsDictionary(System.String,System.String,System.String,System.Boolean)">
            <summary>拆分字符串成为不区分大小写的可空名值字典。逗号分组，等号分隔</summary>
            <param name="value">字符串</param>
            <param name="nameValueSeparator">名值分隔符，默认等于号</param>
            <param name="separator">分组分隔符，默认分号</param>
            <param name="trimQuotation">去掉括号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.SplitAsDictionaryT(System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            在.netCore需要区分该部分内容
            </summary>
            <param name="value"></param>
            <param name="nameValueSeparator"></param>
            <param name="separator"></param>
            <param name="trimQuotation"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Join(System.Collections.IEnumerable,System.String)">
            <summary>把一个列表组合成为一个字符串，默认逗号分隔</summary>
            <param name="value"></param>
            <param name="separator">组合分隔符，默认逗号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Join``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.Object})">
            <summary>把一个列表组合成为一个字符串，默认逗号分隔</summary>
            <param name="value"></param>
            <param name="separator">组合分隔符，默认逗号</param>
            <param name="func">把对象转为字符串的委托</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Separate(System.Text.StringBuilder,System.String)">
            <summary>追加分隔符字符串，忽略开头，常用于拼接</summary>
            <param name="sb">字符串构造者</param>
            <param name="separator">分隔符</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.GetBytes(System.String,System.Text.Encoding)">
            <summary>字符串转数组</summary>
            <param name="value">字符串</param>
            <param name="encoding">编码，默认utf-8无BOM</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.F(System.String,System.Object[])">
            <summary>格式化字符串。特别支持无格式化字符串的时间参数</summary>
            <param name="value">格式字符串</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.IsMatch(System.String,System.String,System.StringComparison)">
            <summary>指定输入是否匹配目标表达式，支持*匹配</summary>
            <param name="pattern">匹配表达式</param>
            <param name="input">输入字符串</param>
            <param name="comparisonType">字符串比较方式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Contains(System.String,System.Char)">
            <summary>Returns a value indicating whether a specified character occurs within this string.</summary>
            <param name="value"></param>
            <param name="inputChar">The character to seek.</param>
            <returns>
            <see langword="true" /> if the <paramref name="inputChar" /> parameter occurs within this string; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:NewLife.StringHelper.Split(System.String,System.Char,System.StringSplitOptions)">
            <summary>Splits a string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.</summary>
            <param name="value"></param>
            <param name="separator">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</param>
            <param name="options">
            <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</param>
            <returns>An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</exception>
        </member>
        <member name="M:NewLife.StringHelper.EnsureStart(System.String,System.String)">
            <summary>确保字符串以指定的另一字符串开始，不区分大小写</summary>
            <param name="str">字符串</param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.EnsureEnd(System.String,System.String)">
            <summary>确保字符串以指定的另一字符串结束，不区分大小写</summary>
            <param name="str">字符串</param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.TrimStart(System.String,System.String[])">
            <summary>从当前字符串开头移除另一字符串，不区分大小写，循环多次匹配前缀</summary>
            <param name="str">当前字符串</param>
            <param name="starts">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.TrimEnd(System.String,System.String[])">
            <summary>从当前字符串结尾移除另一字符串，不区分大小写，循环多次匹配后缀</summary>
            <param name="str">当前字符串</param>
            <param name="ends">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.TrimInvisible(System.String)">
            <summary>修剪不可见字符。仅修剪ASCII，不包含Unicode</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Substring(System.String,System.String,System.String,System.Int32,System.Int32[])">
            <summary>从字符串中检索子字符串，在指定头部字符串之后，指定尾部字符串之前</summary>
            <remarks>常用于截取xml某一个元素等操作</remarks>
            <param name="str">目标字符串</param>
            <param name="after">头部字符串，在它之后</param>
            <param name="before">尾部字符串，在它之前</param>
            <param name="startIndex">搜索的开始位置</param>
            <param name="positions">位置数组，两个元素分别记录头尾位置</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Cut(System.String,System.Int32,System.String)">
            <summary>根据最大长度截取字符串，并允许以指定空白填充末尾</summary>
            <param name="str">字符串</param>
            <param name="maxLength">截取后字符串的最大允许长度，包含后面填充</param>
            <param name="pad">需要填充在后面的字符串，比如几个圆点</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.CutStart(System.String,System.String[])">
            <summary>从当前字符串开头移除另一字符串以及之前的部分</summary>
            <param name="str">当前字符串</param>
            <param name="starts">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.CutEnd(System.String,System.String[])">
            <summary>从当前字符串结尾移除另一字符串以及之后的部分</summary>
            <param name="str">当前字符串</param>
            <param name="ends">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LevenshteinSearch(System.String,System.String[])">
            <summary>编辑距离搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key">关键字</param>
            <param name="words">词组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LevenshteinDistance(System.String,System.String)">
            <summary>编辑距离</summary>
            <remarks>
            又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。
            许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="str1"></param>
            <param name="str2"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCSSearch(System.String,System.String[])">
            <summary>最长公共子序列搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key"></param>
            <param name="words"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCSDistance(System.String,System.String[])">
            <summary>
            最长公共子序列问题是寻找两个或多个已知数列最长的子序列。
            一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。
            The longest common subsequence (LCS) problem is to find the longest subsequence common to all sequences in a set of sequences (often just two). Note that subsequence is different from a substring, see substring vs. subsequence. It is a classic computer science problem, the basis of diff (a file comparison program that outputs the differences between two files), and has applications in bioinformatics.
            </summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="word"></param>
            <param name="keys">多个关键字。长度必须大于0，必须按照字符串长度升序排列。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCS``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>根据列表项成员计算距离</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCSSearch``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.Int32)">
            <summary>在列表项中进行模糊搜索</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Match``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>模糊匹配</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Match(System.String,System.String,System.Int32)">
            <summary>模糊匹配</summary>
            <param name="str"></param>
            <param name="key"></param>
            <param name="maxError"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Match``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.Int32,System.Double)">
            <summary>模糊匹配</summary>
            <typeparam name="T"></typeparam>
            <param name="list">列表项</param>
            <param name="keys">关键字</param>
            <param name="keySelector">匹配字符串选择</param>
            <param name="count">获取个数</param>
            <param name="confidence">权重阀值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Speak(System.String)">
            <summary>调用语音引擎说出指定话</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.StringHelper.SpeakAsync(System.String)">
            <summary>异步调用语音引擎说出指定话。可能导致后来的调用打断前面的语音</summary>
            <param name="value"></param>
        </member>
        <member name="P:NewLife.StringHelper.EnableSpeechTip">
            <summary>启用语音提示</summary>
        </member>
        <member name="M:NewLife.StringHelper.SpeechTip(System.String)">
            <summary>语音提示操作</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.StringHelper.SpeakAsyncCancelAll(System.String)">
            <summary>
            停止所有语音播报
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:NewLife.Http.ControllerHandler">
            <summary>控制器处理器</summary>
        </member>
        <member name="P:NewLife.Http.ControllerHandler.ControllerType">
            <summary>控制器类型</summary>
        </member>
        <member name="M:NewLife.Http.ControllerHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.DnsHttpHandler">
            <summary>支持优化Dns解析的HttpClient处理器</summary>
        </member>
        <member name="P:NewLife.Http.DnsHttpHandler.Resolver">
            <summary>DNS解析器</summary>
        </member>
        <member name="M:NewLife.Http.DnsHttpHandler.#ctor(System.Net.Http.HttpMessageHandler)">
            <summary>实例化一个支持APM的HttpClient处理器</summary>
            <param name="innerHandler"></param>
        </member>
        <member name="M:NewLife.Http.DnsHttpHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <summary>发送请求</summary>
            <param name="request"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.FormFile">
            <summary>表单部分</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.ContentDisposition">
            <summary>内容部署</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.Length">
            <summary>长度</summary>
        </member>
        <member name="M:NewLife.Http.FormFile.OpenReadStream">
            <summary>打开数据读取流</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.FormFile.SaveToFile(System.String)">
            <summary>保存到文件</summary>
            <param name="fileName"></param>
        </member>
        <member name="T:NewLife.Http.HttpBase">
            <summary>Http请求响应基类</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Version">
            <summary>协议版本</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.ContentLength">
            <summary>内容长度</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Body">
            <summary>请求或响应的主体部分</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.BodyLength">
            <summary>主体长度</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.IsCompleted">
            <summary>是否已完整。头部未指定长度，或指定长度后内容已满足</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Headers">
            <summary>头部集合</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Item(System.String)">
            <summary>获取/设置 头部</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.FastValidHeader(NewLife.Data.Packet)">
            <summary>快速验证协议头，剔除非HTTP协议。仅排除，验证通过不一定就是HTTP协议</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.Parse(NewLife.Data.Packet)">
            <summary>分析请求头</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpBase.Build">
            <summary>创建请求响应包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpHelper">
            <summary>Http帮助类</summary>
        </member>
        <member name="P:NewLife.Http.HttpHelper.Tracer">
            <summary>性能跟踪器</summary>
        </member>
        <member name="P:NewLife.Http.HttpHelper.Filter">
            <summary>Http过滤器</summary>
        </member>
        <member name="P:NewLife.Http.HttpHelper.DefaultUserAgent">
            <summary>默认用户浏览器UserAgent。用于内部创建的HttpClient请求</summary>
        </member>
        <member name="M:NewLife.Http.HttpHelper.SetUserAgent(System.Net.Http.HttpClient)">
            <summary>设置浏览器UserAgent。默认使用应用名和版本</summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.CreateHandler(System.Boolean,System.Boolean)">
            <summary>为HttpClient创建Socket处理器，默认设置连接生命为5分钟，有效反映DNS网络更改</summary>
            <remarks>
            PooledConnectionLifetime 属性定义池中的最大连接生存期，从建立连接的时间跟踪其年龄，而不考虑其空闲时间或活动时间。
            在主动用于服务请求时，连接不会被拆毁。此生存期非常有用，以便定期重新建立连接，以便更好地反映 DNS 或其他网络更改。
            </remarks>
            <param name="useProxy">是否使用代理</param>
            <param name="useCookie">是否使用Cookie</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeRequest(System.String,System.Uri,System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Data.Packet)">
            <summary>创建请求包</summary>
            <param name="method"></param>
            <param name="uri"></param>
            <param name="headers"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeResponse(System.Net.HttpStatusCode,System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Data.Packet)">
            <summary>创建响应包</summary>
            <param name="code"></param>
            <param name="headers"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ParseHeader(NewLife.Data.Packet)">
            <summary>分析头部</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostJsonAsync(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>异步提交Json</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostJson(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步提交Json</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostXmlAsync(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>异步提交Xml</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostXml(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步提交Xml</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostFormAsync(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>异步提交表单，名值对传输字典参数</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">名值对数据。匿名对象或字典</param>
            <param name="headers">附加头部</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostForm(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步提交表单，名值对传输字典参数</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">名值对数据。匿名对象或字典</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostMultipartFormAsync(System.Net.Http.HttpClient,System.String,System.Object,System.Threading.CancellationToken)">
            <summary>异步提交多段表单数据，含文件流</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">名值对数据。匿名对象或字典，支持文件流</param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="M:NewLife.Http.HttpHelper.GetString(System.Net.Http.HttpClient,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步获取字符串</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.DownloadFileAsync(System.Net.Http.HttpClient,System.String,System.String)">
            <summary>下载文件</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="fileName">目标文件名</param>
        </member>
        <member name="M:NewLife.Http.HttpHelper.DownloadFileAsync(System.Net.Http.HttpClient,System.String,System.String,System.Threading.CancellationToken)">
            <summary>下载文件</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="fileName">目标文件名</param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="M:NewLife.Http.HttpHelper.UploadFileAsync(System.Net.Http.HttpClient,System.String,System.String,System.Object,System.Threading.CancellationToken)">
            <summary>上传文件以及表单数据</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="fileName">目标文件名</param>
            <param name="data">其它表单数据</param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(NewLife.Http.WebSocket,NewLife.Caching.IProducerConsumer{System.String},System.Func{System.String,System.Byte[]},System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket">WebSocket实例</param>
            <param name="queue">队列</param>
            <param name="onProcess">数据处理委托</param>
            <param name="source">取消通知源</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(NewLife.Http.WebSocket,NewLife.Caching.ICache,System.String,System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket">WebSocket实例</param>
            <param name="host">缓存主机</param>
            <param name="topic">主题</param>
            <param name="source">取消通知源</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(System.Net.WebSockets.WebSocket,NewLife.Caching.IProducerConsumer{System.String},System.Func{System.String,System.Byte[]},System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket">WebSocket实例</param>
            <param name="queue">队列</param>
            <param name="onProcess">数据处理委托</param>
            <param name="source">取消通知源</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(System.Net.WebSockets.WebSocket,NewLife.Caching.ICache,System.String,System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket">WebSocket实例</param>
            <param name="host">缓存主机</param>
            <param name="topic">主题</param>
            <param name="source">取消通知源</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.WaitForClose(System.Net.WebSockets.WebSocket,System.Action{System.String},System.Threading.CancellationTokenSource)">
            <summary>阻塞等待WebSocket关闭</summary>
            <param name="socket">WebSocket实例</param>
            <param name="onReceive">数据处理委托</param>
            <param name="source">取消通知源</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpRequest">
            <summary>Http请求</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Method">
            <summary>Http方法</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.RequestUri">
            <summary>资源路径</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Host">
            <summary>目标主机</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Files">
            <summary>文件集合</summary>
        </member>
        <member name="M:NewLife.Http.HttpRequest.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpRequest.FastParse(NewLife.Data.Packet)">
            <summary>快速分析请求头，只分析第一行</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpRequest.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpRequest.ParseFormData">
            <summary>分析表单数据</summary>
        </member>
        <member name="M:NewLife.Http.HttpRequest.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpResponse">
            <summary>Http响应</summary>
        </member>
        <member name="P:NewLife.Http.HttpResponse.StatusCode">
            <summary>状态码</summary>
        </member>
        <member name="P:NewLife.Http.HttpResponse.StatusDescription">
            <summary>状态描述</summary>
        </member>
        <member name="M:NewLife.Http.HttpResponse.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpResponse.Build">
            <summary>创建请求响应包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpResponse.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpResponse.Valid">
            <summary>验证，如果失败则抛出异常</summary>
        </member>
        <member name="M:NewLife.Http.HttpResponse.SetResult(System.Object,System.String)">
            <summary>设置结果，影响Body和ContentType</summary>
            <param name="result"></param>
            <param name="contentType"></param>
        </member>
        <member name="M:NewLife.Http.HttpResponse.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpServer">
            <summary>Http服务器</summary>
        </member>
        <member name="P:NewLife.Http.HttpServer.ServerName">
            <summary>Http响应头Server名称</summary>
        </member>
        <member name="P:NewLife.Http.HttpServer.Routes">
            <summary>路由映射</summary>
        </member>
        <member name="M:NewLife.Http.HttpServer.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Http.HttpServer.CreateHandler(NewLife.Net.INetSession)">
            <summary>为会话创建网络数据处理器。可作为业务处理实现，也可以作为前置协议解析</summary>
            <param name="session"></param> 
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map(System.String,NewLife.Http.IHttpHandler)">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map(System.String,NewLife.Http.HttpProcessDelegate)">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``1(System.String,System.Func{``0})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``2(System.String,System.Func{``0,``1})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``3(System.String,System.Func{``0,``1,``2})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``4(System.String,System.Func{``0,``1,``2,``3})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``5(System.String,System.Func{``0,``1,``2,``3,``4})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MapController``1(System.String)">
            <summary>映射控制器</summary>
            <typeparam name="TController"></typeparam>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MapController(System.Type,System.String)">
            <summary>映射控制器</summary>
            <param name="controllerType"></param>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MapStaticFiles(System.String,System.String)">
            <summary>映射静态文件</summary>
            <param name="path">映射路径，如 /js</param>
            <param name="contentPath">内容目录，如 /wwwroot/js</param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MatchHandler(System.String,NewLife.Http.HttpRequest)">
            <summary>匹配处理器</summary>
            <param name="path"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpSession">
            <summary>Http会话</summary>
        </member>
        <member name="P:NewLife.Http.HttpSession.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Http.HttpSession.Host">
            <summary>Http服务主机。不一定是HttpServer</summary>
        </member>
        <member name="P:NewLife.Http.HttpSession.MaxRequestLength">
            <summary>最大请求长度。单位字节，默认1G</summary>
        </member>
        <member name="P:NewLife.Http.HttpSession.ExcludeHeaders">
            <summary>忽略的头部</summary>
        </member>
        <member name="P:NewLife.Http.HttpSession.TagTypes">
            <summary>支持作为标签数据的内容类型</summary>
        </member>
        <member name="M:NewLife.Http.HttpSession.Init(NewLife.Net.INetSession)">
            <summary>建立连接时初始化会话</summary>
            <param name="session">会话</param>
        </member>
        <member name="M:NewLife.Http.HttpSession.Process(NewLife.Data.IData)">
            <summary>处理客户端发来的数据</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Http.HttpSession.OnNewRequest(NewLife.Http.HttpRequest,NewLife.Data.IData)">
            <summary>收到新的Http请求，只有头部</summary>
            <param name="request"></param>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Http.HttpSession.ProcessRequest(NewLife.Http.HttpRequest,NewLife.Data.IData)">
            <summary>处理Http请求</summary>
            <param name="request"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpSession.PrepareRequest(NewLife.Http.IHttpContext)">
            <summary>准备请求参数</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.HttpTraceHandler">
            <summary>支持APM跟踪的HttpClient处理器</summary>
        </member>
        <member name="P:NewLife.Http.HttpTraceHandler.Tracer">
            <summary>APM跟踪器</summary>
        </member>
        <member name="P:NewLife.Http.HttpTraceHandler.ExceptionFilter">
            <summary>异常过滤器。仅记录满足条件的异常，默认空记录所有异常</summary>
        </member>
        <member name="M:NewLife.Http.HttpTraceHandler.#ctor(System.Net.Http.HttpMessageHandler)">
            <summary>实例化一个支持APM的HttpClient处理器</summary>
            <param name="innerHandler"></param>
        </member>
        <member name="M:NewLife.Http.HttpTraceHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <summary>发送请求</summary>
            <param name="request"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.IHttpContext">
            <summary>Http上下文</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Response">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Connection">
            <summary>连接会话</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Socket">
            <summary>Socket连接</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.WebSocket">
            <summary>WebSocket连接</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Path">
            <summary>执行路径</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.ServiceProvider">
            <summary>服务提供者</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="T:NewLife.Http.DefaultHttpContext">
            <summary>默认Http上下文</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Response">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Connection">
            <summary>连接会话</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Socket">
            <summary>Socket连接</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.WebSocket">
            <summary>WebSocket连接</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Path">
            <summary>执行路径</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.ServiceProvider">
            <summary>服务提供者</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="M:NewLife.Http.DefaultHttpContext.#ctor(NewLife.Net.INetSession,NewLife.Http.HttpRequest,System.String,NewLife.Http.IHttpHandler)">
            <summary>实例化</summary>
            <param name="session"></param>
            <param name="request"></param>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.DefaultHttpContext.#ctor(NewLife.Net.ISocketRemote,NewLife.Http.HttpRequest,System.String,NewLife.Http.IHttpHandler)">
            <summary>实例化</summary>
            <param name="socket"></param>
            <param name="request"></param>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Current">
            <summary>当前上下文</summary>
        </member>
        <member name="T:NewLife.Http.IHttpFilter">
            <summary>Http过滤器，拦截请求前后</summary>
        </member>
        <member name="M:NewLife.Http.IHttpFilter.OnRequest(System.Net.Http.HttpClient,System.Net.Http.HttpRequestMessage,System.Object,System.Threading.CancellationToken)">
            <summary>请求前</summary>
            <param name="client">客户端</param>
            <param name="request">请求消息</param>
            <param name="state">状态数据</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.IHttpFilter.OnResponse(System.Net.Http.HttpClient,System.Net.Http.HttpResponseMessage,System.Object,System.Threading.CancellationToken)">
            <summary>获取响应后</summary>
            <param name="client">客户端</param>
            <param name="response">响应消息</param>
            <param name="state">状态数据</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.IHttpFilter.OnError(System.Net.Http.HttpClient,System.Exception,System.Object,System.Threading.CancellationToken)">
            <summary>发生错误时</summary>
            <param name="client">客户端</param>
            <param name="exception">异常</param>
            <param name="state">状态数据</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.IHttpHandler">
            <summary>Http处理器</summary>
        </member>
        <member name="M:NewLife.Http.IHttpHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.HttpProcessDelegate">
            <summary>Http请求处理委托</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.DelegateHandler">
            <summary>委托Http处理器</summary>
        </member>
        <member name="P:NewLife.Http.DelegateHandler.Callback">
            <summary>委托</summary>
        </member>
        <member name="M:NewLife.Http.DelegateHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Http.DelegateHandler.OnInvoke(System.Delegate,NewLife.Http.IHttpContext)">
            <summary>复杂调用</summary>
            <param name="handler"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.IHttpHost">
            <summary>Http主机服务</summary>
        </member>
        <member name="M:NewLife.Http.IHttpHost.MatchHandler(System.String,NewLife.Http.HttpRequest)">
            <summary>匹配处理器</summary>
            <param name="path"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.StaticFilesHandler">
            <summary>静态文件处理器</summary>
        </member>
        <member name="P:NewLife.Http.StaticFilesHandler.Path">
            <summary>映射路径</summary>
        </member>
        <member name="P:NewLife.Http.StaticFilesHandler.ContentPath">
            <summary>内容目录</summary>
        </member>
        <member name="M:NewLife.Http.StaticFilesHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.TinyHttpClient">
            <summary>迷你Http客户端。支持https和302跳转</summary>
            <remarks>
            基于Tcp连接设计，用于高吞吐的HTTP通信场景，功能较少，但一切均在掌控之中。
            单个实例使用单个连接，建议外部使用ObjectPool建立连接池。
            </remarks>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.BaseAddress">
            <summary>基础地址</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Timeout">
            <summary>超时时间。默认15s</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.BufferSize">
            <summary>缓冲区大小。接收缓冲区默认64*1024</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.JsonHost">
            <summary>Json序列化</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Tracer">
            <summary>性能追踪</summary>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="server"></param>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetStreamAsync(System.Uri)">
            <summary>获取网络数据流</summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.SendDataAsync(System.Uri,NewLife.Data.Packet)">
            <summary>异步请求</summary>
            <param name="uri"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.SendAsync(NewLife.Http.HttpRequest)">
            <summary>异步发出请求，并接收响应</summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.ReadChunkAsync(NewLife.Data.Packet)">
            <summary>读取分片，返回链式Packet</summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetStringAsync(System.String)">
            <summary>异步获取。连接池操作</summary>
            <param name="url">地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.InvokeAsync``1(System.String,System.String,System.Object)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult">返回类型</typeparam>
            <param name="method">Get/Post</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Http.TokenHttpFilter">
            <summary>Http令牌过滤器，请求前加上令牌，请求后拦截401/403</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.UserName">
            <summary>用户</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Password">
            <summary>密钥</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.ClientId">
            <summary>客户端唯一标识。一般是IP@进程</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.SecurityKey">
            <summary>安全密钥。keyName$keyValue</summary>
            <remarks>
            公钥，用于RSA加密用户密码，在通信链路上保护用户密码安全，可以写死在代码里面。
            密钥前面可以增加keyName，形成keyName$keyValue，用于向服务端指示所使用的密钥标识，方便未来更换密钥。
            </remarks>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Action">
            <summary>申请令牌动作名，默认 OAuth/Token</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Token">
            <summary>令牌信息</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Expire">
            <summary>令牌有效期</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.ErrorCodes">
            <summary>清空令牌的错误码。默认401和403</summary>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.#ctor">
            <summary>实例化令牌过滤器</summary>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.OnRequest(System.Net.Http.HttpClient,System.Net.Http.HttpRequestMessage,System.Object,System.Threading.CancellationToken)">
            <summary>请求前</summary>
            <param name="client">客户端</param>
            <param name="request">请求消息</param>
            <param name="state">状态数据</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.SendAuth(System.Net.Http.HttpClient,System.Threading.CancellationToken)">
            <summary>发起密码认证请求</summary>
            <param name="client"></param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.SendRefresh(System.Net.Http.HttpClient,System.Threading.CancellationToken)">
            <summary>发起刷新令牌请求</summary>
            <param name="client"></param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.EncodePassword(System.String,System.String)">
            <summary>编码密码，在传输中保护安全，一般使用RSA加密</summary>
            <param name="username"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.OnResponse(System.Net.Http.HttpClient,System.Net.Http.HttpResponseMessage,System.Object,System.Threading.CancellationToken)">
            <summary>获取响应后</summary>
            <param name="client">客户端</param>
            <param name="response">响应消息</param>
            <param name="state">状态数据</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.OnError(System.Net.Http.HttpClient,System.Exception,System.Object,System.Threading.CancellationToken)">
            <summary>发生错误时</summary>
            <param name="client">客户端</param>
            <param name="exception">异常</param>
            <param name="state">状态数据</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.WebSocketDelegate">
            <summary>WebSocket消息处理</summary>
            <param name="socket"></param>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Http.WebSocket">
            <summary>WebSocket会话管理</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.Connected">
            <summary>是否还在连接</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.Handler">
            <summary>消息处理器</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.Context">
            <summary>Http上下文</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.ActiveTime">
            <summary>活跃时间</summary>
        </member>
        <member name="M:NewLife.Http.WebSocket.Handshake(NewLife.Http.IHttpContext)">
            <summary>WebSocket 握手</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.WebSocket.Process(NewLife.Data.Packet)">
            <summary>处理WebSocket数据包，不支持超大数据帧（默认8k）</summary>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.Send(NewLife.Data.Packet,NewLife.Http.WebSocketMessageType)">
            <summary>发送消息</summary>
            <param name="data"></param>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.Send(System.String)">
            <summary>发送文本消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.SendAll(NewLife.Data.Packet,NewLife.Http.WebSocketMessageType,System.Func{NewLife.Net.INetSession,System.Boolean})">
            <summary>向所有连接发送消息</summary>
            <param name="data"></param>
            <param name="type"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.SendAll(System.String,System.Func{NewLife.Net.INetSession,System.Boolean})">
            <summary>想所有连接发送文本消息</summary>
            <param name="message"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.Close(System.Int32,System.String)">
            <summary>发送关闭连接</summary>
            <param name="closeStatus"></param>
            <param name="statusDescription"></param>
        </member>
        <member name="T:NewLife.Http.WebSocketHandler">
            <summary>WebSocket处理器</summary>
        </member>
        <member name="M:NewLife.Http.WebSocketHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Http.WebSocketHandler.ProcessMessage(NewLife.Http.WebSocket,NewLife.Http.WebSocketMessage)">
            <summary>处理消息</summary>
            <param name="socket"></param>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Http.WebSocketMessageType">
            <summary>WebSocket消息类型</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Data">
            <summary>附加数据</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Text">
            <summary>文本数据</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Binary">
            <summary>二进制数据</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Close">
            <summary>连接关闭</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Ping">
            <summary>心跳</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Pong">
            <summary>心跳响应</summary>
        </member>
        <member name="T:NewLife.Http.WebSocketMessage">
            <summary>WebSocket消息</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.Fin">
            <summary>消息是否结束</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.Type">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.MaskKey">
            <summary>加密数据的掩码</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.CloseStatus">
            <summary>关闭状态。仅用于Close消息</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.StatusDescription">
            <summary>关闭状态描述。仅用于Close消息</summary>
        </member>
        <member name="M:NewLife.Http.WebSocketMessage.Read(NewLife.Data.Packet)">
            <summary>读取消息</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.WebSocketMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.CsvDb`1">
            <summary>Csv文件轻量级数据库</summary>
            <remarks>
            文档 https://newlifex.com/core/csv_db
            适用于大量数据需要快速存储、快速查找，很少修改和删除的场景。
            在桌面客户端中，关系型数据库SQLite很容易因非法关机而损坏，本数据库能跳过损坏行，自动恢复。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.IO.CsvDb`1.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.IO.CsvDb`1.Encoding">
            <summary>文件编码，默认utf8</summary>
        </member>
        <member name="P:NewLife.IO.CsvDb`1.Comparer">
            <summary>实体比较器</summary>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.#ctor">
            <summary>实例化Csv文件数据库</summary>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>实例化Csv文件数据库</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Write(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>强行写入数据</summary>
            <param name="models">要写入的数据</param>
            <param name="append">是否附加在尾部</param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Add(`0)">
            <summary>尾部插入数据，性能极好</summary>
            <param name="model"></param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>尾部插入数据，性能极好</summary>
            <param name="models"></param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Remove(`0)">
            <summary>删除数据，性能很差，全部读取剔除后保存</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>删除数据，性能很差，全部读取剔除后保存</summary>
            <param name="models"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Remove(System.Func{`0,System.Boolean})">
            <summary>删除满足条件的数据，性能很差，全部读取剔除后保存</summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Clear">
            <summary>清空数据。只写头部</summary>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Update(`0)">
            <summary>更新指定数据行，性能很差，全部读取替换后保存</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Set(`0)">
            <summary>设置（添加或更新）指定数据行，性能很差，全部读取替换后保存</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Find(`0)">
            <summary>查找指定数据行</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Find(System.Func{`0,System.Boolean})">
            <summary>获取满足条件的第一行数据</summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.FindAll">
            <summary>获取所有数据行</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Query(System.Func{`0,System.Boolean},System.Int32)">
            <summary>获取满足条件的数据行，性能好，顺序查找</summary>
            <param name="predicate"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.FindCount">
            <summary>获取数据行数，性能极好，文件行数（除头部）</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.CsvFile">
            <summary>Csv文件</summary>
            <remarks>
            文档 https://newlifex.com/core/csv_file
            支持整体读写以及增量式读写，目标是读写超大Csv文件
            </remarks>
        </member>
        <member name="P:NewLife.IO.CsvFile.Encoding">
            <summary>文件编码</summary>
        </member>
        <member name="P:NewLife.IO.CsvFile.Separator">
            <summary>分隔符。默认逗号</summary>
        </member>
        <member name="M:NewLife.IO.CsvFile.#ctor(System.IO.Stream)">
            <summary>数据流实例化</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>数据流实例化</summary>
            <param name="stream"></param>
            <param name="leaveOpen">保留打开</param>
        </member>
        <member name="M:NewLife.IO.CsvFile.#ctor(System.String,System.Boolean)">
            <summary>Csv文件实例化</summary>
            <param name="file"></param>
            <param name="write"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.IO.CsvFile.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.ReadLine">
            <summary>读取一行</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvFile.ReadAll">
            <summary>读取所有行</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvFile.WriteAll(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Object}})">
            <summary>写入全部</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.WriteLine(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>写入一行</summary>
            <param name="line"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.WriteLine(System.Object[])">
            <summary>
            写入一行
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.WriteLineAsync(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>异步写入一行</summary>
            <param name="line"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.BuildLine(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>构建一行</summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.EasyClient">
            <summary>文件存储客户端</summary>
            <remarks>
            使用方式，可以引用sdk，也可以直接把 EasyClient 类抠出来使用。
            </remarks>
        </member>
        <member name="P:NewLife.IO.EasyClient.Server">
            <summary>服务端地址</summary>
        </member>
        <member name="P:NewLife.IO.EasyClient.AppId">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.IO.EasyClient.Secret">
            <summary>应用密钥</summary>
        </member>
        <member name="P:NewLife.IO.EasyClient.BaseAction">
            <summary>基础控制器路径。默认/io/</summary>
        </member>
        <member name="P:NewLife.IO.EasyClient.CanGetUrl">
            <summary>是否支持获取文件直接访问Url</summary>
        </member>
        <member name="P:NewLife.IO.EasyClient.CanDelete">
            <summary>是否支持删除</summary>
        </member>
        <member name="P:NewLife.IO.EasyClient.CanSearch">
            <summary>是否支持搜索</summary>
        </member>
        <member name="M:NewLife.IO.EasyClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.IO.EasyClient.#ctor(System.IServiceProvider,System.String)">
            <summary>指定服务提供者来实例化文件存储客户端，可对接配置中心或注册中心</summary>
            <param name="serviceProvider">服务提供者</param>
            <param name="name">配置名。默认指向注册中心的EasyIO服务</param>
        </member>
        <member name="M:NewLife.IO.EasyClient.GetClient">
            <summary>获取客户端</summary>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NewLife.IO.EasyClient.Put(System.String,NewLife.Data.Packet)">
            <summary>上传对象</summary>
            <param name="id">对象标识。支持斜杠目录结构</param>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NewLife.IO.EasyClient.Get(System.String)">
            <summary>根据Id获取对象</summary>
            <param name="id">对象标识。支持斜杠目录结构</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NewLife.IO.EasyClient.GetUrl(System.String)">
            <summary>获取对象下载Url</summary>
            <param name="id">对象标识。支持斜杠目录结构</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EasyClient.Delete(System.String)">
            <summary>删除文件对象</summary>
            <param name="id">对象文件名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EasyClient.Search(System.String,System.Int32,System.Int32)">
            <summary>搜索文件</summary>
            <param name="pattern">匹配模式。如/202304/*.jpg</param>
            <param name="start">开始序号。0开始</param>
            <param name="count">最大个数</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.EasyClient.Tracer">
            <summary>性能追踪</summary>
        </member>
        <member name="P:NewLife.IO.EasyClient.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.IO.EasyClient.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.IO.ExcelReader">
            <summary>轻量级Excel读取器，仅用于导入数据</summary>
            <remarks>
            文档 https://newlifex.com/core/excel_reader
            仅支持xlsx格式，本质上是压缩包，内部xml。
            可根据xml格式扩展读取自己想要的内容。
            </remarks>
        </member>
        <member name="P:NewLife.IO.ExcelReader.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.IO.ExcelReader.Sheets">
            <summary>工作表</summary>
        </member>
        <member name="M:NewLife.IO.ExcelReader.#ctor(System.String)">
            <summary>实例化读取器</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.IO.ExcelReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>实例化读取器</summary>
            <param name="stream"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.IO.ExcelReader.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.IO.ExcelReader.ReadRows(System.String)">
            <summary>逐行读取数据，第一行很可能是表头</summary>
            <param name="sheet">工作表名。一般是sheet1/sheet2/sheet3，默认空，使用第一个数据表</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.IObjectInfo">
            <summary>对象信息接口。代表文件存储对象，或者磁盘文件，也可以是目录</summary>
        </member>
        <member name="P:NewLife.IO.IObjectInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.IO.IObjectInfo.Length">
            <summary>大小</summary>
        </member>
        <member name="P:NewLife.IO.IObjectInfo.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.IO.IObjectInfo.IsDirectory">
            <summary>是否目录</summary>
        </member>
        <member name="P:NewLife.IO.IObjectInfo.Data">
            <summary>数据</summary>
        </member>
        <member name="T:NewLife.IO.ObjectInfo">
            <summary>对象信息。代表文件存储对象，或者磁盘文件，也可以是目录</summary>
        </member>
        <member name="P:NewLife.IO.ObjectInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.IO.ObjectInfo.Length">
            <summary>大小</summary>
        </member>
        <member name="P:NewLife.IO.ObjectInfo.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.IO.ObjectInfo.IsDirectory">
            <summary>是否目录</summary>
        </member>
        <member name="P:NewLife.IO.ObjectInfo.Data">
            <summary>数据</summary>
        </member>
        <member name="T:NewLife.IO.IObjectStorage">
            <summary>对象存储接口</summary>
            <remarks>
            可对接阿里云，文档 https://newlifex.com/core/oss
            可对接EasyIO
            
            有的OSS实现，在地址栏增加目录结构，而有的在对象名增加目录。
            </remarks>
        </member>
        <member name="P:NewLife.IO.IObjectStorage.Server">
            <summary>服务器。某些OSS在域名前或地址后增加BucketName</summary>
        </member>
        <member name="P:NewLife.IO.IObjectStorage.AppId">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.IO.IObjectStorage.Secret">
            <summary>应用密钥</summary>
        </member>
        <member name="P:NewLife.IO.IObjectStorage.CanGetUrl">
            <summary>是否支持获取文件直接访问Url</summary>
        </member>
        <member name="P:NewLife.IO.IObjectStorage.CanDelete">
            <summary>是否支持删除</summary>
        </member>
        <member name="P:NewLife.IO.IObjectStorage.CanSearch">
            <summary>是否支持搜索</summary>
        </member>
        <member name="M:NewLife.IO.IObjectStorage.Get(System.String)">
            <summary>获取文件对象</summary>
            <param name="id">对象文件名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IObjectStorage.GetUrl(System.String)">
            <summary>获取文件直接访问Url</summary>
            <param name="id">对象文件名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IObjectStorage.Put(System.String,NewLife.Data.Packet)">
            <summary>上传文件对象</summary>
            <param name="id">对象文件名。可以为空，此时自动生成文件名</param>
            <param name="data">数据内容</param>
            <returns>可能是自动生成的新文件名</returns>
        </member>
        <member name="M:NewLife.IO.IObjectStorage.Delete(System.String)">
            <summary>删除文件对象</summary>
            <param name="id">对象文件名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IObjectStorage.Search(System.String,System.Int32,System.Int32)">
            <summary>搜索文件</summary>
            <param name="pattern">匹配模式。如/202304/*.jpg</param>
            <param name="start">开始序号。0开始</param>
            <param name="count">最大个数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IOHelper">
            <summary>IO工具类</summary>
            <remarks>
            文档 https://newlifex.com/core/io_helper
            </remarks>
        </member>
        <member name="P:NewLife.IOHelper.MaxSafeArraySize">
            <summary>最大安全数组大小。超过该大小时，读取数据操作将强制失败，默认1024*1024</summary>
            <remarks>
            这是一个保护性设置，避免解码错误数据时读取了超大数组导致应用崩溃。
            需要解码较大二进制数据时，可以适当放宽该阈值。
            </remarks>
        </member>
        <member name="M:NewLife.IOHelper.Compress(System.IO.Stream,System.IO.Stream)">
            <summary>压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.Decompress(System.IO.Stream,System.IO.Stream)">
            <summary>解压缩数据流</summary>
            <returns>Deflate算法，如果是ZLIB格式，则前面多两个字节，解压缩之前去掉，RocketMQ中有用到</returns>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.Compress(System.Byte[])">
            <summary>压缩字节数组</summary>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Decompress(System.Byte[])">
            <summary>解压缩字节数组</summary>
            <returns>Deflate算法，如果是ZLIB格式，则前面多两个字节，解压缩之前去掉，RocketMQ中有用到</returns>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.CompressGZip(System.IO.Stream,System.IO.Stream)">
            <summary>压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.DecompressGZip(System.IO.Stream,System.IO.Stream)">
            <summary>解压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.CompressGZip(System.Byte[])">
            <summary>压缩字节数组</summary>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.DecompressGZip(System.Byte[])">
            <summary>解压缩字节数组</summary>
            <returns>Deflate算法，如果是ZLIB格式，则前面多两个字节，解压缩之前去掉，RocketMQ中有用到</returns>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.IO.Stream,System.Byte[])">
            <summary>把一个字节数组写入到一个数据流</summary>
            <param name="des">目的数据流</param>
            <param name="src">源数据流</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.WriteArray(System.IO.Stream,System.Byte[])">
            <summary>写入字节数组，先写入压缩整数表示的长度</summary>
            <param name="des"></param>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadArray(System.IO.Stream)">
            <summary>读取字节数组，先读取压缩整数表示的长度</summary>
            <param name="des"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.WriteDateTime(System.IO.Stream,System.DateTime)">
            <summary>写入Unix格式时间，1970年以来秒数，绝对时间，非UTC</summary>
            <param name="stream"></param>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadDateTime(System.IO.Stream)">
            <summary>读取Unix格式时间，1970年以来秒数，绝对时间，非UTC</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>复制数组</summary>
            <param name="src">源数组</param>
            <param name="offset">起始位置。一般从0开始</param>
            <param name="count">复制字节数。用-1表示截取剩余所有数据</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>向字节数组写入一片数据</summary>
            <param name="dst">目标数组</param>
            <param name="dstOffset">目标偏移</param>
            <param name="src">源数组</param>
            <param name="srcOffset">源数组偏移</param>
            <param name="count">数量</param>
            <returns>返回实际写入的字节个数</returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadBytes(System.IO.Stream,System.Int64)">
            <summary>数据流转为字节数组</summary>
            <remarks>
            针对MemoryStream进行优化。内存流的Read实现是一个个字节复制，而ToArray是调用内部内存复制方法
            如果要读完数据，又不支持定位，则采用内存流搬运
            如果指定长度超过数据流长度，就让其报错，因为那是调用者所期望的值
            </remarks>
            <param name="stream">数据流</param>
            <param name="length">长度，-1表示读到结束</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToStr(System.IO.Stream,System.Text.Encoding)">
            <summary>流转换为字符串</summary>
            <param name="stream">目标流</param>
            <param name="encoding">编码格式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToStr(System.Byte[],System.Text.Encoding,System.Int32,System.Int32)">
            <summary>字节数组转换为字符串</summary>
            <param name="buf">字节数组</param>
            <param name="encoding">编码格式</param>
            <param name="offset">字节数组中的偏移</param>
            <param name="count">字节数组中的查找长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUInt16(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUInt32(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号32位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUInt64(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号64位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToSingle(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个单精度浮点数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToDouble(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个双精度浮点数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.UInt16,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.UInt32,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号32位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.UInt64,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号64位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.Single,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个单精度浮点数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.Double,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个双精度浮点数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.UInt16,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Int16,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.UInt32,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Int32,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.UInt64,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Int64,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Single,System.Boolean)">
            <summary>单精度浮点数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Double,System.Boolean)">
            <summary>双精度浮点数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Swap(System.Byte[],System.Boolean,System.Boolean)">
            <summary>字节翻转。支持双字节和四字节多批次翻转，主要用于大小端转换</summary>
            <param name="data"></param>
            <param name="swap16"></param>
            <param name="swap32"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadEncodedInt(System.IO.Stream)">
            <summary>以压缩格式读取32位整数</summary>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadEncodedInt64(System.IO.Stream)">
            <summary>以压缩格式读取32位整数</summary>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.TryReadEncodedInt(System.IO.Stream,System.UInt32@)">
            <summary>尝试读取压缩编码整数</summary>
            <param name="stream"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.WriteEncodedInt(System.IO.Stream,System.Int64)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="stream">数据流</param>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.IOHelper.GetEncodedInt(System.Int64)">
            <summary>获取压缩编码整数</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>把字节数组编码为十六进制字符串</summary>
            <param name="data">字节数组</param>
            <param name="offset">偏移</param>
            <param name="count">数量。超过实际数量时，使用实际数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToHex(System.Byte[],System.String,System.Int32,System.Int32)">
            <summary>把字节数组编码为十六进制字符串，带有分隔符和分组功能</summary>
            <param name="data">字节数组</param>
            <param name="separate">分隔符</param>
            <param name="groupSize">分组大小，为0时对每个字节应用分隔符，否则对每个分组使用</param>
            <param name="maxLength">最大显示多少个字节。默认-1显示全部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToHex(System.Byte)">
            <summary>1个字节转为2个16进制字符</summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToHex(System.String,System.Int32,System.Int32)">
            <summary>解密</summary>
            <param name="data">Hex编码的字符串</param>
            <param name="startIndex">起始位置</param>
            <param name="length">长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToBase64(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>字节数组转为Base64编码</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="lineBreak">是否换行显示</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUrlBase64(System.Byte[],System.Int32,System.Int32)">
            <summary>字节数组转为Url改进型Base64编码</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToBase64(System.String)">
            <summary>Base64字符串转为字节数组</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.IndexOf(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>Boyer Moore 字符串搜索算法，比KMP更快，常用于IDE工具的查找</summary>
            <param name="source"></param>
            <param name="pattern"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ActionLog">
            <summary>依托于动作的日志类</summary>
        </member>
        <member name="P:NewLife.Log.ActionLog.Method">
            <summary>方法</summary>
        </member>
        <member name="M:NewLife.Log.ActionLog.#ctor(System.Action{System.String,System.Object[]})">
            <summary>使用指定方法否则动作日志</summary>
            <param name="action"></param>
        </member>
        <member name="M:NewLife.Log.ActionLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.ActionLog.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.CompositeLog">
            <summary>复合日志提供者，多种方式输出</summary>
        </member>
        <member name="P:NewLife.Log.CompositeLog.Logs">
            <summary>日志提供者集合</summary>
        </member>
        <member name="P:NewLife.Log.CompositeLog.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info，打开NewLife.Debug时默认为最低的Debug</summary>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor(NewLife.Log.ILog)">
            <summary>实例化</summary>
            <param name="log"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor(NewLife.Log.ILog,NewLife.Log.ILog)">
            <summary>实例化</summary>
            <param name="log1"></param>
            <param name="log2"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Add(NewLife.Log.ILog)">
            <summary>添加一个日志提供者</summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Remove(NewLife.Log.ILog)">
            <summary>删除日志提供者</summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Get``1">
            <summary>从复合日志提供者中提取指定类型的日志提供者</summary>
            <typeparam name="TLog"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ConsoleLog">
            <summary>控制台输出日志</summary>
        </member>
        <member name="P:NewLife.Log.ConsoleLog.UseColor">
            <summary>是否使用多种颜色，默认使用</summary>
        </member>
        <member name="M:NewLife.Log.ConsoleLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.ConsoleLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ICounter">
            <summary>性能计数器接口</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Times">
            <summary>次数</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Speed">
            <summary>速度</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Cost">
            <summary>平均耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.ICounter.Increment(System.Int64,System.Int64)">
            <summary>增加</summary>
            <param name="value">增加的数量</param>
            <param name="usCost">耗时，单位us</param>
        </member>
        <member name="T:NewLife.Log.CounterHelper">
            <summary>计数器助手</summary>
        </member>
        <member name="M:NewLife.Log.CounterHelper.StartCount(NewLife.Log.ICounter)">
            <summary>开始计时</summary>
            <param name="counter"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CounterHelper.StopCount(NewLife.Log.ICounter,System.Nullable{System.Int64})">
            <summary>结束计时</summary>
            <param name="counter"></param>
            <param name="startTicks"></param>
        </member>
        <member name="T:NewLife.Log.ILog">
            <summary>日志接口</summary>
            <remarks>
            文档 https://newlifex.com/core/log
            </remarks>
        </member>
        <member name="M:NewLife.Log.ILog.Write(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level">日志级别</param>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Debug(System.String,System.Object[])">
            <summary>调试日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Info(System.String,System.Object[])">
            <summary>信息日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Warn(System.String,System.Object[])">
            <summary>警告日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Error(System.String,System.Object[])">
            <summary>错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Fatal(System.String,System.Object[])">
            <summary>严重错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="P:NewLife.Log.ILog.Enable">
            <summary>是否启用日志</summary>
        </member>
        <member name="P:NewLife.Log.ILog.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info</summary>
        </member>
        <member name="T:NewLife.Log.ILogFeature">
            <summary>日志功能接口</summary>
        </member>
        <member name="P:NewLife.Log.ILogFeature.Log">
            <summary>日志。非空，默认为Logger.Null</summary>
        </member>
        <member name="T:NewLife.Log.LogFeatureExtensions">
            <summary>日志功能扩展</summary>
        </member>
        <member name="M:NewLife.Log.LogFeatureExtensions.WriteLog(NewLife.Log.ILogFeature,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="logFeature">日志功能</param>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数，特殊处理时间日期和异常对象</param>
        </member>
        <member name="T:NewLife.Log.ISpan">
            <summary>性能跟踪片段。轻量级APM</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.Id">
            <summary>唯一标识。随线程上下文、Http、Rpc传递，作为内部片段的父级</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.ParentId">
            <summary>父级片段标识</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.TraceId">
            <summary>跟踪标识。可用于关联多个片段，建立依赖关系，随线程上下文、Http、Rpc传递</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.Value">
            <summary>用户数值。记录数字型标量，如每次数据库操作行数，星尘平台汇总统计</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.Tag">
            <summary>数据标签。记录一些附加数据</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.Error">
            <summary>错误信息</summary>
        </member>
        <member name="M:NewLife.Log.ISpan.SetError(System.Exception,System.Object)">
            <summary>设置错误信息，ApiException除外</summary>
            <param name="ex">异常</param>
            <param name="tag">标签</param>
        </member>
        <member name="M:NewLife.Log.ISpan.SetTag(System.Object)">
            <summary>设置数据标签。内部根据长度截断</summary>
            <param name="tag">标签</param>
        </member>
        <member name="T:NewLife.Log.DefaultSpan">
            <summary>性能跟踪片段。轻量级APM</summary>
            <remarks>
            spanId/traceId采用W3C标准，https://www.w3.org/TR/trace-context/
            </remarks>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Builder">
            <summary>构建器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Id">
            <summary>唯一标识。随线程上下文、Http、Rpc传递，作为内部片段的父级</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.ParentId">
            <summary>父级片段标识</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.TraceId">
            <summary>跟踪标识。可用于关联多个片段，建立依赖关系，随线程上下文、Http、Rpc传递</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Value">
            <summary>用户数值。记录数字型标量，如每次数据库操作行数，星尘平台汇总统计</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Tag">
            <summary>数据标签。记录一些附加数据</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.TraceFlag">
            <summary>跟踪标识。强制采样，确保链路采样完整，上下文传递</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Error">
            <summary>错误信息</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Current">
            <summary>当前线程正在使用的上下文</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.#ctor(NewLife.Log.ISpanBuilder)">
            <summary>实例化</summary>
            <param name="builder"></param>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.Start">
            <summary>设置跟踪标识</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.CreateId">
            <summary>创建分片编号</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.CreateTraceId">
            <summary>创建跟踪编号</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.Finish">
            <summary>完成跟踪</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.SetError(System.Exception,System.Object)">
            <summary>设置错误信息，ApiException除外</summary>
            <param name="ex">异常</param>
            <param name="tag">标签</param>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.SetTag(System.Object)">
            <summary>设置数据标签。内部根据长度截断</summary>
            <param name="tag">标签</param>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.SpanExtension">
            <summary>跟踪片段扩展</summary>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Attach(NewLife.Log.ISpan,System.Net.Http.HttpRequestMessage)">
            <summary>把片段信息附加到http请求头上</summary>
            <param name="span">片段</param>
            <param name="request">http请求</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Attach(NewLife.Log.ISpan,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>把片段信息附加到http请求头上</summary>
            <param name="span">片段</param>
            <param name="headers">http请求头</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Attach(NewLife.Log.ISpan,System.Net.WebRequest)">
            <summary>把片段信息附加到http请求头上</summary>
            <param name="span">片段</param>
            <param name="request">http请求</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Attach(NewLife.Log.ISpan,System.Object)">
            <summary>把片段信息附加到api请求头上</summary>
            <param name="span">片段</param>
            <param name="args">api请求参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach(NewLife.Log.ISpan,System.Collections.Specialized.NameValueCollection)">
            <summary>从http请求头释放片段信息</summary>
            <param name="span">片段</param>
            <param name="headers">http请求头</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach(NewLife.Log.ISpan,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>从api请求释放片段信息</summary>
            <param name="span">片段</param>
            <param name="parameters">参数</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach``1(NewLife.Log.ISpan,System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>从api请求释放片段信息</summary>
            <param name="span">片段</param>
            <param name="parameters">参数</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach(NewLife.Log.ISpan,System.String)">
            <summary>从数据流traceId中释放片段信息</summary>
            <param name="span">片段</param>
            <param name="traceId">W3C标准TraceId，可以是traceparent</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.AppendTag(NewLife.Log.ISpan,System.Object)">
            <summary>附加Tag信息在原Tag信息后面</summary>
            <param name="span">片段</param>
            <param name="tag">Tag信息</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.AppendTag(NewLife.Log.ISpan,System.Object,System.Int64)">
            <summary>附加Tag信息在原Tag信息后面</summary>
            <param name="span">片段</param>
            <param name="tag">Tag信息</param>
            <param name="value">可累加的数值标量</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.AppendTag(NewLife.Log.ISpan,System.Net.Http.HttpResponseMessage)">
            <summary>附加Http响应内容在原Tag信息后面</summary>
            <param name="span"></param>
            <param name="response"></param>
        </member>
        <member name="T:NewLife.Log.ISpanBuilder">
            <summary>跟踪片段构建器</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Tracer">
            <summary>跟踪器</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Name">
            <summary>操作名</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Total">
            <summary>采样总数</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Errors">
            <summary>错误次数</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Cost">
            <summary>总耗时。所有请求耗时累加，单位ms</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.MaxCost">
            <summary>最大耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.MinCost">
            <summary>最小耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Value">
            <summary>用户数值。记录数字型标量，如每次数据库操作行数，星尘平台汇总统计</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Samples">
            <summary>正常采样</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.ErrorSamples">
            <summary>异常采样</summary>
        </member>
        <member name="M:NewLife.Log.ISpanBuilder.Start">
            <summary>开始一个Span</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ISpanBuilder.Finish(NewLife.Log.ISpan)">
            <summary>完成Span</summary>
            <param name="span"></param>
        </member>
        <member name="T:NewLife.Log.DefaultSpanBuilder">
            <summary>跟踪片段构建器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Tracer">
            <summary>跟踪器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Name">
            <summary>操作名</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Total">
            <summary>采样总数</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Errors">
            <summary>错误次数</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Cost">
            <summary>总耗时。所有请求耗时累加，单位ms</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.MaxCost">
            <summary>最大耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.MinCost">
            <summary>最小耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Value">
            <summary>用户数值。记录数字型标量，如每次数据库操作行数，星尘平台汇总统计</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Samples">
            <summary>正常采样</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.ErrorSamples">
            <summary>异常采样</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.#ctor(NewLife.Log.ITracer,System.String)">
            <summary>实例化</summary>
            <param name="tracer"></param>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.Start">
            <summary>开始一个Span，开始计时</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.Finish(NewLife.Log.ISpan)">
            <summary>完成Span，每一个埋点结束都进入这里</summary>
            <param name="span"></param>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ITracer">
            <summary>性能跟踪器。轻量级APM</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.Period">
            <summary>采样周期</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.MaxSamples">
            <summary>最大正常采样数。采样周期内，最多只记录指定数量的正常事件，用于绘制依赖关系</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.MaxErrors">
            <summary>最大异常采样数。采样周期内，最多只记录指定数量的异常事件，默认10</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.Timeout">
            <summary>超时时间。超过该时间时强制采样，毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.MaxTagLength">
            <summary>最大标签长度。超过该长度时将截断，默认1024字符</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.AttachParameter">
            <summary>向http/rpc请求注入TraceId的参数名，为空表示不注入，默认W3C标准的traceparent</summary>
        </member>
        <member name="M:NewLife.Log.ITracer.BuildSpan(System.String)">
            <summary>建立Span构建器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ITracer.NewSpan(System.String)">
            <summary>开始一个Span</summary>
            <param name="name">操作名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ITracer.NewSpan(System.String,System.Object)">
            <summary>开始一个Span，指定数据标签</summary>
            <param name="name">操作名</param>
            <param name="tag">数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ITracer.TakeAll">
            <summary>截断所有Span构建器数据，重置集合</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.DefaultTracer">
            <summary>性能跟踪器。轻量级APM</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Instance">
            <summary>全局实例。可影响X组件各模块的跟踪器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Period">
            <summary>采样周期。默认15s</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.MaxSamples">
            <summary>最大正常采样数。采样周期内，最多只记录指定数量的正常事件，用于绘制依赖关系</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.MaxErrors">
            <summary>最大异常采样数。采样周期内，最多只记录指定数量的异常事件，默认10</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Timeout">
            <summary>超时时间。超过该时间时强制采样，默认15000毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.MaxTagLength">
            <summary>最大标签长度。超过该长度时将截断，默认1024字符</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.AttachParameter">
            <summary>向http/rpc请求注入TraceId的参数名，为空表示不注入，默认是W3C标准的traceparent</summary>
        </member>
        <member name="F:NewLife.Log.DefaultTracer._builders">
            <summary>Span构建器集合</summary>
        </member>
        <member name="F:NewLife.Log.DefaultTracer._timer">
            <summary>采样定时器</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.ProcessSpans(NewLife.Log.ISpanBuilder[])">
            <summary>处理Span集合。默认输出日志，可重定义输出控制台</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.BuildSpan(System.String)">
            <summary>建立Span构建器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.OnBuildSpan(System.String)">
            <summary>实例化Span构建器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.NewSpan(System.String)">
            <summary>开始一个Span</summary>
            <param name="name">操作名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.NewSpan(System.String,System.Object)">
            <summary>开始一个Span，指定数据标签</summary>
            <param name="name">操作名</param>
            <param name="tag">数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.TakeAll">
            <summary>截断所有Span构建器数据，重置集合</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Log.TracerExtension">
            <summary>跟踪扩展</summary>
        </member>
        <member name="M:NewLife.Log.TracerExtension.CreateHttpClient(NewLife.Log.ITracer,System.Net.Http.HttpMessageHandler)">
            <summary>创建受跟踪的HttpClient</summary>
            <param name="tracer">跟踪器</param>
            <param name="handler">http处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TracerExtension.NewSpan(NewLife.Log.ITracer,System.String,System.Object,System.Int64)">
            <summary>开始一个Span，指定数据标签和用户数值</summary>
            <param name="tracer">跟踪器</param>
            <param name="name">操作名</param>
            <param name="tag">数据</param>
            <param name="value">用户数值。星尘平台汇总统计</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TracerExtension.NewSpan(NewLife.Log.ITracer,System.Net.Http.HttpRequestMessage)">
            <summary>为Http请求创建Span</summary>
            <param name="tracer">跟踪器</param>
            <param name="request">Http请求</param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Log.TracerExtension._TagTypes">
            <summary>支持作为标签数据的内容类型</summary>
        </member>
        <member name="M:NewLife.Log.TracerExtension.NewSpan(NewLife.Log.ITracer,System.Net.WebRequest)">
            <summary>为Http请求创建Span</summary>
            <param name="tracer">跟踪器</param>
            <param name="request">Http请求</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TracerExtension.NewError(NewLife.Log.ITracer,System.String,System.Object)">
            <summary>直接创建错误Span</summary>
            <param name="tracer">跟踪器</param>
            <param name="name">操作名</param>
            <param name="error">Exception 异常对象，或错误信息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TracerExtension.NewError(NewLife.Log.ITracer,System.String,System.Object,System.Object)">
            <summary>直接创建错误Span</summary>
            <param name="tracer">跟踪器</param>
            <param name="name">操作名</param>
            <param name="error">Exception 异常对象，或错误信息</param>
            <param name="tag">数据标签</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ITracerFeature">
            <summary>日志功能接口</summary>
        </member>
        <member name="P:NewLife.Log.ITracerFeature.Tracer">
            <summary>性能追踪</summary>
        </member>
        <member name="T:NewLife.Log.LevelLog">
            <summary>等级日志提供者，不同等级分不同日志输出</summary>
        </member>
        <member name="M:NewLife.Log.LevelLog.#ctor(System.String,System.String)">
            <summary>通过指定路径和文件格式来实例化等级日志，每个等级使用自己的日志输出</summary>
            <param name="logPath"></param>
            <param name="fileFormat"></param>
        </member>
        <member name="M:NewLife.Log.LevelLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Log.LogEventListener">
            <summary>日志事件监听器。用于监听内置事件并写入日志</summary>
        </member>
        <member name="M:NewLife.Log.LogEventListener.#ctor(System.String[])">
            <summary>实例化</summary>
            <param name="sources"></param>
        </member>
        <member name="M:NewLife.Log.LogEventListener.OnEventSourceCreated(System.Diagnostics.Tracing.EventSource)">
            <summary>创建事件源。此时决定要不要跟踪</summary>
            <param name="eventSource"></param>
        </member>
        <member name="M:NewLife.Log.LogEventListener.OnEventWritten(System.Diagnostics.Tracing.EventWrittenEventArgs)">
            <summary>写入事件。监听器拦截，并写入日志</summary>
            <param name="eventData"></param>
        </member>
        <member name="T:NewLife.Log.Logger">
            <summary>日志基类。提供日志的基本实现</summary>
        </member>
        <member name="M:NewLife.Log.Logger.Debug(System.String,System.Object[])">
            <summary>调试日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Info(System.String,System.Object[])">
            <summary>信息日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Warn(System.String,System.Object[])">
            <summary>警告日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Error(System.String,System.Object[])">
            <summary>错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Fatal(System.String,System.Object[])">
            <summary>严重错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Write(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.Logger.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.Logger.Format(System.String,System.Object[])">
            <summary>格式化参数，特殊处理异常和时间</summary>
            <param name="format"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.Logger.Enable">
            <summary>是否启用日志。默认true</summary>
        </member>
        <member name="P:NewLife.Log.Logger.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info</summary>
        </member>
        <member name="P:NewLife.Log.Logger.Null">
            <summary>空日志实现</summary>
        </member>
        <member name="M:NewLife.Log.Logger.GetHead">
            <summary>输出日志头，包含所有环境信息</summary>
        </member>
        <member name="T:NewLife.Log.LogLevel">
            <summary>日志等级</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.All">
            <summary>打开所有日志记录</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Debug">
            <summary>最低调试。细粒度信息事件对调试应用程序非常有帮助</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Info">
            <summary>普通消息。在粗粒度级别上突出强调应用程序的运行过程</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Warn">
            <summary>警告</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Error">
            <summary>错误</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Fatal">
            <summary>严重错误</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Off">
            <summary>关闭所有日志记录</summary>
        </member>
        <member name="T:NewLife.Log.NetworkLog">
            <summary>网络日志</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.AppId">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.ClientId">
            <summary>客户端标识</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.#ctor">
            <summary>实例化网络日志。默认广播到514端口</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.#ctor(System.String)">
            <summary>指定日志服务器地址来实例化网络日志</summary>
            <param name="server"></param>
        </member>
        <member name="M:NewLife.Log.NetworkLog.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Log.PerfCounter">
            <summary>性能计数器。次数、TPS、平均耗时</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Enable">
            <summary>是否启用。默认true</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Times">
            <summary>次数</summary>
        </member>
        <member name="F:NewLife.Log.PerfCounter._TotalCost">
            <summary>耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.PerfCounter.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.PerfCounter.Increment(System.Int64,System.Int64)">
            <summary>增加</summary>
            <param name="value">增加的数量</param>
            <param name="usCost">耗时，单位us</param>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Interval">
            <summary>采样间隔，默认1000毫秒</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Duration">
            <summary>持续采样时间，默认60秒</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Speed">
            <summary>当前速度</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.MaxSpeed">
            <summary>最大速度</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Cost">
            <summary>最后一个采样周期的平均耗时，单位us</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.MaxCost">
            <summary>持续采样时间内的最大平均耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.PerfCounter.DoWork(System.Object)">
            <summary>定期采样，保存最近60组到数组队列里面</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Log.PerfCounter.ToString">
            <summary>已重载。输出统计信息</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.TextControlLog">
            <summary>文本控件输出日志</summary>
        </member>
        <member name="P:NewLife.Log.TextControlLog.Control">
            <summary>文本控件</summary>
        </member>
        <member name="P:NewLife.Log.TextControlLog.MaxLines">
            <summary>最大行数，超过该行数讲清空文本控件。默认1000行</summary>
        </member>
        <member name="M:NewLife.Log.TextControlLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.TextControlLog.WriteLog(System.Windows.Forms.Control,System.String,System.Int32)">
            <summary>在WinForm控件上输出日志，主要考虑非UI线程操作</summary>
            <remarks>不是常用功能，为了避免干扰常用功能，保持UseWinForm开头</remarks>
            <param name="control">要绑定日志输出的WinForm控件</param>
            <param name="msg">日志</param>
            <param name="maxLines">最大行数</param>
        </member>
        <member name="T:NewLife.Log.TextFileLog">
            <summary>文本文件日志类。提供向文本文件写日志的能力</summary>
            <remarks>
            两大用法：
            1，Create(path, fileFormat) 指定日志目录和文件名格式
            2，CreateFile(path) 指定文件，一直往里面写
            
            2015-06-01 为了继承TextFileLog，增加了无参构造函数，修改了异步写日志方法为虚方法，可以进行重载
            </remarks>
        </member>
        <member name="P:NewLife.Log.TextFileLog.LogPath">
            <summary>日志目录</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.FileFormat">
            <summary>日志文件格式。默认{0:yyyy_MM_dd}.log</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.MaxBytes">
            <summary>日志文件上限。超过上限后拆分新日志文件，默认10MB，0表示不限制大小</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.Backups">
            <summary>日志文件备份。超过备份数后，最旧的文件将被删除，默认100，0表示不限制个数</summary>
        </member>
        <member name="F:NewLife.Log.TextFileLog._isFirst">
            <summary>是否当前进程的第一次写日志</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.#ctor">
            <summary>该构造函数没有作用，为了继承而设置</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Create(System.String,System.String)">
            <summary>每个目录的日志实例应该只有一个，所以采用静态创建</summary>
            <param name="path">日志目录或日志文件路径</param>
            <param name="fileFormat"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.CreateFile(System.String)">
            <summary>每个目录的日志实例应该只有一个，所以采用静态创建</summary>
            <param name="path">日志目录或日志文件路径</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.InitLog(System.String)">
            <summary>初始化日志记录文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.GetLogFile">
            <summary>获取日志文件路径</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteFile">
            <summary>写文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.DoWriteAndClose(System.Object)">
            <summary>关闭文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteAndClose(System.DateTime)">
            <summary>写入队列日志并关闭文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.WriteLogEventArgs">
            <summary>写日志事件参数</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Level">
            <summary>日志等级</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Message">
            <summary>日志信息</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadID">
            <summary>线程编号</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsPool">
            <summary>是否线程池线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsWeb">
            <summary>是否Web线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadName">
            <summary>线程名</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.TaskID">
            <summary>任务编号</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor">
            <summary>实例化一个日志事件参数</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Current">
            <summary>线程专有实例。线程静态，每个线程只用一个，避免GC浪费</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Set(NewLife.Log.LogLevel)">
            <summary>初始化为新日志</summary>
            <param name="level">日志等级</param>
            <returns>返回自身，链式写法</returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Set(System.String,System.Exception)">
            <summary>初始化为新日志</summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
            <returns>返回自身，链式写法</returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Reset">
            <summary>重置日志事件对象，释放内存</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.GetAndReset">
            <summary>获取日志全文，并重置对象释放内存</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.CurrentThreadName">
            <summary>设置当前线程输出日志时的线程名</summary>
        </member>
        <member name="T:NewLife.Log.XTrace">
             <summary>日志类，包含跟踪调试功能</summary>
             <remarks>
             文档 https://newlifex.com/core/log
            
             该静态类包括写日志、写调用栈和Dump进程内存等调试功能。
            
             默认写日志到文本文件，可通过修改<see cref="P:NewLife.Log.XTrace.Log"/>属性来增加日志输出方式。
             对于控制台工程，可以直接通过UseConsole方法，把日志输出重定向为控制台输出，并且可以为不同线程使用不同颜色。
             </remarks>
        </member>
        <member name="F:NewLife.Log.XTrace._Log">
            <summary>文本文件日志</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.Log">
            <summary>日志提供者，默认使用文本文件日志</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String)">
            <summary>输出日志</summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteException(System.Exception)">
            <summary>输出异常日志</summary>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.InitLog">
            <summary>
            2012.11.05 修正初次调用的时候，由于同步BUG，导致Log为空的问题。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.UseConsole(System.Boolean,System.Boolean)">
            <summary>使用控制台输出日志，只能调用一次</summary>
            <param name="useColor">是否使用颜色，默认使用</param>
            <param name="useFileLog">是否同时使用文件日志，默认使用</param>
        </member>
        <member name="M:NewLife.Log.XTrace.DisableConsoleEdit">
            <summary>
            禁用控制台快捷编辑，在UseConsole方法之后调用
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.DisableConsoleCloseButton(System.String)">
            <summary>
            禁用控制台关闭按钮
            </summary>
            <param name="consoleTitle">控制台程序名称，可使用Console.Title动态设置的值</param>
        </member>
        <member name="M:NewLife.Log.XTrace.UseWinForm(System.Boolean)">
            <summary>拦截WinForm异常并记录日志，可指定是否用<see cref="T:System.Windows.Forms.MessageBox"/>显示。</summary>
            <param name="showErrorMessage">发为捕获异常时，是否显示提示，默认显示</param>
        </member>
        <member name="M:NewLife.Log.XTrace.UseWinFormControl(System.Windows.Forms.Control,System.Boolean,System.Int32)">
            <summary>在WinForm控件上输出日志，主要考虑非UI线程操作</summary>
            <remarks>不是常用功能，为了避免干扰常用功能，保持UseWinForm开头</remarks>
            <param name="control">要绑定日志输出的WinForm控件</param>
            <param name="useFileLog">是否同时使用文件日志，默认使用</param>
            <param name="maxLines">最大行数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.Combine(System.Windows.Forms.Control,NewLife.Log.ILog,System.Int32)">
            <summary>控件绑定到日志，生成混合日志</summary>
            <param name="control"></param>
            <param name="log"></param>
            <param name="maxLines"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.XTrace.Debug">
            <summary>是否调试。</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.LogPath">
            <summary>文本日志目录</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteVersion">
            <summary>输出核心库和启动程序的版本号</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteVersion(System.Reflection.Assembly)">
            <summary>输出程序集版本</summary>
            <param name="asm"></param>
        </member>
        <member name="T:NewLife.Messaging.DataKinds">
            <summary>数据类型。可用于标准消息的Flag</summary>
        </member>
        <member name="F:NewLife.Messaging.DataKinds.String">
            <summary>字符串</summary>
        </member>
        <member name="F:NewLife.Messaging.DataKinds.Packet">
            <summary>二进制数据包</summary>
        </member>
        <member name="F:NewLife.Messaging.DataKinds.Binary">
            <summary>二进制对象</summary>
        </member>
        <member name="F:NewLife.Messaging.DataKinds.Json">
            <summary>Json对象</summary>
        </member>
        <member name="T:NewLife.Messaging.DefaultMessage">
            <summary>标准消息SRMP</summary>
            <remarks>
            标准协议最大优势是短小，头部定长，没有序列化成本，适用于专业级RPC以及嵌入式通信。
            缺点是可读性差，不能适用于字符串通信场景。
            标准网络封包协议：1 Flag + 1 Sequence + 2 Length + N Payload
            1个字节标识位，标识请求、响应、错误等；
            1个字节序列号，用于请求响应包配对；
            2个字节数据长度N，小端，指示后续负载数据长度（不包含头部4个字节），解决粘包问题；
            N个字节负载数据，数据内容完全由业务决定，最大长度65535=64k。
            如：
            Open => OK
            01-01-04-00-"Open" => 81-01-02-00-"OK"
            
            Length为0xFFFF时，后续4字节为正式长度，以支持超过64k的扩展包
            </remarks>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.Flag">
            <summary>标记位。可用于标识消息数据类型DataKinds（非强制），内置0标识字符串，默认1标识二进制</summary>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.Sequence">
            <summary>序列号，匹配请求和响应</summary>
        </member>
        <member name="F:NewLife.Messaging.DefaultMessage._raw">
            <summary>解析数据时的原始报文</summary>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.GetLength(NewLife.Data.Packet)">
            <summary>获取数据包长度</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.GetRaw">
            <summary>获取解析数据时的原始报文</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.ToString">
            <summary>消息摘要</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.IMessage">
            <summary>消息命令</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Reply">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Error">
            <summary>是否有错</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.OneWay">
            <summary>单向请求</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="M:NewLife.Messaging.IMessage.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.IMessage.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.IMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.Message">
            <summary>消息命令基类</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Reply">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Error">
            <summary>是否有错</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.OneWay">
            <summary>单向请求</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="M:NewLife.Messaging.Message.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.Message.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.MessageEventArgs">
            <summary>收到消息时的事件参数</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.Packet">
            <summary>数据包</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.Message">
            <summary>消息</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.UserState">
            <summary>用户数据。比如远程地址等</summary>
        </member>
        <member name="T:NewLife.Messaging.PacketCodec">
            <summary>数据包编码器</summary>
            <remarks>
            文档 https://newlifex.com/core/packet_codec
            编码器的设计目标是作为网络粘包处理的基础实现。
            </remarks>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Stream">
            <summary>缓存流</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.GetLength">
            <summary>获取长度的委托。本包所应该拥有的总长度，满足该长度后解除一个封包</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Offset">
            <summary>长度的偏移量，截取数据包时加上，否则将会漏掉长度之间的数据包，如MQTT</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Last">
            <summary>最后一次解包成功，而不是最后一次接收</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Expire">
            <summary>缓存有效期。超过该时间后仍未匹配数据包的缓存数据将被抛弃，默认5000ms</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.MaxCache">
            <summary>最大缓存待处理数据。默认1M</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Messaging.PacketCodec.Parse(NewLife.Data.Packet)">
            <summary>数据包加入缓存数据末尾，分析数据流，得到一帧或多帧数据</summary>
            <param name="pk">待分析数据包</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.PacketCodec.CheckCache">
            <summary>检查缓存</summary>
        </member>
        <member name="T:NewLife.Model.IActor">
            <summary>无锁并行编程模型</summary>
            <remarks>
            文档 https://newlifex.com/core/actor
            
            独立线程轮询消息队列，简单设计避免影响默认线程池。
            适用于任务颗粒较大的场合，例如IO操作。
            </remarks>
        </member>
        <member name="M:NewLife.Model.IActor.Tell(System.Object,NewLife.Model.IActor)">
            <summary>添加消息，驱动内部处理</summary>
            <param name="message">消息</param>
            <param name="sender">发送者</param>
            <returns>返回待处理消息数</returns>
        </member>
        <member name="T:NewLife.Model.ActorContext">
            <summary>Actor上下文</summary>
        </member>
        <member name="P:NewLife.Model.ActorContext.Sender">
            <summary>发送者</summary>
        </member>
        <member name="P:NewLife.Model.ActorContext.Message">
            <summary>消息</summary>
        </member>
        <member name="T:NewLife.Model.Actor">
            <summary>无锁并行编程模型</summary>
            <remarks>
            独立线程轮询消息队列，简单设计避免影响默认线程池。
            </remarks>
        </member>
        <member name="P:NewLife.Model.Actor.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.Actor.Active">
            <summary>是否启用</summary>
        </member>
        <member name="P:NewLife.Model.Actor.BoundedCapacity">
            <summary>受限容量。最大可堆积的消息数，默认Int32.MaxValue</summary>
        </member>
        <member name="P:NewLife.Model.Actor.BatchSize">
            <summary>批大小。每次处理消息数，默认1，大于1表示启用批量处理模式</summary>
        </member>
        <member name="P:NewLife.Model.Actor.LongRunning">
            <summary>是否长时间运行。长时间运行任务使用独立线程，默认false</summary>
        </member>
        <member name="P:NewLife.Model.Actor.MailBox">
            <summary>存放消息的邮箱。默认FIFO实现，外部可覆盖</summary>
        </member>
        <member name="P:NewLife.Model.Actor.Tracer">
            <summary>
            性能追踪器
            </summary>
        </member>
        <member name="P:NewLife.Model.Actor.TracerParent">
            <summary>
            父级性能追踪器。用于把内外调用链关联起来
            </summary>
        </member>
        <member name="M:NewLife.Model.Actor.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Model.Actor.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Model.Actor.ToString">
            <summary>已重载。显示名称</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Actor.Start">
            <summary>通知开始处理</summary>
            <remarks>
            添加消息时自动触发
            </remarks>
        </member>
        <member name="M:NewLife.Model.Actor.OnStart">
            <summary>开始时，返回执行线程包装任务</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Actor.Stop(System.Int32)">
            <summary>通知停止添加消息，并等待处理完成</summary>
            <param name="msTimeout">等待的毫秒数。0表示不等待，-1表示无限等待</param>
        </member>
        <member name="M:NewLife.Model.Actor.Tell(System.Object,NewLife.Model.IActor)">
            <summary>添加消息，驱动内部处理</summary>
            <param name="message">消息</param>
            <param name="sender">发送者</param>
            <returns>返回待处理消息数</returns>
        </member>
        <member name="M:NewLife.Model.Actor.DoActorWork">
            <summary>循环消费消息</summary>
        </member>
        <member name="M:NewLife.Model.Actor.Loop">
            <summary>循环消费消息</summary>
        </member>
        <member name="M:NewLife.Model.Actor.ReceiveAsync(NewLife.Model.ActorContext,System.Threading.CancellationToken)">
            <summary>处理消息。批大小为1时使用该方法</summary>
            <param name="context">上下文</param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="M:NewLife.Model.Actor.ReceiveAsync(NewLife.Model.ActorContext[],System.Threading.CancellationToken)">
            <summary>批量处理消息。批大小大于1时使用该方法</summary>
            <param name="contexts">上下文集合</param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="T:NewLife.Model.DeferredQueue">
            <summary>延迟队列。缓冲合并对象，批量处理</summary>
            <remarks>
            借助实体字典，缓冲实体对象，定期给字典换新，实现批量处理。
            
            有可能外部拿到对象后，正在修改，内部恰巧执行批量处理，导致外部的部分修改未能得到处理。
            解决办法是增加一个提交机制，外部用完后提交修改，内部需要处理时，等待一个时间。
            </remarks>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Entities">
            <summary>实体字典</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.TraceCount">
            <summary>跟踪数。达到该值时输出跟踪日志，默认1000</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Period">
            <summary>周期。默认10_000毫秒</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.MaxEntity">
            <summary>最大个数。超过该个数时，进入队列将产生堵塞。默认10_000_000</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.BatchSize">
            <summary>批大小。默认5_000</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.WaitForBusy">
            <summary>等待借出对象确认修改的时间，默认3000ms</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Speed">
            <summary>保存速度，每秒保存多少个实体</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Async">
            <summary>是否异步处理。默认true表示异步处理，共用DQ定时调度；false表示同步处理，独立线程</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Times">
            <summary>合并保存的总次数</summary>
        </member>
        <member name="F:NewLife.Model.DeferredQueue.Finish">
            <summary>批次处理成功时</summary>
        </member>
        <member name="F:NewLife.Model.DeferredQueue.Error">
            <summary>批次处理失败时</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Dispose(System.Boolean)">
            <summary>销毁。统计队列销毁时保存数据</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Init">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.OnInit">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.TryAdd(System.String,System.Object)">
            <summary>尝试添加</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.GetOrAdd``1(System.String,System.Func{System.String,``0})">
            <summary>获取 或 添加 实体对象，在外部修改对象值</summary>
            <remarks>
            外部正在修改对象时，内部不允许执行批量处理
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="valueFactory"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Model.DeferredQueue._busy">
            <summary>等待确认修改的借出对象数</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Commit(System.String)">
            <summary>提交对象的修改，外部不再使用该对象</summary>
            <param name="key"></param>
        </member>
        <member name="F:NewLife.Model.DeferredQueue._count">
            <summary>当前缓存个数</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.ProcessAll(System.Collections.Generic.ICollection{System.Object})">
            <summary>定时处理全部数据</summary>
            <param name="list"></param>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Process(System.Collections.Generic.IList{System.Object})">
            <summary>处理一批</summary>
            <param name="list"></param>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.OnError(System.Collections.Generic.IList{System.Object},System.Exception)">
            <summary>发生错误</summary>
            <param name="list"></param>
            <param name="ex"></param>
        </member>
        <member name="T:NewLife.Model.IHostedService">
            <summary>轻量级主机服务</summary>
            <remarks>
            文档 https://newlifex.com/core/host
            </remarks>
        </member>
        <member name="M:NewLife.Model.IHostedService.StartAsync(System.Threading.CancellationToken)">
            <summary>开始服务</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IHostedService.StopAsync(System.Threading.CancellationToken)">
            <summary>停止服务</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.HostedServiceExtensions">
            <summary>主机服务扩展</summary>
        </member>
        <member name="M:NewLife.Model.HostedServiceExtensions.AddHostedService``1(NewLife.Model.IObjectContainer)">
            <summary>注册主机服务，在主机启动和停止时执行</summary>
            <typeparam name="THostedService"></typeparam>
            <param name="services"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.HostedServiceExtensions.AddHostedService``1(NewLife.Model.IObjectContainer,System.Func{System.IServiceProvider,``0})">
            <summary>注册主机服务，在主机启动和停止时执行</summary>
            <typeparam name="THostedService"></typeparam>
            <param name="services"></param>
            <param name="implementationFactory"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IHost">
            <summary>轻量级应用主机</summary>
            <remarks>
            文档 https://newlifex.com/core/host
            销毁主机时，会触发所有服务的停止事件
            </remarks>
        </member>
        <member name="M:NewLife.Model.IHost.Add(NewLife.Model.IHostedService)">
            <summary>添加服务</summary>
            <param name="service"></param>
        </member>
        <member name="M:NewLife.Model.IHost.Add``1">
            <summary>添加服务</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Model.IHost.Run">
            <summary>同步运行，大循环阻塞</summary>
        </member>
        <member name="M:NewLife.Model.IHost.RunAsync">
            <summary>异步允许，大循环阻塞</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IHost.Close(System.String)">
            <summary>关闭主机</summary>
            <param name="reason"></param>
        </member>
        <member name="T:NewLife.Model.Host">
            <summary>轻量级应用主机</summary>
            <remarks>
            文档 https://newlifex.com/core/host
            销毁主机时，会触发所有服务的停止事件
            </remarks>
        </member>
        <member name="P:NewLife.Model.Host.ServiceProvider">
            <summary>服务提供者</summary>
        </member>
        <member name="P:NewLife.Model.Host.Services">
            <summary>服务集合</summary>
        </member>
        <member name="M:NewLife.Model.Host.#ctor(System.IServiceProvider)">
            <summary>通过制定服务提供者来实例化一个应用主机</summary>
            <param name="serviceProvider"></param>
        </member>
        <member name="M:NewLife.Model.Host.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Model.Host.Add``1">
            <summary>添加服务</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Model.Host.Add(NewLife.Model.IHostedService)">
            <summary>添加服务</summary>
            <param name="service"></param>
        </member>
        <member name="M:NewLife.Model.Host.StartAsync(System.Threading.CancellationToken)">
            <summary>开始</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Host.StopAsync(System.Threading.CancellationToken)">
            <summary>停止</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Host.Run">
            <summary>同步运行，大循环阻塞</summary>
        </member>
        <member name="M:NewLife.Model.Host.RunAsync">
            <summary>异步允许，大循环阻塞</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Host.Close(System.String)">
            <summary>关闭主机</summary>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Model.Host.RegisterExit(System.EventHandler)">
            <summary>注册应用退出事件</summary>
            <remarks>在不同场景可能被多次执行，调用方需要做判断</remarks>
            <param name="onExit">回调函数</param>
        </member>
        <member name="M:NewLife.Model.Host.RegisterExit(System.Action)">
            <summary>注册应用退出事件。仅执行一次</summary>
            <param name="onExit">回调函数</param>
        </member>
        <member name="T:NewLife.Model.BackgroundService">
            <summary>后台任务</summary>
            <remarks>
            文档 https://newlifex.com/core/host
            </remarks>
        </member>
        <member name="M:NewLife.Model.BackgroundService.ExecuteAsync(System.Threading.CancellationToken)">
            <summary>执行</summary>
            <param name="stoppingToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.BackgroundService.StartAsync(System.Threading.CancellationToken)">
            <summary>开始</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.BackgroundService.StopAsync(System.Threading.CancellationToken)">
            <summary>停止</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.BackgroundService.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="T:NewLife.Model.IAuthUser">
            <summary>认证用户接口，具有登录验证、注册、在线等基本信息</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.Logins">
            <summary>登录次数</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.LastLogin">
            <summary>最后登录</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.LastLoginIP">
            <summary>最后登录IP</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.RegisterTime">
            <summary>注册时间</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.RegisterIP">
            <summary>注册IP</summary>
        </member>
        <member name="M:NewLife.Model.IAuthUser.Save">
            <summary>保存</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ManageUserHelper">
            <summary>用户接口工具类</summary>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckEqual(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码相等</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckMD5(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码MD5</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckRC4(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码RC4</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.SaveLogin(NewLife.Model.IAuthUser,NewLife.Net.INetSession)">
            <summary>保存登录信息</summary>
            <param name="user"></param>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.SaveRegister(NewLife.Model.IAuthUser,NewLife.Net.INetSession)">
            <summary>保存注册信息</summary>
            <param name="user"></param>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Model.IHandler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Model.IHandler.Prev">
            <summary>上一个处理器</summary>
        </member>
        <member name="P:NewLife.Model.IHandler.Next">
            <summary>下一个处理器</summary>
        </member>
        <member name="M:NewLife.Model.IHandler.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <remarks>
            最终处理器决定如何使用消息。
            处理得到单个消息时，调用一次下一级处理器，返回下级结果给上一级；
            处理得到多个消息时，调用多次下一级处理器，返回null给上一级；
            </remarks>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Model.Handler.Prev">
            <summary>上一个处理器</summary>
        </member>
        <member name="P:NewLife.Model.Handler.Next">
            <summary>下一个处理器</summary>
        </member>
        <member name="M:NewLife.Model.Handler.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <remarks>
            最终处理器决定如何使用消息。
            处理得到单个消息时，调用一次下一级处理器，返回下级结果给上一级；
            处理得到多个消息时，调用多次下一级处理器，返回null给上一级；
            </remarks>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Handler.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Handler.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.Handler.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.Handler.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.IHandlerContext">
            <summary>处理器上下文</summary>
        </member>
        <member name="P:NewLife.Model.IHandlerContext.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Model.IHandlerContext.Owner">
            <summary>上下文拥有者</summary>
        </member>
        <member name="M:NewLife.Model.IHandlerContext.FireRead(System.Object)">
            <summary>读取管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Model.IHandlerContext.FireWrite(System.Object)">
            <summary>写入管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Model.HandlerContext">
            <summary>处理器上下文</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Owner">
            <summary>上下文拥有者</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.HandlerContext.FireRead(System.Object)">
            <summary>读取管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Model.HandlerContext.FireWrite(System.Object)">
            <summary>写入管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Model.IManageUser">
            <summary>用户接口</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.NickName">
            <summary>昵称</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.Enable">
            <summary>启用</summary>
        </member>
        <member name="T:NewLife.Model.IObjectContainer">
            <summary>轻量级对象容器，支持注入</summary>
            <remarks>
            文档 https://newlifex.com/core/object_container
            </remarks>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Register(System.Type,System.Type,System.Object)">
            <summary>注册类型和名称</summary>
            <param name="serviceType">接口类型</param>
            <param name="implementationType">实现类型</param>
            <param name="instance">实例</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Add(NewLife.Model.IObject)">
            <summary>添加</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.TryAdd(NewLife.Model.IObject)">
            <summary>尝试添加</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Resolve(System.Type,System.IServiceProvider)">
            <summary>在指定容器中解析类型的实例</summary>
            <param name="serviceType">接口类型</param>
            <param name="serviceProvider">容器</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ObjectLifetime">
            <summary>生命周期</summary>
        </member>
        <member name="F:NewLife.Model.ObjectLifetime.Singleton">
            <summary>单实例</summary>
        </member>
        <member name="F:NewLife.Model.ObjectLifetime.Scoped">
            <summary>容器内单实例</summary>
        </member>
        <member name="F:NewLife.Model.ObjectLifetime.Transient">
            <summary>每次一个实例</summary>
        </member>
        <member name="T:NewLife.Model.IObject">
            <summary>对象映射接口</summary>
        </member>
        <member name="P:NewLife.Model.IObject.ServiceType">
            <summary>服务类型</summary>
        </member>
        <member name="P:NewLife.Model.IObject.ImplementationType">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.IObject.Lifetime">
            <summary>生命周期</summary>
        </member>
        <member name="T:NewLife.Model.IPipeline">
            <summary>管道。进站顺序，出站逆序</summary>
        </member>
        <member name="M:NewLife.Model.IPipeline.Add(NewLife.Model.IHandler)">
            <summary>添加处理器到末尾</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IPipeline.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.Pipeline">
            <summary>管道。进站顺序，出站逆序</summary>
        </member>
        <member name="P:NewLife.Model.Pipeline.Handlers">
            <summary>处理器集合</summary>
        </member>
        <member name="M:NewLife.Model.Pipeline.Add(NewLife.Model.IHandler)">
            <summary>添加处理器到末尾</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Pipeline.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，顺序过滤消息，返回结果作为下一个处理器消息</summary>
            <remarks>
            最终处理器决定如何使用消息。
            处理得到单个消息时，调用一次下一级处理器，返回下级结果给上一级；
            处理得到多个消息时，调用多次下一级处理器，返回null给上一级；
            </remarks>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，逆序过滤消息，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.IPlugin">
            <summary>通用插件接口</summary>
            <remarks>
            为了方便构建一个简单通用的插件系统，先规定如下：
            1，负责加载插件的宿主，在加载插件后会进行插件实例化，此时可在插件构造函数中做一些事情，但不应该开始业务处理，因为宿主的准备工作可能尚未完成
            2，宿主一切准备就绪后，会顺序调用插件的Init方法，并将宿主标识传入，插件通过标识区分是否自己的目标宿主。插件的Init应尽快完成。
            3，如果插件实现了<see cref="T:System.IDisposable"/>接口，宿主最后会清理资源。
            </remarks>
        </member>
        <member name="M:NewLife.Model.IPlugin.Init(System.String,System.IServiceProvider)">
            <summary>初始化</summary>
            <param name="identity">插件宿主标识</param>
            <param name="provider">服务提供者</param>
            <returns>返回初始化是否成功。如果当前宿主不是所期待的宿主，这里返回false</returns>
        </member>
        <member name="T:NewLife.Model.PluginAttribute">
            <summary>插件特性。用于判断某个插件实现类是否支持某个宿主</summary>
            <remarks>实例化</remarks>
            <param name="identity"></param>
        </member>
        <member name="M:NewLife.Model.PluginAttribute.#ctor(System.String)">
            <summary>插件特性。用于判断某个插件实现类是否支持某个宿主</summary>
            <remarks>实例化</remarks>
            <param name="identity"></param>
        </member>
        <member name="P:NewLife.Model.PluginAttribute.Identity">
            <summary>插件宿主标识</summary>
        </member>
        <member name="T:NewLife.Model.PluginManager">
            <summary>插件管理器</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Identity">
            <summary>宿主标识，用于供插件区分不同宿主</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Provider">
            <summary>宿主服务提供者</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Plugins">
            <summary>插件集合</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.#ctor">
            <summary>实例化一个插件管理器</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.Dispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.Model.PluginManager.Load">
            <summary>加载插件。此时是加载所有插件，无法识别哪些是需要的</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.LoadPlugins">
            <summary>加载插件</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.PluginManager.Init">
            <summary>开始初始化。初始化之后，不属于当前宿主的插件将会被过滤掉</summary>
        </member>
        <member name="T:NewLife.Model.IServer">
            <summary>服务接口。</summary>
            <remarks>服务代理XAgent可以附加代理实现了IServer接口的服务。</remarks>
        </member>
        <member name="M:NewLife.Model.IServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Model.IServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="T:NewLife.Model.IServiceScope">
            <summary>范围服务。该范围生命周期内，每个服务类型只有一个实例</summary>
            <remarks>
            满足Singleton和Scoped的要求，暂时无法满足Transient的要求（仍然只有一份）。
            </remarks>
        </member>
        <member name="P:NewLife.Model.IServiceScope.ServiceProvider">
            <summary>服务提供者</summary>
        </member>
        <member name="T:NewLife.Model.IServiceScopeFactory">
            <summary>范围服务工厂</summary>
        </member>
        <member name="M:NewLife.Model.IServiceScopeFactory.CreateScope">
            <summary>创建范围服务</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ModelExtension">
            <summary>模型扩展</summary>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetService``1(System.IServiceProvider)">
            <summary>获取指定类型的服务对象</summary>
            <typeparam name="T"></typeparam>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetRequiredService(System.IServiceProvider,System.Type)">
            <summary>获取必要的服务，不存在时抛出异常</summary>
            <param name="provider">服务提供者</param>
            <param name="serviceType">服务类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetRequiredService``1(System.IServiceProvider)">
            <summary>获取必要的服务，不存在时抛出异常</summary>
            <typeparam name="T">服务类型</typeparam>
            <param name="provider">服务提供者</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetServices``1(System.IServiceProvider)">
            <summary>获取一批服务</summary>
            <typeparam name="T">服务类型</typeparam>
            <param name="provider">服务提供者</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetServices(System.IServiceProvider,System.Type)">
            <summary>获取一批服务</summary>
            <param name="provider">服务提供者</param>
            <param name="serviceType">服务类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.CreateScope(System.IServiceProvider)">
            <summary>创建范围作用域，该作用域内提供者解析一份数据</summary>
            <param name="provider">服务提供者</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.CreateInstance(System.IServiceProvider,System.Type)">
            <summary>创建服务对象，使用服务提供者来填充构造函数</summary>
            <param name="provider">服务提供者</param>
            <param name="serviceType">服务类型</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ObjectContainer">
            <summary>轻量级对象容器，支持注入</summary>
            <remarks>
            文档 https://newlifex.com/core/object_container
            </remarks>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Current">
            <summary>当前容器</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Provider">
            <summary>当前容器提供者</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Services">
            <summary>服务集合</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Count">
            <summary>注册项个数</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Add(NewLife.Model.IObject)">
            <summary>添加，允许重复添加同一个服务</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.TryAdd(NewLife.Model.IObject)">
            <summary>尝试添加，不允许重复添加同一个服务</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Register(System.Type,System.Type,System.Object)">
            <summary>注册</summary>
            <param name="serviceType">接口类型</param>
            <param name="implementationType">实现类型</param>
            <param name="instance">实例</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Resolve(System.Type,System.IServiceProvider)">
            <summary>在指定容器中解析类型的实例</summary>
            <param name="serviceType">接口类型</param>
            <param name="serviceProvider">容器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Resolve(NewLife.Model.IObject,System.IServiceProvider)">
            <summary>在指定容器中解析类型的实例</summary>
            <param name="item"></param>
            <param name="serviceProvider"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ServiceDescriptor">
            <summary>对象映射</summary>
        </member>
        <member name="P:NewLife.Model.ServiceDescriptor.ServiceType">
            <summary>服务类型</summary>
        </member>
        <member name="P:NewLife.Model.ServiceDescriptor.ImplementationType">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.ServiceDescriptor.Lifetime">
            <summary>生命周期</summary>
        </member>
        <member name="P:NewLife.Model.ServiceDescriptor.Instance">
            <summary>实例</summary>
        </member>
        <member name="P:NewLife.Model.ServiceDescriptor.Factory">
            <summary>对象工厂</summary>
        </member>
        <member name="M:NewLife.Model.ServiceDescriptor.#ctor(System.Type)">
            <summary>实例化</summary>
            <param name="serviceType"></param>
        </member>
        <member name="M:NewLife.Model.ServiceDescriptor.#ctor(System.Type,System.Type)">
            <summary>实例化</summary>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
        </member>
        <member name="M:NewLife.Model.ServiceDescriptor.#ctor(System.Type,System.Type,System.Object)">
            <summary>实例化</summary>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:NewLife.Model.ServiceDescriptor.ToString">
            <summary>显示友好名称</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Model.ServiceProvider.Container">
            <summary>容器</summary>
        </member>
        <member name="T:NewLife.Model.ObjectContainerHelper">
            <summary>对象容器助手。扩展方法专用</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加单实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton``2(NewLife.Model.IObjectContainer)">
            <summary>添加单实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加单实例，指定实例工厂</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton``1(NewLife.Model.IObjectContainer,System.Func{System.IServiceProvider,``0})">
            <summary>添加单实例，指定实例工厂</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Object)">
            <summary>添加单实例，指定实例</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton``1(NewLife.Model.IObjectContainer,``0)">
            <summary>添加单实例，指定实例</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>尝试添加单实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddSingleton``2(NewLife.Model.IObjectContainer)">
            <summary>尝试添加单实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddSingleton``1(NewLife.Model.IObjectContainer,``0)">
            <summary>尝试添加单实例，指定实例</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddScoped(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加范围容器实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddScoped``2(NewLife.Model.IObjectContainer)">
            <summary>添加范围容器实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddScoped``1(NewLife.Model.IObjectContainer)">
            <summary>添加范围容器实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddScoped(NewLife.Model.IObjectContainer,System.Type,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加范围容器实例，指定实现工厂</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddScoped``1(NewLife.Model.IObjectContainer,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加范围容器实例，指定实现工厂</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddScoped(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加范围容器实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddScoped``2(NewLife.Model.IObjectContainer)">
            <summary>尝试添加范围容器实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddScoped``1(NewLife.Model.IObjectContainer,``0)">
            <summary>尝试添加范围容器实例，指定实例</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient``2(NewLife.Model.IObjectContainer)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient``1(NewLife.Model.IObjectContainer)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient(NewLife.Model.IObjectContainer,System.Type,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加瞬态实例，指定实现工厂</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient``1(NewLife.Model.IObjectContainer,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加瞬态实例，指定实现工厂</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddTransient(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddTransient``2(NewLife.Model.IObjectContainer)">
            <summary>尝试添加瞬态实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddTransient``1(NewLife.Model.IObjectContainer,``0)">
            <summary>尝试添加瞬态实例，指定实例</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.BuildServiceProvider(NewLife.Model.IObjectContainer)">
            <summary>从对象容器创建服务提供者</summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.BuildHost(NewLife.Model.IObjectContainer)">
            <summary>从对象容器创建应用主机</summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.Resolve``1(NewLife.Model.IObjectContainer)">
            <summary>解析类型的实例</summary>
            <typeparam name="TService">接口类型</typeparam>
            <param name="container">对象容器</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.IMatchQueue">
            <summary>消息匹配队列接口。用于把响应数据包配对到请求包</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Add(System.Object,System.Object,System.Int32,System.Threading.Tasks.TaskCompletionSource{System.Object})">
            <summary>加入请求队列</summary>
            <param name="owner">拥有者</param>
            <param name="request">请求消息</param>
            <param name="msTimeout">超时取消时间</param>
            <param name="source">任务源</param>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Match(System.Object,System.Object,System.Object,System.Func{System.Object,System.Object,System.Boolean})">
            <summary>检查请求队列是否有匹配该响应的请求</summary>
            <param name="owner">拥有者</param>
            <param name="response">响应消息</param>
            <param name="result">任务结果</param>
            <param name="callback">用于检查匹配的回调</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Clear">
            <summary>清空队列</summary>
        </member>
        <member name="T:NewLife.Net.Handlers.DefaultMatchQueue">
            <summary>消息匹配队列。子类可重载以自定义请求响应匹配逻辑</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.#ctor(System.Int32)">
            <summary>按指定大小来初始化队列</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Add(System.Object,System.Object,System.Int32,System.Threading.Tasks.TaskCompletionSource{System.Object})">
            <summary>加入请求队列</summary>
            <param name="owner">拥有者</param>
            <param name="request">请求的数据</param>
            <param name="msTimeout">超时取消时间</param>
            <param name="source">任务源</param>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Match(System.Object,System.Object,System.Object,System.Func{System.Object,System.Object,System.Boolean})">
            <summary>检查请求队列是否有匹配该响应的请求</summary>
            <param name="owner">拥有者</param>
            <param name="response">响应消息</param>
            <param name="result">任务结果</param>
            <param name="callback">用于检查匹配的回调</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Check(System.Object)">
            <summary>定时检查发送队列，超时未收到响应则重发</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Clear">
            <summary>清空队列</summary>
        </member>
        <member name="T:NewLife.Net.Handlers.JsonCodec">
            <summary>Json编码器。用于把用户对象编码为Json字符串</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.JsonCodec.JsonHost">
            <summary>Json序列化主机</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.JsonCodec.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>发送消息时，写入数据，编码并加入队列</summary>
            <remarks>
            遇到消息T时，调用Encode编码并加入队列。
            Encode返回空时，跳出调用链。
            </remarks>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.JsonCodec.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>接收数据后，读取数据包，Decode解码得到消息</summary>
            <remarks>
            Decode可以返回多个消息，每个消息调用一次下一级处理器。
            Decode返回空时，跳出调用链。
            </remarks>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.LengthFieldCodec">
            <summary>长度字段作为头部</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Offset">
            <summary>长度所在位置</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Size">
            <summary>长度占据字节数，1/2/4个字节，0表示压缩编码整数，默认2</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Expire">
            <summary>过期时间，超过该时间后按废弃数据处理，默认500ms</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Encode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>编码</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.MessageCodec`1">
            <summary>消息封包编码器</summary>
            <remarks>
            该编码器向基于请求响应模型的协议提供了匹配队列，能够根据响应序列号去匹配请求。
            
            消息封包编码器实现网络处理器，具体用法是添加网络客户端或服务端主机。主机收发消息时，会自动调用编码器对消息进行编码解码。
            发送消息SendMessage时调用编码器Write/Encode方法；
            接收消息时调用编码器Read/Decode方法，消息存放在ReceivedEventArgs.Message。
            
            网络编码器支持多层添加，每个编码器处理后交给下一个编码器处理，直到最后一个编码器，然后发送出去。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.Queue">
            <summary>消息队列。用于匹配请求响应包</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.QueueSize">
            <summary>匹配队列大小</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.Timeout">
            <summary>请求消息匹配队列中等待响应的超时时间。默认30_000ms</summary>
            <remarks>
            某些RPC场景需要更长时间等待响应时，可以加大该值。
            该值不宜过大，否则会导致请求队列过大，影响并行请求数。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.MaxCache">
            <summary>最大缓存待处理数据。默认10M</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.UserPacket">
            <summary>用户数据包。写入时数据包转消息，读取时消息自动解包返回数据负载，要求T实现IMessage。默认true</summary>
            <remarks>一般用于上层还有其它编码器时，实现编码器级联</remarks>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>发送消息时，写入数据，编码并加入队列</summary>
            <remarks>
            遇到消息T时，调用Encode编码并加入队列。
            Encode返回空时，跳出调用链。
            </remarks>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Encode(NewLife.Model.IHandlerContext,`0)">
            <summary>编码消息，一般是编码为Packet后传给下一个处理器</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.AddToQueue(NewLife.Model.IHandlerContext,`0)">
            <summary>把请求加入队列，等待响应到来时建立请求响应匹配</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>接收数据后，读取数据包，Decode解码得到消息</summary>
            <remarks>
            Decode可以返回多个消息，每个消息调用一次下一级处理器。
            Decode返回空时，跳出调用链。
            </remarks>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.IsMatch(System.Object,System.Object)">
            <summary>是否匹配响应</summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.GetLength(NewLife.Data.Packet,System.Int32,System.Int32)">
            <summary>从数据流中获取整帧数据长度</summary>
            <param name="pk">数据包</param>
            <param name="offset">长度的偏移量</param>
            <param name="size">长度大小。0变长，1/2/4小端字节，-2/-4大端字节</param>
            <returns>数据帧长度（包含头部长度位）</returns>
        </member>
        <member name="T:NewLife.Net.Handlers.SplitDataCodec">
            <summary>
            按指定分割字节来处理粘包的处理器
            </summary>
            <remarks>
            默认以"0x0D 0x0A"即换行来分割，分割的包包含分割字节本身，使用时请注意。
            默认分割方式：ISocket.Add&lt;SplitDataCodec&gt;()
            自定义分割方式：ISocket.Add(new SplitDataHandler { SplitData = 自定义分割字节数组 })
            自定义最大缓存大小方式：ISocket.Add(new SplitDataHandler { MaxCacheDataLength = 2048 })
            自定义方式：ISocket.Add(new SplitDataHandler { MaxCacheDataLength = 2048, SplitData = 自定义分割字节数组 })
            </remarks>
        </member>
        <member name="P:NewLife.Net.Handlers.SplitDataCodec.SplitData">
            <summary>
            粘包分割字节数据（默认0x0D,0x0A）
            </summary>
        </member>
        <member name="P:NewLife.Net.Handlers.SplitDataCodec.MaxCacheDataLength">
            <summary>
            最大缓存待处理数据，默认1024字节
            </summary>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk">包</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.GetLineLength(NewLife.Data.Packet)">
            <summary>
            获取包含分割字节在内的数据长度
            </summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.StandardCodec">
            <summary>标准网络封包。头部4字节定长</summary>
            <remarks>
            文档 https://newlifex.com/core/srmp
            </remarks>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.AddToQueue(NewLife.Model.IHandlerContext,NewLife.Messaging.IMessage)">
            <summary>加入队列</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.IsMatch(System.Object,System.Object)">
            <summary>是否匹配响应</summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.WebSocketCodec">
            <summary>WebSocket消息编码器</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.WebSocketCodec.UserPacket">
            <summary>用户数据包。写入时数据包转消息，读取时消息自动解包返回数据负载</summary>
            <remarks>一般用于上层还有其它编码器时，实现编码器级联</remarks>
        </member>
        <member name="M:NewLife.Net.Handlers.WebSocketCodec.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Net.Handlers.WebSocketCodec.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.WebSocketCodec.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.WebSocketCodec.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>发送消息时，写入数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.IDnsResolver">
            <summary>DNS解析器</summary>
        </member>
        <member name="M:NewLife.Net.IDnsResolver.Resolve(System.String)">
            <summary>解析域名</summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DnsResolver">
            <summary>DNS解析器，带有缓存，解析失败时使用旧数据</summary>
        </member>
        <member name="P:NewLife.Net.DnsResolver.Instance">
            <summary>静态实例</summary>
        </member>
        <member name="P:NewLife.Net.DnsResolver.Expire">
            <summary>缓存超时时间</summary>
        </member>
        <member name="M:NewLife.Net.DnsResolver.Resolve(System.String)">
            <summary>解析域名</summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.IIPResolver">
            <summary>IP地址提供者</summary>
        </member>
        <member name="M:NewLife.Net.IIPResolver.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址的物理地址位置</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.INetHandler">
            <summary>网络数据处理器。可作为业务处理实现，也可以作为前置协议解析</summary>
        </member>
        <member name="M:NewLife.Net.INetHandler.Init(NewLife.Net.INetSession)">
            <summary>建立连接时初始化会话</summary>
            <param name="session">会话</param>
        </member>
        <member name="M:NewLife.Net.INetHandler.Process(NewLife.Data.IData)">
            <summary>处理客户端发来的数据</summary>
            <param name="data"></param>
        </member>
        <member name="T:NewLife.Net.INetSession">
            <summary>网络服务的会话，每个Tcp/Udp连接作为一个会话</summary>
            <remarks>
            每当收到一个Tcp连接时，创建一个INetSession会话，用于处理该连接的业务。
            使用Udp服务端时，收到远程节点的第一个数据包时，也会创建一个会话，处理该节点的业务。
            
            所有应用服务器以会话<see cref="T:NewLife.Net.INetSession"/>作为业务处理核心。
            应用服务器收到新会话请求后，通过<see cref="M:NewLife.Net.INetSession.Start"/>启动一个会话处理。
            会话进行业务处理的过程中，可以通过多个Send方法向客户端发送数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.INetSession.ID">
            <summary>唯一会话标识。在主服务中唯一标识当前会话，原子自增</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Host">
            <summary>主服务。负责管理当前会话的主服务器NetServer</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Session">
            <summary>客户端。跟客户端通讯的那个Socket，其实是服务端TcpSession/UdpSession</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Remote">
            <summary>客户端地址</summary>
        </member>
        <member name="M:NewLife.Net.INetSession.Start">
            <summary>开始会话处理。</summary>
        </member>
        <member name="M:NewLife.Net.INetSession.Close(System.String)">
            <summary>主动关闭跟客户端的网络连接</summary>
            <param name="reason">断开原因。包括 SendError/RemoveNotAlive/Dispose/GC 等，其中 ConnectionReset 为网络被动断开或对方断开</param>
        </member>
        <member name="E:NewLife.Net.INetSession.Connected">
            <summary>连接创建事件。创建会话之后</summary>
        </member>
        <member name="E:NewLife.Net.INetSession.Disconnected">
            <summary>连接断开事件。包括客户端主动断开、服务端主动断开以及服务端超时下线</summary>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(NewLife.Data.Packet)">
            <summary>发送数据，直达网卡</summary>
            <param name="data">数据包</param>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(System.IO.Stream)">
            <summary>发送数据流，直达网卡</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(System.String,System.Text.Encoding)">
            <summary>发送字符串，直达网卡</summary>
            <param name="msg"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Net.INetSession.SendMessage(System.Object)">
            <summary>通过管道发送消息，不等待响应。管道内对消息进行报文封装处理，最终得到二进制数据进入网卡</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.INetSession.SendMessageAsync(System.Object)">
            <summary>异步发送消息并等待响应。管道内对消息进行报文封装处理，最终得到二进制数据进入网卡</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.INetSession.SendMessageAsync(System.Object,System.Threading.CancellationToken)">
            <summary>异步发送消息并等待响应。管道内对消息进行报文封装处理，最终得到二进制数据进入网卡</summary>
            <param name="message">消息</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.INetSession.Received">
            <summary>数据到达事件。包括原始数据包Packet以及管道处理器解码后的业务消息Message</summary>
        </member>
        <member name="T:NewLife.Net.NetSessionEventArgs">
            <summary>会话事件参数</summary>
        </member>
        <member name="P:NewLife.Net.NetSessionEventArgs.Session">
            <summary>会话</summary>
        </member>
        <member name="T:NewLife.Net.ISocket">
            <summary>基础Socket接口</summary>
            <remarks>
            封装所有基础接口的共有特性！
            
            核心设计理念：事件驱动，接口统一，简单易用！
            异常处理理念：确保主流程简单易用，特殊情况的异常通过事件处理！
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocket.Name">
            <summary>名称。主要用于日志输出</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Client">
            <summary>基础Socket对象</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Local">
            <summary>本地地址</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocket.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.ISocket.WriteLog(System.String,System.Object[])">
            <summary>已重载。日志加上前缀</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="E:NewLife.Net.ISocket.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="T:NewLife.Net.ISocketClient">
            <summary>Socket客户端</summary>
            <remarks>
            具备打开关闭
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketClient.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.ISocketClient.Active">
            <summary>是否活动</summary>
        </member>
        <member name="M:NewLife.Net.ISocketClient.Open">
            <summary>打开连接</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.ISocketClient.Close(System.String)">
            <summary>关闭连接</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="E:NewLife.Net.ISocketClient.Opened">
            <summary>打开后触发。</summary>
        </member>
        <member name="E:NewLife.Net.ISocketClient.Closed">
            <summary>关闭后触发。可实现掉线重连</summary>
        </member>
        <member name="T:NewLife.Net.ISocketRemote">
            <summary>远程通信Socket，仅具有收发功能</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.ID">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.LastTime">
            <summary>最后一次通信时间，主要表示会话活跃时间，包括收发</summary>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Send(NewLife.Data.Packet)">
            <summary>发送原始数据包</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.ISocketRemote.Remote"/>决定
            </remarks>
            <param name="data">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Receive">
            <summary>接收数据。阻塞当前线程等待返回</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>异步接收数据</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.ISocketRemote.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.SendMessageAsync(System.Object)">
            <summary>异步发送消息并等待响应</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.SendMessageAsync(System.Object,System.Threading.CancellationToken)">
            <summary>异步发送消息并等待响应</summary>
            <param name="message">消息</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.SendMessage(System.Object)">
            <summary>发送消息，不等待响应</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Process(NewLife.Data.IData)">
            <summary>处理消息数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="T:NewLife.Net.SocketRemoteHelper">
            <summary>远程通信Socket扩展</summary>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Send(NewLife.Net.ISocketRemote,System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="session">会话</param>
            <param name="stream">数据流</param>
            <returns>返回是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Send(NewLife.Net.ISocketRemote,System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="session">会话</param>
            <param name="msg">要发送的字符串</param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.ReceiveString(NewLife.Net.ISocketRemote,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="session">会话</param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Add``1(NewLife.Net.ISocket)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="session">会话</param>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Add(NewLife.Net.ISocket,NewLife.Model.IHandler)">
            <summary>添加处理器</summary>
            <param name="session">会话</param>
            <param name="handler">处理器</param>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.SendMessages(NewLife.Net.ISocketRemote,System.IO.Stream)">
            <summary>切分数据流为多个数据包消息进行发送，接收方按顺序组装</summary>
            <param name="session">会话</param>
            <param name="stream">数据流</param>
            <returns>拆分消息数</returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.SendFile(NewLife.Net.ISocketRemote,System.String,System.Boolean)">
            <summary>切分文件流为多个数据包发出，接收方按顺序组装</summary>
            <param name="session"></param>
            <param name="file"></param>
            <param name="compressed"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.ISocketServer">
            <summary>Socket服务器接口</summary>
        </member>
        <member name="P:NewLife.Net.ISocketServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.ISocketServer.SessionTimeout">
            <summary>会话超时时间。默认20*60秒</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="E:NewLife.Net.ISocketServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="T:NewLife.Net.ISocketSession">
            <summary>用于与对方进行通讯的Socket会话，仅具有收发功能，也专用于上层应用收发数据</summary>
            <remarks>
            Socket会话发送数据不需要指定远程地址，因为内部已经具有。
            接收数据时，Tcp接收全部数据，而Udp只接受来自所属远方的数据。
            
            Socket会话不具有连接和断开的能力，所以需要外部连接好之后再创建Socket会话。
            但是会话可以销毁，来代替断开。
            对于Udp额外创建的会话来说，仅仅销毁会话而已。
            
            所以，它必须具有收发数据的能力。
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketSession.Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="T:NewLife.Net.SessionEventArgs">
            <summary>会话事件参数</summary>
        </member>
        <member name="P:NewLife.Net.SessionEventArgs.Session">
            <summary>会话</summary>
        </member>
        <member name="M:NewLife.Net.SessionEventArgs.#ctor(NewLife.Net.ISocketSession)">
            <summary>实例化</summary>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Net.ITransport">
            <summary>帧数据传输接口</summary>
            <remarks>实现者确保数据以包的形式传输，屏蔽数据的粘包和拆包</remarks>
        </member>
        <member name="P:NewLife.Net.ITransport.Timeout">
            <summary>超时</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Open">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Close">
            <summary>关闭</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Send(NewLife.Data.Packet)">
            <summary>写入数据</summary>
            <param name="data">数据包</param>
        </member>
        <member name="M:NewLife.Net.ITransport.Receive">
            <summary>读取数据</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.ITransport.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="T:NewLife.Net.NetHandlerContext">
            <summary>网络处理器上下文</summary>
        </member>
        <member name="P:NewLife.Net.NetHandlerContext.Session">
            <summary>远程连接</summary>
        </member>
        <member name="P:NewLife.Net.NetHandlerContext.Data">
            <summary>数据帧</summary>
        </member>
        <member name="M:NewLife.Net.NetHandlerContext.FireRead(System.Object)">
            <summary>读取管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Net.NetHandlerContext.FireWrite(System.Object)">
            <summary>写入管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Net.NetServer">
            <summary>网络服务器。可同时支持多个Socket服务器，同时支持IPv4和IPv6，同时支持Tcp和Udp</summary>
            <remarks>
            网络服务器模型，所有网络应用服务器可以通过继承该类实现。
            该类仅实现了业务应用对网络流的操作，与具体网络协议无关。
            
            收到请求<see cref="M:NewLife.Net.NetServer.Server_NewSession(System.Object,NewLife.Net.SessionEventArgs)"/>后，会建立<see cref="M:NewLife.Net.NetServer.CreateSession(NewLife.Net.ISocketSession)"/>会话，并加入到会话集合<see cref="P:NewLife.Net.NetServer.Sessions"/>中，然后启动<see cref="M:NewLife.Net.NetServer.Start"/>会话处理；
            
            标准用法：
            指定端口后直接<see cref="M:NewLife.Net.NetServer.Start"/>，NetServer将同时监听Tcp/Udp和IPv4/IPv6（会检查是否支持）四个端口。
            
            高级用法：
            重载方法<see cref="M:NewLife.Net.NetServer.EnsureCreateServer"/>来创建一个SocketServer并赋值给<see cref="P:NewLife.Net.NetServer.Server"/>属性，<see cref="M:NewLife.Net.NetServer.EnsureCreateServer"/>将会在<see cref="M:NewLife.Net.NetServer.OnStart"/>时首先被调用。
            
            超级用法：
            使用<see cref="M:NewLife.Net.NetServer.AttachServer(NewLife.Net.ISocketServer)"/>方法向网络服务器添加Socket服务，其中第一个将作为默认Socket服务<see cref="P:NewLife.Net.NetServer.Server"/>。
            如果Socket服务集合<see cref="P:NewLife.Net.NetServer.Servers"/>为空，将依据地址<see cref="P:NewLife.Net.NetServer.Local"/>、端口<see cref="P:NewLife.Net.NetServer.Port"/>、地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>、协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>创建默认Socket服务。
            如果地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>指定为IPv4和IPv6以外的值，将同时创建IPv4和IPv6两个Socket服务；
            如果协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>指定为Tcp和Udp以外的值，将同时创建Tcp和Udp两个Socket服务；
            默认情况下，地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>和协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>都是其它值，所以一共将会创建四个Socket服务（Tcp、Tcpv6、Udp、Udpv6）。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Name">
            <summary>服务名</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Local">
            <summary>本地结点</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.ProtocolType">
            <summary>协议类型</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.AddressFamily">
            <summary>寻址方案</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Servers">
            <summary>服务器集合</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Server">
            <summary>服务器。返回服务器集合中的第一个服务器</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionTimeout">
            <summary>会话超时时间。默认0秒，使用SocketServer默认值</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.UseSession">
            <summary>使用会话集合，允许遍历会话。默认true</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.ReuseAddress">
            <summary>地址重用，主要应用于网络服务器重启交替。默认false</summary>
            <remarks>
            一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。
            SO_REUSEADDR用于对TCP套接字处于TIME_WAIT状态下的socket(TCP连接中, 先调用close() 的一方会进入TIME_WAIT状态)，才可以重复绑定使用。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.SslProtocol">
            <summary>SSL协议。默认None</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Certificate">
            <summary>X509证书。用于SSL连接时验证证书指纹，可以直接加载pem证书文件，未指定时不验证证书</summary>
            <remarks>
            可以使用pfx证书文件，也可以使用pem证书文件。
            服务端必须指定证书。
            </remarks>
            <example>
            var cert = new X509Certificate2("file", "pass");
            </example>
        </member>
        <member name="P:NewLife.Net.NetServer.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SocketTracer">
            <summary>用于内部Socket服务器的APM性能追踪器</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.StatPeriod">
            <summary>显示统计信息的周期。默认600秒，0表示不显示统计信息</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.ServiceProvider">
            <summary>服务提供者</summary>
            <remarks>
            用于网络服务器内部解析各种服务，可以直接赋值或者依赖注入。
            网络会话默认使用该提供者，应用系统可以在网络会话中创建Scope版服务提供者。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor">
            <summary>实例化一个网络服务器</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Int32)">
            <summary>通过指定监听地址和端口实例化一个网络服务器</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>通过指定监听地址和端口实例化一个网络服务器</summary>
            <param name="address"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Net.IPAddress,System.Int32,NewLife.Net.NetType)">
            <summary>通过指定监听地址和端口，还有协议，实例化一个网络服务器，默认支持Tcp协议和Udp协议</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocolType"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.Dispose(System.Boolean)">
            <summary>已重载。释放会话集合等资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.AttachServer(NewLife.Net.ISocketServer)">
            <summary>添加Socket服务器</summary>
            <param name="server"></param>
            <returns>添加是否成功</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.AddServer(System.Net.IPAddress,System.Int32,NewLife.Net.NetType,System.Net.Sockets.AddressFamily)">
            <summary>同时添加指定端口的IPv4和IPv6服务器，如果协议不是指定的Tcp或Udp，则同时添加Tcp和Udp服务器</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocol"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.EnsureCreateServer">
            <summary>确保建立服务器</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Add``1">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
        </member>
        <member name="M:NewLife.Net.NetServer.Add(NewLife.Model.IHandler)">
            <summary>添加处理器</summary>
            <param name="handler">处理器</param>
        </member>
        <member name="M:NewLife.Net.NetServer.Start">
            <summary>开始服务</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.OnStart">
            <summary>开始时调用的方法</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Stop(System.String)">
            <summary>停止服务</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnStop(System.String)">
            <summary>停止时调用的方法</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="E:NewLife.Net.NetServer.NewSession">
            <summary>新会话，对于TCP是新连接，对于UDP是新客户端</summary>
        </member>
        <member name="E:NewLife.Net.NetServer.Received">
            <summary>某个会话的数据到达。sender是INetSession</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Server_NewSession(System.Object,NewLife.Net.SessionEventArgs)">
            <summary>接受连接时，对于Udp是收到数据时（同时触发OnReceived）。</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnNewSession(NewLife.Net.ISocketSession)">
            <summary>收到连接时，建立会话，并挂接数据接收和错误处理事件</summary>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnReceived(System.Object,NewLife.Net.ReceivedEventArgs)">
            <summary>收到数据时</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>收到数据时，最原始的数据处理，但不影响会话内部的数据处理</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnReceive(NewLife.Net.INetSession,NewLife.Net.ReceivedEventArgs)">
            <summary>收到数据时，最原始的数据处理，但不影响会话内部的数据处理</summary>
            <param name="session"></param>
            <param name="e"></param>
        </member>
        <member name="E:NewLife.Net.NetServer.Error">
            <summary>错误发生/断开连接时。sender是ISocketSession</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary>触发异常</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:NewLife.Net.NetServer.Sessions">
            <summary>会话集合。用自增的数字ID作为标识，业务应用自己维持ID与业务主键的对应关系。</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionCount">
            <summary>会话数</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.MaxSessionCount">
            <summary>最高会话数</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.AddSession(NewLife.Net.INetSession)">
            <summary>添加会话。子类可以在添加会话前对会话进行一些处理</summary>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.GetSession(System.Int32)">
            <summary>根据会话ID查找会话</summary>
            <param name="sessionid"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.CreateHandler(NewLife.Net.INetSession)">
            <summary>为会话创建网络数据处理器。可作为业务处理实现，也可以作为前置协议解析</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.SendAllAsync(NewLife.Data.Packet)">
            <summary>异步群发数据给所有客户端</summary>
            <param name="data"></param>
            <returns>已群发客户端总数</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.SendAllAsync(NewLife.Data.Packet,System.Func{NewLife.Net.INetSession,System.Boolean})">
            <summary>异步群发数据给所有客户端</summary>
            <param name="data"></param>
            <param name="predicate">过滤器，判断指定会话是否需要发送</param>
            <returns>已群发客户端总数</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.SendAllMessage(System.Object,System.Func{NewLife.Net.INetSession,System.Boolean})">
            <summary>群发管道消息给所有客户端。不等待，支持协议编码</summary>
            <param name="message">应用消息，底层对其进行协议编码</param>
            <param name="predicate">过滤器，判断指定会话是否需要发送</param>
            <returns>已群发客户端总数</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.CreateServer(System.Net.IPAddress,System.Int32,NewLife.Net.NetType,System.Net.Sockets.AddressFamily)">
            <summary>创建Tcp/Udp、IPv4/IPv6服务</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocol"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.GetStat">
            <summary>获取统计信息</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.NetServer.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SocketLog">
            <summary>用于内部Socket服务器的日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionLog">
            <summary>用于网络会话的日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.WriteError(System.String,System.Object[])">
            <summary>输出错误日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetServer`1">
            <summary>网络服务器</summary>
            <typeparam name="TSession"></typeparam>
        </member>
        <member name="M:NewLife.Net.NetServer`1.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer`1.GetSession(System.Int32)">
            <summary>获取指定标识的会话</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetSession`1">
            <summary>网络服务的会话，每个Tcp/Udp连接作为一个会话</summary>
            <typeparam name="TServer">网络服务类型</typeparam>
            <remarks>
            每当收到一个Tcp连接时，创建一个INetSession会话，用于处理该连接的业务。
            使用Udp服务端时，收到远程节点的第一个数据包时，也会创建一个会话，处理该节点的业务。
            
            所有应用服务器以会话<see cref="T:NewLife.Net.INetSession"/>作为业务处理核心。
            应用服务器收到新会话请求后，通过Start启动一个会话处理。
            会话进行业务处理的过程中，可以通过多个Send方法向客户端发送数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetSession`1.Host">
            <summary>主服务</summary>
        </member>
        <member name="T:NewLife.Net.NetSession">
            <summary>网络服务的会话，每个Tcp/Udp连接作为一个会话</summary>
            <remarks>
            每当收到一个Tcp连接时，创建一个INetSession会话，用于处理该连接的业务。
            使用Udp服务端时，收到远程节点的第一个数据包时，也会创建一个会话，处理该节点的业务。
            
            所有应用服务器以会话<see cref="T:NewLife.Net.INetSession"/>作为业务处理核心。
            应用服务器收到新会话请求后，通过<see cref="M:NewLife.Net.NetSession.Start"/>启动一个会话处理。
            会话进行业务处理的过程中，可以通过多个Send方法向客户端发送数据。
            
            实际应用可通过重载OnReceive实现收到数据时的业务逻辑。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetSession.ID">
            <summary>唯一会话标识。在主服务中唯一标识当前会话，原子自增</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.NewLife#Net#INetSession#Host">
            <summary>主服务。负责管理当前会话的主服务器NetServer</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Session">
            <summary>客户端。跟客户端通讯的那个Socket，其实是服务端TcpSession/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Remote">
            <summary>客户端地址</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Handler">
            <summary>网络数据处理器。可作为业务处理实现，也可以作为前置协议解析</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Items">
            <summary>用户会话数据</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.NetSession.ServiceProvider">
            <summary>服务提供者</summary>
            <remarks>
            根据会话创建Scoped范围服务，以使得各服务解析在本会话中唯一。
            基类使用内置ObjectContainer的Scope，在WebApi/Worker项目中，使用者需要自己创建Scope并赋值服务提供者。
            </remarks>
        </member>
        <member name="E:NewLife.Net.NetSession.Connected">
            <summary>连接创建事件。创建会话之后</summary>
        </member>
        <member name="E:NewLife.Net.NetSession.Disconnected">
            <summary>连接断开事件。包括客户端主动断开、服务端主动断开以及服务端超时下线</summary>
        </member>
        <member name="E:NewLife.Net.NetSession.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.Start">
            <summary>开始会话处理。</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.Dispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.Net.NetSession.Close(System.String)">
            <summary>关闭跟客户端的网络连接</summary>
            <param name="reason">断开原因。包括 SendError/RemoveNotAlive/Dispose/GC 等，其中 ConnectionReset 为网络被动断开或对方断开</param>
        </member>
        <member name="M:NewLife.Net.NetSession.OnConnected">
            <summary>新的客户端连接。基类负责触发Connected事件</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.OnDisconnected(System.String)">
            <summary>客户端连接已断开。基类负责触发Disconnected事件</summary>
            <param name="reason">断开原因。包括 SendError/RemoveNotAlive/Dispose/GC 等，其中 ConnectionReset 为网络被动断开或对方断开</param>
        </member>
        <member name="M:NewLife.Net.NetSession.OnDisconnected">
            <summary>客户端连接已断开</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据。基类负责触发Received事件</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary>错误发生，可能是连接断开</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(NewLife.Data.Packet)">
            <summary>发送数据，直达网卡</summary>
            <param name="data">数据包</param>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(System.IO.Stream)">
            <summary>发送数据流，直达网卡</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(System.String,System.Text.Encoding)">
            <summary>发送字符串，直达网卡</summary>
            <param name="msg"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.SendMessage(System.Object)">
            <summary>通过管道发送消息，不等待响应。管道内对消息进行报文封装处理，最终得到二进制数据进入网卡</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.SendMessageAsync(System.Object)">
            <summary>异步发送消息并等待响应。管道内对消息进行报文封装处理，最终得到二进制数据进入网卡</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.SendMessageAsync(System.Object,System.Threading.CancellationToken)">
            <summary>异步发送消息并等待响应。管道内对消息进行报文封装处理，最终得到二进制数据进入网卡</summary>
            <param name="message">消息</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.NetSession.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.WriteError(System.String,System.Object[])">
            <summary>输出错误日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.GetService(System.Type)">
            <summary>获取服务</summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetType">
            <summary>协议类型</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Unknown">
            <summary>未知协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Tcp">
            <summary>传输控制协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Udp">
            <summary>用户数据报协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Http">
            <summary>Http协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Https">
            <summary>Https协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.WebSocket">
            <summary>WebSocket协议</summary>
        </member>
        <member name="T:NewLife.Net.NetUri">
            <summary>网络资源标识，指定协议、地址、端口、地址族（IPv4/IPv6）</summary>
            <remarks>
            仅序列化<see cref="P:NewLife.Net.NetUri.Type"/>和<see cref="P:NewLife.Net.NetUri.EndPoint"/>，其它均是配角！
            有可能<see cref="P:NewLife.Net.NetUri.Host"/>代表主机域名，而<see cref="P:NewLife.Net.NetUri.Address"/>指定主机IP地址。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetUri.Type">
            <summary>协议类型</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.Host">
            <summary>主机或域名</summary>
            <remarks>可能对应多个IP地址</remarks>
        </member>
        <member name="P:NewLife.Net.NetUri.Address">
            <summary>地址</summary>
            <remarks>
            域名多地址时的第一个。
            设置地址后，反向覆盖Host。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetUri.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.EndPoint">
            <summary>终结点</summary>
            <remarks>
            域名多地址时的第一个。
            设置地址后，反向覆盖Host。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetUri.IsTcp">
            <summary>是否Tcp协议</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.IsUdp">
            <summary>是否Udp协议</summary>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.Net.IPEndPoint)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="endpoint"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.Net.IPAddress,System.Int32)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="address"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.String,System.Int32)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="host"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.Parse(System.String)">
            <summary>分析</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.GetAddresses">
            <summary>获取该域名下所有IP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.GetEndPoints">
            <summary>获取该域名下所有IP节点（含端口）</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.ParseAddress(System.String)">
            <summary>分析地址</summary>
            <param name="hostname">主机地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.op_Implicit(System.String)~NewLife.Net.NetUri">
            <summary>重载类型转换，字符串直接转为NetUri对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.ReceivedEventArgs">
            <summary>收到数据时的事件参数</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Packet">
            <summary>原始数据包</summary>
            <remarks>
            Packet内部的Data可能是网络缓冲区，并非全部数据都属于当前消息，需要ReadBytes得到有效数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Local">
            <summary>本地地址</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Message">
            <summary>管道处理器解码后的消息，一般就是业务消息</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.UserState">
            <summary>用户自定义数据</summary>
        </member>
        <member name="M:NewLife.Net.ReceivedEventArgs.GetBytes">
            <summary>获取当前事件的原始数据。避免用户错误使用Packet.Data</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.SessionBase">
            <summary>会话基类</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.ID">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Local">
            <summary>本地绑定信息</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Remote">
            <summary>远程结点地址</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LastTime">
            <summary>最后一次通信时间，主要表示活跃时间，包括收发</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.MaxAsync">
            <summary>最大并行接收数。Tcp默认1，Udp默认CPU*1.6，0关闭异步接收使用同步接收</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.BufferSize">
            <summary>缓冲区大小。默认8k</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.CloseReason">
            <summary>连接关闭原因</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.#ctor">
            <summary>构造函数，初始化默认名称</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Open">
            <summary>打开</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnOpen">
            <summary>打开</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnClose(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.CheckClosed">
            <summary>检查连接是否已关闭，并返回关闭原因，主要检测FIN/RST</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.SessionBase.Opened">
            <summary>打开后触发。</summary>
        </member>
        <member name="E:NewLife.Net.SessionBase.Closed">
            <summary>关闭后触发。可实现掉线重连</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.Send(NewLife.Data.Packet)">
            <summary>直接发送数据包 Byte[]/Packet</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="data">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="data">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Receive">
            <summary>接收数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>异步接收数据</summary>
            <returns></returns>
        </member>
        <member name="F:NewLife.Net.SessionBase._RecvCount">
            <summary>当前异步接收个数</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReceiveAsync">
            <summary>开始异步接收。在事件中返回数据</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReleaseRecv(System.Net.Sockets.SocketAsyncEventArgs,System.String)">
            <summary>释放一个事件参数</summary>
            <param name="se"></param>
            <param name="reason"></param>
        </member>
        <member name="F:NewLife.Net.SessionBase._IntoThreadCount">
            <summary>当前进入线程递归数量，超过10就另外起线程</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.StartReceive(System.Net.Sockets.SocketAsyncEventArgs,System.Int32)">
            <summary>用一个事件参数来开始异步接收</summary>
            <param name="se">事件参数</param>
            <param name="ioThread">是否在线程池调用,小于等于0不是，大于0是</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.ProcessEvent(System.Net.Sockets.SocketAsyncEventArgs,System.Int32,System.Int32)">
            <summary>同步或异步收到数据</summary>
            <remarks>
            ioThread:
            如果在StartReceive的时候线程池调用ProcessEvent，则处于worker线程；
            如果在IOCP的时候调用ProcessEvent，则处于completionPort线程。
            </remarks>
            <param name="se"></param>
            <param name="bytes"></param>
            <param name="ioThread">是否在IO线程池里面</param>
        </member>
        <member name="M:NewLife.Net.SessionBase.ProcessReceive(NewLife.Data.Packet,System.Net.IPAddress,System.Net.IPEndPoint)">
            <summary>接收预处理，粘包拆包</summary>
            <param name="pk">数据包</param>
            <param name="local">接收数据的本地地址</param>
            <param name="remote">远程地址</param>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnPreReceive(NewLife.Data.Packet,System.Net.IPAddress,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="local">接收数据的本地地址</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据。默认匹配同步接收委托</summary>
            <param name="e">接收事件参数</param>
            <returns>是否已处理，已处理的数据不再向下传递</returns>
        </member>
        <member name="E:NewLife.Net.SessionBase.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.RaiseReceive(System.Object,NewLife.Net.ReceivedEventArgs)">
            <summary>触发数据到达事件</summary>
            <param name="sender"></param>
            <param name="e">接收事件参数</param>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnReceiveError(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>收到异常时如何处理。默认关闭会话</summary>
            <param name="se"></param>
            <returns>是否当作异常处理并结束会话</returns>
        </member>
        <member name="P:NewLife.Net.SessionBase.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="M:NewLife.Net.SessionBase.CreateContext(NewLife.Net.ISocketRemote)">
            <summary>创建上下文</summary>
            <param name="session">远程会话</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.SendMessage(System.Object)">
            <summary>通过管道发送消息，不等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.SendMessageAsync(System.Object)">
            <summary>通过管道发送消息并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.SendMessageAsync(System.Object,System.Threading.CancellationToken)">
            <summary>通过管道发送消息并等待响应</summary>
            <param name="message">消息</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.NewLife#Net#ISocketRemote#Process(NewLife.Data.IData)">
            <summary>处理数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="E:NewLife.Net.SessionBase.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="P:NewLife.Net.SessionBase.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Log">
            <summary>日志对象。禁止设为空对象</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogDataLength">
            <summary>收发日志数据体长度。默认64</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.SessionCollection">
            <summary>会话集合。带有自动清理不活动会话的功能</summary>
        </member>
        <member name="P:NewLife.Net.SessionCollection.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Net.SessionCollection.ClearPeriod">
            <summary>清理周期。单位毫秒，默认10秒。</summary>
        </member>
        <member name="F:NewLife.Net.SessionCollection._clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Net.SessionCollection.Add(NewLife.Net.ISocketSession)">
            <summary>添加新会话，并设置会话编号</summary>
            <param name="session"></param>
            <returns>返回添加新会话是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionCollection.Get(System.String)">
            <summary>获取会话，加锁</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionCollection.CloseAll(System.String)">
            <summary>关闭所有</summary>
        </member>
        <member name="M:NewLife.Net.SessionCollection.RemoveNotAlive(System.Object)">
            <summary>移除不活动的会话</summary>
        </member>
        <member name="T:NewLife.Net.Setting">
            <summary>网络设置</summary>
        </member>
        <member name="T:NewLife.Net.SocketSetting">
            <summary>网络设置</summary>
        </member>
        <member name="P:NewLife.Net.SocketSetting.Debug">
            <summary>网络调试</summary>
        </member>
        <member name="P:NewLife.Net.SocketSetting.SessionTimeout">
            <summary>会话超时时间。每个Tcp/Udp连接会话，超过一定时间不活跃时做超时下线处理，默认20*60秒</summary>
        </member>
        <member name="P:NewLife.Net.SocketSetting.BufferSize">
            <summary>缓冲区大小。每个IOCP异步接收缓冲区的大小，较大的值能减少小包合并，但是当连接数很多时会浪费大量内存，默认8k</summary>
        </member>
        <member name="P:NewLife.Net.SocketSetting.LogDataLength">
            <summary>收发日志数据体长度。应用于LogSend/LogReceive时的数据HEX长度，默认64字节</summary>
        </member>
        <member name="P:NewLife.Net.SocketSetting.AutoGZip">
            <summary>自动启用GZip压缩的请求体大小。应用于HttpHelper/ApiHttpClient发起的请求，默认1024，用0表示不压缩</summary>
        </member>
        <member name="T:NewLife.Net.SocketHelper">
            <summary>Socket扩展</summary>
        </member>
        <member name="M:NewLife.Net.SocketHelper.SendAsync(System.Net.Sockets.Socket,System.Byte[])">
            <summary>异步发送数据</summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.SendToAsync(System.Net.Sockets.Socket,System.Byte[],System.Net.IPEndPoint)">
            <summary>异步发送数据</summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.IO.Stream,System.Net.IPEndPoint)">
            <summary>发送数据流</summary>
            <param name="socket"></param>
            <param name="stream"></param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.Byte[],System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="socket"></param>
            <param name="buffer">缓冲区</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.String,System.Text.Encoding,System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="socket"></param>
            <param name="message"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Broadcast(System.Net.Sockets.Socket,System.Byte[],System.Int32)">
            <summary>广播数据包</summary>
            <param name="socket"></param>
            <param name="buffer">缓冲区</param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Broadcast(System.Net.Sockets.Socket,System.String,System.Int32)">
            <summary>广播字符串</summary>
            <param name="socket"></param>
            <param name="message"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.SocketHelper.ReceiveString(System.Net.Sockets.Socket,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="socket"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.CheckBroadcast(System.Net.Sockets.Socket,System.Net.IPAddress)">
            <summary>检查并开启广播</summary>
            <param name="socket"></param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Shutdown(System.Net.Sockets.Socket,System.Boolean)">
            <summary>关闭连接</summary>
            <param name="socket"></param>
            <param name="reuseAddress"></param>
        </member>
        <member name="P:NewLife.Net.SocketHelper.mSafeHandle">
            <summary>SafeHandle字段</summary>
        </member>
        <member name="M:NewLife.Net.SocketHelper.IsNotClosed(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>Socket是否未被关闭</summary>
            <param name="se"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.GetException(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>根据异步事件获取可输出异常，屏蔽常见异常</summary>
            <param name="se"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.TcpConnectionInformation2">
            <summary>Tcp连接信息</summary>
        </member>
        <member name="P:NewLife.Net.TcpConnectionInformation2.LocalEndPoint">
            <summary>本地结点</summary>
        </member>
        <member name="P:NewLife.Net.TcpConnectionInformation2.RemoteEndPoint">
            <summary>远程结点</summary>
        </member>
        <member name="P:NewLife.Net.TcpConnectionInformation2.State">
            <summary>Tcp状态</summary>
        </member>
        <member name="P:NewLife.Net.TcpConnectionInformation2.ProcessId">
            <summary>进程标识</summary>
        </member>
        <member name="P:NewLife.Net.TcpConnectionInformation2.Node">
            <summary>inode标识</summary>
        </member>
        <member name="M:NewLife.Net.TcpConnectionInformation2.#ctor(System.Net.IPEndPoint,System.Net.IPEndPoint,System.Net.NetworkInformation.TcpState,System.Int32)">
            <summary>实例化Tcp连接信息</summary>
            <param name="local"></param>
            <param name="remote"></param>
            <param name="state"></param>
            <param name="processId"></param>
        </member>
        <member name="M:NewLife.Net.TcpConnectionInformation2.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.TcpConnectionInformation2.GetAllTcpConnections">
            <summary>获取所有Tcp连接</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.TcpConnectionInformation2.GetWindowsTcpConnections">
            <summary>获取所有Tcp连接</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.TcpConnectionInformation2.GetLinuxTcpConnections(System.Int32)">
            <summary>获取指定进程的Tcp连接</summary>
            <param name="processId">目标进程。默认-1未指定，获取所有进程的Tcp连接</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.TcpConnectionInformation2.ParseTcps(System.String)">
            <summary>分析Tcp连接信息</summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.TcpConnectionInformation2.ParseNodes(System.Collections.Generic.IList{System.String})">
            <summary>分析Socket的inode</summary>
            <param name="files"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.TcpServer">
            <summary>TCP服务器</summary>
            <remarks>
            核心工作：启动服务<see cref="M:NewLife.Net.TcpServer.Start"/>时，监听端口，并启用多个（逻辑处理器数的10倍）异步接受操作<see cref="M:NewLife.Net.TcpServer.StartAccept(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)"/>。
            
            服务器完全处于异步工作状态，任何操作都不可能被阻塞。
            
            注意：服务器接受连接请求后，不会开始处理数据，而是由<see cref="E:NewLife.Net.TcpServer.NewSession"/>事件订阅者决定何时开始处理数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Local">
            <summary>本地绑定信息</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.SessionTimeout">
            <summary>会话超时时间</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.MaxAsync">
            <summary>最大并行接收连接数。默认CPU*1.6</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.NoDelay">
            <summary>不延迟直接发送。Tcp为了合并小包而设计，客户端默认false，服务端默认true</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.ReuseAddress">
            <summary>地址重用，主要应用于网络服务器重启交替。默认false</summary>
            <remarks>
            一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。
            SO_REUSEADDR用于对TCP套接字处于TIME_WAIT状态下的socket(TCP连接中, 先调用close() 的一方会进入TIME_WAIT状态)，才可以重复绑定使用。
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.KeepAliveInterval">
            <summary>KeepAlive间隔。默认0秒不启用</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.EnableHttp">
            <summary>启用Http，数据处理时截去请求响应头，默认false</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.SslProtocol">
            <summary>SSL协议。默认None</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Certificate">
            <summary>X509证书。用于SSL连接时验证证书指纹，可以直接加载pem证书文件，未指定时不验证证书</summary>
            <remarks>
            可以使用pfx证书文件，也可以使用pem证书文件。
            服务端必须指定证书。
            </remarks>
            <example>
            var cert = new X509Certificate2("file", "pass");
            </example>
        </member>
        <member name="P:NewLife.Net.TcpServer.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.#ctor">
            <summary>构造TCP服务器对象</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.#ctor(System.Int32)">
            <summary>构造TCP服务器对象</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.Dispose(System.Boolean)">
            <summary>已重载。释放会话集合等资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="E:NewLife.Net.TcpServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.StartAccept(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)">
            <summary>开启异步接受新连接</summary>
            <param name="se"></param>
            <param name="io">是否IO线程</param>
            <returns>开启异步是否成功</returns>
        </member>
        <member name="M:NewLife.Net.TcpServer.OnAccept(System.Net.Sockets.Socket)">
            <summary>收到新连接时处理</summary>
            <param name="client"></param>
        </member>
        <member name="P:NewLife.Net.TcpServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.CreateSession(System.Net.Sockets.Socket)">
            <summary>创建会话</summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.TcpServer.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Log">
            <summary>日志对象</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.TcpSession">
            <summary>增强TCP客户端</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.RemoteAddress">
            <summary>实际使用的远程地址。Remote配置域名时，可能有多个IP地址</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.NewLife#Net#ISocketSession#Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer。该属性决定本会话是客户端会话还是服务的会话</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.NoDelay">
            <summary>不延迟直接发送。Tcp为了合并小包而设计，客户端默认false，服务端默认true</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.KeepAliveInterval">
            <summary>KeepAlive间隔。默认0秒不启用</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.SslProtocol">
            <summary>SSL协议。默认None，服务端Default，客户端不启用</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.Certificate">
            <summary>X509证书。用于SSL连接时验证证书指纹，可以直接加载pem证书文件，未指定时不验证证书</summary>
            <remarks>
            可以使用pfx证书文件，也可以使用pem证书文件。
            服务端必须指定证书，客户端可以不指定，除非服务端请求客户端证书。
            </remarks>
            <example>
            var cert = new X509Certificate2("file", "pass");
            </example>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor">
            <summary>实例化增强TCP</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor(System.Int32)">
            <summary>使用监听口初始化</summary>
            <param name="listenPort"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor(System.Net.Sockets.Socket)">
            <summary>用TCP客户端初始化</summary>
            <param name="client"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnOpen">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnClose(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.TcpSession.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>异步接收数据。重载以支持SSL</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnEndRead(System.IAsyncResult)">
            <summary>异步读取数据流，仅用于SSL</summary>
            <param name="ar"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnPreReceive(NewLife.Data.Packet,System.Net.IPAddress,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="local">接收数据的本地地址</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据</summary>
            <param name="e">接收事件参数</param>
        </member>
        <member name="P:NewLife.Net.TcpSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpServer">
            <summary>增强的UDP</summary>
            <remarks>
            如果已经打开异步接收，还要使用同步接收，则同步Receive内部不再调用底层Socket，而是等待截走异步数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpServer.SessionTimeout">
            <summary>会话超时时间</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpServer.Loopback">
            <summary>是否接收来自自己广播的环回数据。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpServer.ReuseAddress">
            <summary>地址重用，主要应用于网络服务器重启交替。默认false</summary>
            <remarks>
            一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。
            SO_REUSEADDR用于对TCP套接字处于TIME_WAIT状态下的socket(TCP连接中, 先调用close() 的一方会进入TIME_WAIT状态)，才可以重复绑定使用。
            </remarks>
        </member>
        <member name="M:NewLife.Net.UdpServer.#ctor">
            <summary>实例化增强UDP</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.#ctor(System.Int32)">
            <summary>使用监听口初始化</summary>
            <param name="listenPort"></param>
        </member>
        <member name="M:NewLife.Net.UdpServer.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnOpen">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnClose(System.String)">
            <summary>关闭</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.SendMessageAsync(System.Object)">
            <summary>发送消息并等待响应。必须调用会话的发送，否则配对会失败</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.SendMessageAsync(System.Object,System.Threading.CancellationToken)">
            <summary>发送消息并等待响应。必须调用会话的发送，否则配对会失败</summary>
            <param name="message">消息</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnPreReceive(NewLife.Data.Packet,System.Net.IPAddress,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="local">接收数据的本地地址</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据</summary>
            <param name="e">接收事件参数</param>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnReceiveError(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>收到异常时如何处理。Tcp/Udp客户端默认关闭会话，但是Udp服务端不能关闭服务器，仅关闭会话</summary>
            <param name="se"></param>
            <returns>是否当作异常处理并结束会话</returns>
        </member>
        <member name="E:NewLife.Net.UdpServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="P:NewLife.Net.UdpServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.CreateSession(System.Net.IPAddress,System.Net.IPEndPoint)">
            <summary>创建会话</summary>
            <param name="local">接收数据的本地地址</param>
            <param name="remoteEP">远程地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpHelper">
            <summary>Udp扩展</summary>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.IO.Stream,System.Net.IPEndPoint)">
            <summary>发送数据流</summary>
            <param name="udp"></param>
            <param name="stream"></param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.Byte[],System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="udp"></param>
            <param name="buffer">缓冲区</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.String,System.Text.Encoding,System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="udp"></param>
            <param name="message"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Broadcast(System.Net.Sockets.UdpClient,System.Byte[],System.Int32)">
            <summary>广播数据包</summary>
            <param name="udp"></param>
            <param name="buffer">缓冲区</param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Broadcast(System.Net.Sockets.UdpClient,System.String,System.Int32)">
            <summary>广播字符串</summary>
            <param name="udp"></param>
            <param name="message"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.UdpHelper.ReceiveString(System.Net.Sockets.UdpClient,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="udp"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpSession">
            <summary>Udp会话。仅用于服务端与某一固定远程地址通信</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.ID">
            <summary>会话编号</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Server">
            <summary>服务器</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.NewLife#Net#ISocket#Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Local">
            <summary>本地地址</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpSession.NewLife#Net#ISocketSession#Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LastTime">
            <summary>最后一次通信时间，主要表示活跃时间，包括收发</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.#ctor(NewLife.Net.UdpServer,System.Net.IPAddress,System.Net.IPEndPoint)">
            <summary>实例化Udp会话</summary>
            <param name="server"></param>
            <param name="local">接收数据的本地地址</param>
            <param name="remote"></param>
        </member>
        <member name="M:NewLife.Net.UdpSession.Start">
            <summary>开始数据交换</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.UdpSession.Send(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:NewLife.Net.UdpSession.SendMessage(System.Object)">
            <summary>发送消息，不等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.SendMessageAsync(System.Object)">
            <summary>发送消息并等待响应</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.SendMessageAsync(System.Object,System.Threading.CancellationToken)">
            <summary>发送消息并等待响应</summary>
            <param name="message">消息</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.Receive">
            <summary>接收数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>异步接收数据</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.UdpSession.Received">
            <summary>数据接收事件</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.NewLife#Net#ISocketRemote#Process(NewLife.Data.IData)">
            <summary>处理数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="E:NewLife.Net.UdpSession.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:NewLife.Net.UdpSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.UdpSession.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.UdpSession.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Upgrade">
            <summary>升级更新</summary>
            <remarks>
            优先比较版本Version，再比较时间Time。
            自动更新的难点在于覆盖正在使用的exe/dll文件，通过改名可以解决。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Upgrade.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Server">
            <summary>服务器地址</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Time">
            <summary>本地编译时间</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.UpdatePath">
            <summary>更新目录</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.DestinationPath">
            <summary>目标目录</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Link">
            <summary>超链接信息</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.CacheFile">
            <summary>缓存文件。同名文件不再下载，默认false</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.SourceFile">
            <summary>更新源文件</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.#ctor">
            <summary>实例化一个升级对象实例，获取当前应用信息</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Check">
            <summary>获取版本信息，检查是否需要更新</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Upgrade.Download">
            <summary>开始更新</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Download(System.String,System.String)">
            <summary>开始更新</summary>
            <param name="url">下载源</param>
            <param name="fileName">文件名</param>
        </member>
        <member name="M:NewLife.Net.Upgrade.DownloadAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>开始更新</summary>
            <param name="url">下载源</param>
            <param name="fileName">文件名</param>
            <param name="cancellationToken">取消通知</param>
        </member>
        <member name="M:NewLife.Net.Upgrade.Update">
            <summary>检查并执行更新操作</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Run">
            <summary>启动当前应用的新进程。当前进程退出</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.DeleteBuckup(System.String)">
            <summary>删除备份文件</summary>
            <param name="dest">目标目录</param>
        </member>
        <member name="M:NewLife.Net.Upgrade.DeleteBackup(System.String)">
            <summary>删除备份文件</summary>
            <param name="dest">目标目录</param>
        </member>
        <member name="M:NewLife.Net.Upgrade.Extract(System.String)">
            <summary>
            解压缩
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Net.Upgrade.CopyAndReplace(System.String,System.String)">
            <summary>拷贝并替换。正在使用锁定的文件不可删除，但可以改名</summary>
            <param name="source">源目录</param>
            <param name="dest">目标目录</param>
        </member>
        <member name="P:NewLife.Net.Upgrade.Log">
            <summary>日志对象</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.WebSocketClient">
            <summary>WebSocket客户端</summary>
        </member>
        <member name="P:NewLife.Net.WebSocketClient.Uri">
            <summary>资源地址</summary>
        </member>
        <member name="P:NewLife.Net.WebSocketClient.KeepAlive">
            <summary>WebSocket心跳间隔。默认60秒</summary>
        </member>
        <member name="P:NewLife.Net.WebSocketClient.RequestHeaders">
            <summary>请求头。ws握手时可以传递Token</summary>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.#ctor(System.Uri)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.OnOpen">
            <summary>打开连接，建立WebSocket请求</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.OnClose(System.String)">
            <summary>关闭连接</summary>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.SetRequestHeader(System.String,System.String)">
            <summary>设置请求头。ws握手时可以传递Token</summary>
            <param name="headerName"></param>
            <param name="headerValue"></param>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.ReceiveMessageAsync(System.Threading.CancellationToken)">
            <summary>接收WebSocket消息</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.SendMessageAsync(NewLife.Http.WebSocketMessage,System.Threading.CancellationToken)">
            <summary>发送消息</summary>
            <param name="message"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.SendTextAsync(NewLife.Data.Packet,System.Threading.CancellationToken)">
            <summary>发送文本</summary>
            <param name="data"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.SendTextAsync(System.String,System.Threading.CancellationToken)">
            <summary>发送文本</summary>
            <param name="text"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.SendBinaryAsync(NewLife.Data.Packet,System.Threading.CancellationToken)">
            <summary>发送二进制数据</summary>
            <param name="data"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.CloseAsync(System.Int32,System.String,System.Threading.CancellationToken)">
            <summary>发送关闭</summary>
            <param name="closeStatus"></param>
            <param name="statusDescription"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.WebSocketClient.Handshake(NewLife.Net.ISocketClient,System.Uri)">
            <summary>握手</summary>
            <param name="client"></param>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.NetHelper">
            <summary>网络工具类</summary>
        </member>
        <member name="M:NewLife.NetHelper.SetTcpKeepAlive(System.Net.Sockets.Socket,System.Boolean,System.Int32,System.Int32)">
            <summary>设置超时检测时间和检测间隔</summary>
            <remarks>
            一次对server服务大量积压异常TCP ESTABLISHED链接的排查笔记 https://www.jianshu.com/p/a1c3aba4af96
            查看连接创建时间： sudo ls /proc/128260/fd -l|grep socket ，可发现大量连接的创建时间在很久之前。
            查看连接是否有启用keepalive： ss -aoen|grep ESTAB|grep timer ，带有timer的socket表示启用了keepalive。
            </remarks>
            <param name="socket">要设置的Socket对象</param>
            <param name="isKeepAlive">是否启用Keep-Alive</param>
            <param name="startTime">多长时间后开始第一次探测（单位：秒）</param>
            <param name="interval">探测时间间隔（单位：秒）</param>
        </member>
        <member name="M:NewLife.NetHelper.ParseAddress(System.String)">
            <summary>分析地址，根据IP或者域名得到IP地址，缓存60秒，异步更新</summary>
            <param name="hostname"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.ParseEndPoint(System.String,System.Int32)">
            <summary>分析网络终结点</summary>
            <param name="address">地址，可以不带端口</param>
            <param name="defaultPort">地址不带端口时指定的默认端口</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetRightAny(System.Net.IPAddress,System.Net.Sockets.AddressFamily)">
            <summary>针对IPv4和IPv6获取合适的Any地址</summary>
            <remarks>除了Any地址以为，其它地址不具备等效性</remarks>
            <param name="address"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsAny(System.Net.IPAddress)">
            <summary>是否Any地址，同时处理IPv4和IPv6</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsAny(System.Net.EndPoint)">
            <summary>是否Any结点</summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsIPv4(System.Net.IPAddress)">
            <summary>是否IPv4地址</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsLocal(System.Net.IPAddress)">
            <summary>是否本地地址</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetRelativeAddress(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>获取相对于指定远程地址的本地地址</summary>
            <param name="address"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetRelativeEndPoint(System.Net.IPEndPoint,System.Net.IPAddress)">
            <summary>获取相对于指定远程地址的本地地址</summary>
            <param name="local"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CheckPort(System.Net.IPAddress,NewLife.Net.NetType,System.Int32)">
            <summary>指定地址的指定端口是否已被使用，似乎没办法判断IPv6地址</summary>
            <param name="protocol"></param>
            <param name="address"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CheckPort(NewLife.Net.NetUri)">
            <summary>检查该协议的地址端口是否已经被使用</summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetAllTcpConnections">
            <summary>获取所有Tcp连接，带进程Id</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetAllTcpConnections(System.Int32)">
            <summary>获取所有Tcp连接，带进程Id</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetActiveInterfaces">
            <summary>获取活动的接口信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetDhcps">
            <summary>获取可用的DHCP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetDns">
            <summary>获取可用的DNS地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetGateways">
            <summary>获取可用的网关地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetIPs">
            <summary>获取可用的IP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetIPsWithCache">
            <summary>获取本机可用IP地址，缓存60秒，异步更新</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetMulticasts">
            <summary>获取可用的多播地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetMacs">
            <summary>获取所有物理网卡MAC地址。包括未启用网卡，剔除本地和隧道</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetMac">
            <summary>获取网卡MAC地址（网关所在网卡）</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.MyIP">
            <summary>获取本地第一个IPv4地址。一般是网关所在网卡的IP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.MyIPv6">
            <summary>获取本地第一个IPv6地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.Wake(System.String[])">
            <summary>唤醒指定MAC地址的计算机</summary>
            <param name="macs"></param>
        </member>
        <member name="M:NewLife.NetHelper.GetMac(System.Net.IPAddress)">
            <summary>根据IP地址获取MAC地址</summary>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.NetHelper.IpResolver">
            <summary>IP地址提供者</summary>
        </member>
        <member name="M:NewLife.NetHelper.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址的物理地址位置</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IPToAddress(System.String)">
            <summary>根据字符串形式IP地址转为物理地址</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CreateClient(NewLife.Net.NetUri)">
            <summary>根据本地网络标识创建客户端</summary>
            <param name="local"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CreateRemote(NewLife.Net.NetUri)">
            <summary>根据远程网络标识创建客户端</summary>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CreateRemote(System.Uri)">
            <summary>根据Uri创建客户端，主要支持Http/WebSocket</summary>
            <param name="uri"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:NewLife.Reflection.AssemblyX">
            <summary>程序集辅助类。使用Create创建，保证每个程序集只有一个辅助类</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Asm">
            <summary>程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Version">
            <summary>程序集版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Title">
            <summary>程序集标题</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.FileVersion">
            <summary>文件版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Compile">
            <summary>编译时间</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Company">
            <summary>公司名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Description">
            <summary>说明</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Location">
            <summary>获取包含清单的已加载文件的路径或 UNC 位置。</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.Create(System.Reflection.Assembly)">
            <summary>创建程序集辅助对象</summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Types">
            <summary>类型集合，当前程序集的所有类型，包括私有和内嵌，非内嵌请直接调用Asm.GetTypes()</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.IsSystemAssembly">
            <summary>是否系统程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Entry">
            <summary>入口程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.ResolveFilter">
            <summary>
            加载过滤器，如果返回 false 表示跳过加载。
            </summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetType(System.String)">
            <summary>从程序集中查找指定名称的类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetTypeInternal(System.String)">
            <summary>在程序集中查找类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindPlugins(System.Type)">
            <summary>查找插件，带缓存</summary>
            <param name="baseType">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindAllPlugins(System.Type,System.Boolean,System.Boolean)">
            <summary>查找所有非系统程序集中的所有插件</summary>
            <remarks>继承类所在的程序集会引用baseType所在的程序集，利用这一点可以做一定程度的性能优化。</remarks>
            <param name="baseType"></param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <param name="excludeGlobalTypes">指示是否应检查来自所有引用程序集的类型。如果为 false，则检查来自所有引用程序集的类型。 否则，只检查来自非全局程序集缓存 (GAC) 引用的程序集的类型。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.IsReferencedFrom(System.Reflection.Assembly,System.String)">
            <summary><paramref name="asm"/> 是否引用了 <paramref name="baseAsmName"/></summary>
            <param name="asm">程序集</param>
            <param name="baseAsmName">被引用程序集全名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetAssemblies(System.AppDomain)">
            <summary>获取指定程序域所有程序集</summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.AssemblyPaths">
            <summary>程序集目录集合</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyGetAssemblies">
            <summary>获取当前程序域所有只反射程序集的辅助类。NETCore不支持只反射加载，该方法动态加载DLL后返回</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoad(System.String)">
            <summary>只反射加载指定路径的所有程序集。NETCore不支持只反射加载，该方法动态加载DLL后返回</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetMyAssemblies">
            <summary>获取当前应用程序的所有程序集，不包括系统程序集，仅限本目录</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.OnResolve(System.String)">
            <summary>在对程序集的解析失败时发生</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetCompileTime(System.String)">
            <summary>根据版本号计算得到编译时间</summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DynamicInternal">
            <summary>包装程序集内部类的动态对象</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
            <summary>类型转换</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>成员取值</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
            <summary>调用成员</summary>
            <param name="binder"></param>
            <param name="args"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.Wrap(System.Object)">
            <summary>包装</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DynamicXml">
            <summary>动态Xml</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicXml.Node">
            <summary>节点</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor(System.Xml.Linq.XElement)">
            <summary>实例化</summary>
            <param name="node"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>设置</summary>
            <param name="binder"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>获取</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.IReflect">
            <summary>反射接口</summary>
            <remarks>该接口仅用于扩展，不建议外部使用</remarks>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMethod(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMethods(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetProperty(System.Type,System.String,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetField(System.Type,System.String,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMember(System.Type,System.String,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetFields(System.Type,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetValue(System.Object,System.Reflection.PropertyInfo)">
            <summary>获取目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetValue(System.Object,System.Reflection.FieldInfo)">
            <summary>获取目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.SetValue(System.Object,System.Reflection.PropertyInfo,System.Object)">
            <summary>设置目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.SetValue(System.Object,System.Reflection.FieldInfo,System.Object)">
            <summary>设置目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetElementType(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.As(System.Type,System.Type)">
            <summary>是否能够转为指定基类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类或接口的所有子类实现</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口，为空时返回所有类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetAllSubclasses(System.Type)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DefaultReflect">
            <summary>默认反射实现</summary>
            <remarks>该接口仅用于扩展，不建议外部使用</remarks>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMethod(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMethods(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetProperty(System.Type,System.String,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetField(System.Type,System.String,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMember(System.Type,System.String,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetFields(System.Type,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetValue(System.Object,System.Reflection.PropertyInfo)">
            <summary>获取目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetValue(System.Object,System.Reflection.FieldInfo)">
            <summary>获取目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.SetValue(System.Object,System.Reflection.PropertyInfo,System.Object)">
            <summary>设置目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.SetValue(System.Object,System.Reflection.FieldInfo,System.Object)">
            <summary>设置目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="source">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="source">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetElementType(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.As(System.Type,System.Type)">
            <summary>是否子类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类的子类</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口，为空时返回所有类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetAllSubclasses(System.Type)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Reflect">
            <summary>反射工具类</summary>
            <remarks>
            文档 https://newlifex.com/core/reflect
            </remarks>
        </member>
        <member name="P:NewLife.Reflection.Reflect.Provider">
            <summary>当前反射提供者</summary>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeEx(System.String)">
            <summary>根据名称获取类型。可搜索当前目录DLL，自动加载</summary>
            <param name="typeName">类型名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeEx(System.String,System.Boolean)">
            <summary>根据名称获取类型。可搜索当前目录DLL，自动加载</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMethodEx(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMethodsEx(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetPropertyEx(System.Type,System.String,System.Boolean)">
            <summary>获取属性。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetFieldEx(System.Type,System.String,System.Boolean)">
            <summary>获取字段。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMemberEx(System.Type,System.String,System.Boolean)">
            <summary>获取成员。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetFields(System.Type,System.Boolean)">
            <summary>获取用于序列化的字段</summary>
            <remarks>过滤<seealso cref="T:NonSerializedAttribute"/>特性的字段</remarks>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取用于序列化的属性</summary>
            <remarks>过滤<seealso cref="T:XmlIgnoreAttribute"/>特性的属性和索引器</remarks>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Invoke(System.Object,System.String,System.Object[])">
            <summary>反射调用指定对象的方法。target为类型时调用其静态方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="name">方法名</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.TryInvoke(System.Object,System.String,System.Object@,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="name">方法名</param>
            <param name="value">数值</param>
            <param name="parameters">方法参数</param>
            <remarks>反射调用是否成功</remarks>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetValue(System.Object,System.String,System.Boolean)">
            <summary>获取目标对象指定名称的属性/字段值</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="throwOnError">出错时是否抛出异常</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.TryGetValue(System.Object,System.String,System.Object@)">
            <summary>获取目标对象指定名称的属性/字段值</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <returns>是否成功获取数值</returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetValue(System.Object,System.Reflection.MemberInfo)">
            <summary>获取目标对象的成员值</summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.SetValue(System.Object,System.String,System.Object)">
            <summary>设置目标对象指定名称的属性/字段值，若不存在返回false</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <remarks>反射调用是否成功</remarks>
        </member>
        <member name="M:NewLife.Reflection.Reflect.SetValue(System.Object,System.Reflection.MemberInfo,System.Object)">
            <summary>设置目标对象的成员值</summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetElementTypeEx(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.ChangeType``1(System.Object)">
            <summary>类型转换</summary>
            <typeparam name="TResult"></typeparam>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeArray(System.Object[])">
            <summary>从参数数组中获取类型数组</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMemberType(System.Reflection.MemberInfo)">
            <summary>获取成员的类型，字段和属性是它们的类型，方法是返回类型，类型是自身</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeCode(System.Type)">
            <summary>获取类型代码，支持可空类型</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsBaseType(System.Type)">
            <summary>是否基础类型。识别常见基元类型和String，支持可空类型</summary>
            <remarks>
            基础类型可以方便的进行字符串转换，用于存储于传输。
            在序列化时，基础类型作为原子数据不可再次拆分，而复杂类型则可以进一步拆分。
            包括：Boolean/Char/SByte/Byte/Int16/UInt16/Int32/UInt32/Int64/UInt64/Single/Double/Decimal/DateTime/String/枚举，以及这些类型的可空类型
            </remarks>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsNullable(System.Type)">
            <summary>是否可空类型。继承泛型定义Nullable的类型</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsInt(System.Type)">
            <summary>是否整数。Byte/Int16/Int32/Int64/SByte/UInt16/UInt32/UInt64</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsNumber(System.Type)">
            <summary>是否数字类型。包括整数、小数、字节等</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsList(System.Type)">
            <summary>是否泛型列表</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsDictionary(System.Type)">
            <summary>是否泛型字典</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As(System.Type,System.Type)">
            <summary>是否能够转为指定基类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As``1(System.Type)">
            <summary>是否能够转为指定基类</summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类的子类</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetAllSubclasses(System.Type)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetType(System.Object)">
            <summary>获取类型，如果target是Type类型，则表示要反射的是静态成员</summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As``1(System.Reflection.MethodInfo,System.Object)">
            <summary>把一个方法转为泛型委托，便于快速反射调用</summary>
            <typeparam name="TFunc"></typeparam>
            <param name="method"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.ScriptEngine">
            <summary>脚本引擎</summary>
            <remarks>
            文档 https://newlifex.com/core/script_engine
            
            三大用法：
            1，单个表达式，根据参数计算表达式结果并返回
            2，多个语句，最后有返回语句
            3，多个方法，有一个名为Execute的静态方法作为入口方法
            
            脚本引擎禁止实例化，必须通过<see cref="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)"/>方法创建，以代码为键进行缓存，避免重复创建反复编译形成泄漏。
            其中<see cref="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)"/>方法的第二个参数为true表示前两种用法，为false表示第三种用法。
            </remarks>
            <example>
            最简单而完整的用法：
            <code>
            // 根据代码创建脚本实例，相同代码只编译一次
            var se = ScriptEngine.Create("a+b");
            // 如果Method为空说明未编译，可设置参数
            if (se.Method == null)
            {
                se.Parameters.Add("a", typeof(Int32));
                se.Parameters.Add("b", typeof(Int32));
            }
            // 脚本固定返回Object类型，需要自己转换
            var n = (Int32)se.Invoke(2, 3);
            Console.WriteLine("2+3={0}", n);
            </code>
            
            无参数快速调用：
            <code>
            var n = (Int32)ScriptEngine.Execute("2*3");
            </code>
            
            约定参数快速调用：
            <code>
            var n = (Int32)ScriptEngine.Execute("p0*p1", new Object[] { 2, 3 });
            Console.WriteLine("2*3={0}", n);
            </code>
            </example>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Code">
            <summary>代码</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.IsExpression">
            <summary>是否表达式</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Parameters">
            <summary>参数集合。编译后就不可修改。</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.FinalCode">
            <summary>最终代码</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Type">
            <summary>编译得到的类型</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Method">
            <summary>根据代码编译出来可供直接调用的入口方法，Eval/Main</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.NameSpaces">
            <summary>命名空间集合</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.ReferencedAssemblies">
            <summary>引用程序集集合</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Log">
            <summary>日志</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.WorkingDirectory">
            <summary>工作目录。执行时，将会作为环境变量的当前目录和PathHelper目录，执行后还原</summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.#ctor(System.String,System.Boolean)">
            <summary>构造函数私有，禁止外部越过Create方法直接创建实例</summary>
            <param name="code">代码片段</param>
            <param name="isExpression">是否表达式，表达式将编译成为一个Main方法</param>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)">
            <summary>为指定代码片段创建脚本引擎实例。采用缓存，避免同一脚本重复创建引擎。</summary>
            <param name="code">代码片段</param>
            <param name="isExpression">是否表达式，表达式将编译成为一个Main方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String)">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.String[],System.Type[],System.Object[])">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <param name="names">参数名称</param>
            <param name="parameterTypes">参数类型</param>
            <param name="parameters">参数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <param name="parameters">参数名值对</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.Object[])">
            <summary>执行表达式，返回结果。参数名默认为p0/p1/p2/pn</summary>
            <param name="code"></param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.GenerateCode">
            <summary>生成代码。根据<see cref="P:NewLife.Reflection.ScriptEngine.Code"/>完善得到最终代码<see cref="P:NewLife.Reflection.ScriptEngine.FinalCode"/></summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.GetFullCode">
            <summary>获取完整源代码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Compile">
            <summary>编译</summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Compile(System.String,System.CodeDom.Compiler.CompilerParameters)">
            <summary>编译</summary>
            <param name="classCode"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Invoke(System.Object[])">
            <summary>按照传入参数执行代码</summary>
            <param name="parameters">参数</param>
            <returns>结果</returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.ParseNameSpace(System.String)">
            <summary>分析命名空间</summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.AttributeX">
            <summary>特性辅助类</summary>
        </member>
        <member name="M:NewLife.AttributeX.GetCustomAttributes``1(System.Reflection.Assembly)">
            <summary>获取自定义属性，带有缓存功能，避免因.Net内部GetCustomAttributes没有缓存而带来的损耗</summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetDisplayName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取成员绑定的显示名</summary>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetDescription(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取成员绑定的备注</summary>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetCustomAttributeValue``2(System.Reflection.Assembly)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetCustomAttributeValue``2(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="target">目标对象</param>
            <param name="inherit">是否递归</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiCode">
            <summary>Api接口响应代码</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiCode.Ok">
            <summary>成功</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiCode.Ok200">
            <summary>200成功。一般用于Http响应，也有部分JsonRpc使用该响应码表示成功</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiCode.Unauthorized">
            <summary>未经许可。一般是指未登录</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiCode.Forbidden">
            <summary>禁止访问。一般是只已登录但无权访问</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiCode.NotFound">
            <summary>找不到</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiCode.InternalServerError">
            <summary>内部服务错误。通用错误</summary>
        </member>
        <member name="T:NewLife.Remoting.ApiException">
            <summary>远程调用异常</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiException.Code">
            <summary>代码</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiException.#ctor(System.Int32,System.String)">
            <summary>实例化远程调用异常</summary>
            <param name="code"></param>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiException.#ctor(System.Int32,System.Exception)">
            <summary>实例化远程调用异常</summary>
            <param name="code"></param>
            <param name="ex"></param>
        </member>
        <member name="T:NewLife.Remoting.ApiHelper">
            <summary>Api助手</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHelper.Tracer">
            <summary>性能跟踪器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHelper.Filter">
            <summary>Http过滤器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.GetAsync``1(System.Net.Http.HttpClient,System.String,System.Object,System.Threading.CancellationToken)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="client">Http客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.Get``1(System.Net.Http.HttpClient,System.String,System.Object)">
            <summary>同步获取，参数构造在Url</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="client">Http客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.PostAsync``1(System.Net.Http.HttpClient,System.String,System.Object,System.Threading.CancellationToken)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="client">Http客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.Post``1(System.Net.Http.HttpClient,System.String,System.Object)">
            <summary>同步提交，参数Json打包在Body</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="client">Http客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.PutAsync``1(System.Net.Http.HttpClient,System.String,System.Object,System.Threading.CancellationToken)">
            <summary>异步上传，等待返回结果</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="client">Http客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.DeleteAsync``1(System.Net.Http.HttpClient,System.String,System.Object,System.Threading.CancellationToken)">
            <summary>异步删除，等待返回结果</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="client">Http客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.InvokeAsync``1(System.Net.Http.HttpClient,System.Net.Http.HttpMethod,System.String,System.Object,System.Action{System.Net.Http.HttpRequestMessage},System.String,System.Threading.CancellationToken)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="client">Http客户端</param>
            <param name="method">请求方法</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="onRequest">请求头回调</param>
            <param name="dataName">数据字段名称，默认data。同一套rpc体系不同接口的code/message一致，但data可能不同</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.BuildRequest(System.Net.Http.HttpMethod,System.String,System.Object,NewLife.Serialization.IJsonHost)">
            <summary>建立请求，action写到url里面</summary>
            <param name="method">请求方法</param>
            <param name="action">动作</param>
            <param name="args">参数</param>
            <param name="jsonHost">Json序列化主机</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.BuildContent(NewLife.Data.Packet)">
            <summary>为二进制数据生成请求体内容。对超长内容进行压缩</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiHelper.CodeNames">
            <summary>结果代码名称。默认 code/errcode</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHelper.MessageNames">
            <summary>结果消息名称。默认 message/msg/errmsg</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.ProcessResponse``1(System.Net.Http.HttpResponseMessage,System.String)">
            <summary>处理响应。统一识别code/message</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="response">Http响应消息</param>
            <param name="dataName">数据字段名称，默认data。同一套rpc体系不同接口的code/message一致，但data可能不同</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.ProcessResponse``1(System.Net.Http.HttpResponseMessage,System.String,System.String)">
            <summary>处理响应。统一识别code/message</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="codeName">状态码字段名</param>
            <param name="response">Http响应消息</param>
            <param name="dataName">数据字段名称，默认data。同一套rpc体系不同接口的code/message一致，但data可能不同</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.ProcessResponse``1(System.Net.Http.HttpResponseMessage,System.String,System.String,NewLife.Serialization.IJsonHost)">
            <summary>处理响应。统一识别code/message</summary>
            <typeparam name="TResult">响应类型，优先原始字节数据，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="codeName">状态码字段名</param>
            <param name="response">Http响应消息</param>
            <param name="dataName">数据字段名称，默认data。同一套rpc体系不同接口的code/message一致，但data可能不同</param>
            <param name="jsonHost">Json序列化主机</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.ProcessResponse``1(System.String,System.String,System.String,NewLife.Serialization.IJsonHost)">
            <summary>处理响应。</summary>
            <typeparam name="TResult">响应类型，字典返回整体，Object返回data，没找到data时返回整体字典，其它对data反序列化</typeparam>
            <param name="response">文本响应消息</param>
            <param name="codeName">状态码字段名</param>
            <param name="dataName">数据字段名称，默认data。同一套rpc体系不同接口的code/message一致，但data可能不同</param>
            <param name="jsonHost">Json序列化主机</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHelper.GetUrl(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>根据动作和参数构造Url</summary>
            <param name="action"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiHttpClient">
            <summary>Http应用接口客户端</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Token">
            <summary>令牌。每次请求携带</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Timeout">
            <summary>超时时间。默认15000ms</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.UseProxy">
            <summary>是否使用系统代理设置。默认false不检查系统代理设置，在某些系统上可以大大改善初始化速度</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.RoundRobin">
            <summary>加权轮询负载均衡。默认false只使用故障转移</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.ShieldingTime">
            <summary>不可用节点的屏蔽时间。默认60秒</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Authentication">
            <summary>身份验证</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.DefaultUserAgent">
            <summary>默认用户浏览器UserAgent。默认为空，可取值HttpHelper.DefaultUserAgent</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.JsonHost">
            <summary>Json序列化主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.ServiceProvider">
            <summary>服务提供者。创建控制器实例时使用，可实现依赖注入。务必在注册控制器之前设置该属性</summary>
        </member>
        <member name="E:NewLife.Remoting.ApiHttpClient.OnRequest">
            <summary>创建请求时触发</summary>
        </member>
        <member name="E:NewLife.Remoting.ApiHttpClient.OnCreateClient">
            <summary>创建客户端时触发</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Filter">
            <summary>Http过滤器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.CodeName">
            <summary>状态码字段名。例如code/status等</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.DataName">
            <summary>数据体字段名。例如data/result等</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Source">
            <summary>服务器源。正在使用的服务器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.StatInvoke">
            <summary>调用统计</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.SlowTrace">
            <summary>慢追踪。远程调用或处理时间超过该值时，输出慢调用日志，默认5000ms</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Tracer">
            <summary>跟踪器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Services">
            <summary>服务列表。用于负载均衡和故障转移</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiHttpClient._currentService">
            <summary>当前服务</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Current">
            <summary>正在使用的服务点。最后一次调用成功的服务点，可获取其地址以及状态信息</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="urls">地址集合。多地址逗号分隔，支持权重，test1=3*http://127.0.0.1:1234,test2=7*http://127.0.0.1:3344</param>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.#ctor(System.IServiceProvider,System.String)">
            <summary>按照配置服务实例化，用于NETCore依赖注入</summary>
            <param name="provider">服务提供者，将要解析IConfigProvider</param>
            <param name="name">缓存名称，也是配置中心key</param>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.Add(System.String,System.String)">
            <summary>添加服务地址</summary>
            <param name="name">名称</param>
            <param name="address">地址，支持名称和权重，test1=3*http://127.0.0.1:1234</param>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.Add(System.String,System.Uri)">
            <summary>添加服务地址</summary>
            <param name="name"></param>
            <param name="address"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.GetAsync``1(System.String,System.Object)">
            <summary>异步获取，参数构造在Url</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.Get``1(System.String,System.Object)">
            <summary>同步获取，参数构造在Url</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.PostAsync``1(System.String,System.Object)">
            <summary>异步提交，参数Json打包在Body</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.Post``1(System.String,System.Object)">
            <summary>同步提交，参数Json打包在Body</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.PutAsync``1(System.String,System.Object)">
            <summary>异步上传，参数Json打包在Body</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.PatchAsync``1(System.String,System.Object)">
            <summary>异步修改，参数Json打包在Body</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.DeleteAsync``1(System.String,System.Object)">
            <summary>异步删除，参数Json打包在Body</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.InvokeAsync``1(System.Net.Http.HttpMethod,System.String,System.Object,System.Action{System.Net.Http.HttpRequestMessage},System.Threading.CancellationToken)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult"></typeparam>
            <param name="method">请求方法</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="onRequest">请求头回调</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.InvokeAsync``1(System.String,System.Object,System.Threading.CancellationToken)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult"></typeparam>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.Invoke``1(System.String,System.Object)">
            <summary>同步调用，阻塞等待</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.BuildRequest(System.Net.Http.HttpMethod,System.String,System.Object,System.Type)">
            <summary>建立请求</summary>
            <param name="method">请求方法</param>
            <param name="action"></param>
            <param name="args"></param>
            <param name="returnType"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Remoting.ApiHttpClient._idxServer">
            <summary>调度索引，当前使用该索引处的服务</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <summary>异步发送</summary>
            <param name="request">请求</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.GetService">
            <summary>获取一个服务用于处理请求，此处可实现负载均衡LoadBalance。默认取当前可用服务</summary>
            <remarks>
            如需实现负载均衡，每次取值后都累加索引，让其下一次记获取时拿到下一个服务。
            </remarks>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.PutService(NewLife.Remoting.ApiHttpClient.Service,System.Exception)">
            <summary>归还服务，此处实现故障转移Failover，服务的客户端被清空，说明当前服务不可用</summary>
            <param name="service"></param>
            <param name="error"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.SendOnServiceAsync(System.Net.Http.HttpRequestMessage,NewLife.Remoting.ApiHttpClient.Service,System.Net.Http.HttpClient,System.Threading.CancellationToken)">
            <summary>在指定服务地址上发生请求</summary>
            <param name="request">请求消息</param>
            <param name="service">服务名</param>
            <param name="client">客户端</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.CreateClient">
            <summary>创建客户端</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiHttpClient.Service">
            <summary>服务项</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.Address">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.Weight">
            <summary>权重。用于负载均衡，默认1</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiHttpClient.Service.Index">
            <summary>轮询均衡时，本项第几次使用</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.Times">
            <summary>总次数</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.Errors">
            <summary>错误数</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.CreateTime">
            <summary>创建时间。每过一段时间，就清空一次客户端，让它重建连接，更新域名缓存</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.NextTime">
            <summary>下一次时间。服务项出错时，将禁用一段时间</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Service.Client">
            <summary>客户端</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.Service.ToString">
            <summary>已重载。友好显示</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiHttpClient.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpClient.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Remoting.HttpClientEventArgs">
            <summary>Http客户端事件参数</summary>
        </member>
        <member name="P:NewLife.Remoting.HttpClientEventArgs.Client">
            <summary>客户端</summary>
        </member>
        <member name="T:NewLife.Remoting.HttpRequestEventArgs">
            <summary>Http请求事件参数</summary>
        </member>
        <member name="P:NewLife.Remoting.HttpRequestEventArgs.Request">
            <summary>客户端</summary>
        </member>
        <member name="T:NewLife.Remoting.IApiClient">
            <summary>应用接口客户端接口</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiClient.Token">
            <summary>令牌。每次请求携带</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiClient.Invoke``1(System.String,System.Object)">
            <summary>同步调用，阻塞等待</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiClient.InvokeAsync``1(System.String,System.Object,System.Threading.CancellationToken)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult"></typeparam>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Asn1">
            <summary>抽象语法标记。ASN.1是一种 ISO/ITU-T 标准，描述了一种对数据进行表示、编码、传输和解码的数据格式。</summary>
        </member>
        <member name="P:NewLife.Security.Asn1.Tag">
            <summary>标签</summary>
        </member>
        <member name="P:NewLife.Security.Asn1.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Security.Asn1.Value">
            <summary>数值</summary>
        </member>
        <member name="M:NewLife.Security.Asn1.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.GetOids">
            <summary>获取OID</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.Read(System.Byte[])">
            <summary>读取</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.Read(System.IO.Stream)">
            <summary>读取</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.Read(System.IO.BinaryReader)">
            <summary>读取对象</summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.GetByteArray(System.Boolean)">
            <summary>获取字节数组</summary>
            <param name="trimZero"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.ReadTLV(System.IO.BinaryReader,System.Byte@)">
            <summary>读取TLV，Tag+Length+Value</summary>
            <param name="reader">读取器</param>
            <param name="tag"></param>
            <returns>返回长度，数据流指针移到Value第一个字节</returns>
        </member>
        <member name="M:NewLife.Security.Asn1.ReadTLV(System.IO.BinaryReader,System.Boolean)">
            <summary>读取TLV，Tag+Length+Value</summary>
            <param name="reader">读取器</param>
            <param name="trimZero">是否剔除头部的0x00</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Asn1Tags">
            <summary>ASN.1标签</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Boolean">
            <summary>布尔</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Integer">
            <summary>长整数</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.BitString">
            <summary>比特串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.OctetString">
            <summary>字节串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Null">
            <summary>空</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.ObjectIdentifier">
            <summary>OID实体标识符</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.External">
            <summary>外部</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Enumerated">
            <summary>枚举</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Sequence">
            <summary>序列</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Set">
            <summary>集合</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.NumericString">
            <summary>数字字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.PrintableString">
            <summary>可打印字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.T61String">
            <summary>T61字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.VideotexString">
            <summary>视频</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.IA5String">
            <summary>IA5字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.UtcTime">
            <summary>UTC时间</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.GeneralizedTime">
            <summary>通用时间</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.GraphicString">
            <summary>图形</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.VisibleString">
            <summary>可见字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.GeneralString">
            <summary>基本字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.UniversalString">
            <summary>全局字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.BmpString">
            <summary>位图</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Utf8String">
            <summary>UTF8字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Constructed">
            <summary>组合</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Application">
            <summary>应用</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Tagged">
            <summary>标记</summary>
        </member>
        <member name="T:NewLife.Security.CbcTransform">
            <summary>CBC块密码模式</summary>
            <remarks>
            密码块链 (CBC) 模式引入了反馈。 每个纯文本块在加密前，通过按位“异或”操作与前一个块的密码文本结合。
            这样确保了即使纯文本包含许多相同的块，这些块中的每一个也会加密为不同的密码文本块。
            在加密块之前，初始化向量通过按位“异或”操作与第一个纯文本块结合。
            如果密码文本块中有一个位出错，相应的纯文本块也将出错。
            此外，后面的块中与原出错位的位置相同的位也将出错。
            </remarks>
        </member>
        <member name="P:NewLife.Security.CbcTransform.CanTransformMultipleBlocks">
            <summary>获取一个值，该值指示是否可以转换多个块。</summary>
        </member>
        <member name="P:NewLife.Security.CbcTransform.CanReuseTransform">
            <summary>获取一个值，该值指示是否可重复使用当前转换。</summary>
        </member>
        <member name="P:NewLife.Security.CbcTransform.InputBlockSize">
            <summary>获取输入块大小。</summary>
        </member>
        <member name="P:NewLife.Security.CbcTransform.OutputBlockSize">
            <summary>获取输出块大小。</summary>
        </member>
        <member name="M:NewLife.Security.CbcTransform.#ctor(System.Security.Cryptography.ICryptoTransform,System.Byte[],System.Boolean)">
            <summary>实例化</summary>
            <param name="transform"></param>
            <param name="iv"></param>
            <param name="encryptMode"></param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:NewLife.Security.CbcTransform.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Security.CbcTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>转换输入字节数组的指定区域，并将所得到的转换复制到输出字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <param name="outputBuffer"></param>
            <param name="outputOffset"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NewLife.Security.CbcTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>转换指定字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:NewLife.Security.Crc16">
            <summary>CRC16校验</summary>
        </member>
        <member name="F:NewLife.Security.Crc16.CrcTable">
            <summary>CRC16表</summary>
        </member>
        <member name="P:NewLife.Security.Crc16.Value">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Int16)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验，查表计算  CRC16-CCITT x16+x12+x5+1 1021  ISO HDLC, ITU X.25, V.34/V.41/V.42, PPP-FCS</summary>
            <remarks>字符串123456789的Crc16是31C3</remarks>
            <param name = "buffer">数据缓冲区</param>
            <param name = "offset">偏移量</param>
            <param name = "count">字节个数</param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验，不查表计算  CRC-16 x16+x15+x2+1 8005 IBM SDLC</summary>
            <param name="stream"></param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>计算校验码</summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.IO.Stream,System.Int32)">
            <summary>计算数据流校验码</summary>
            <param name="stream"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.IO.Stream,System.Int64,System.Int32)">
            <summary>计算数据流校验码，指定起始位置和字节数偏移量</summary>
            <remarks>
            一般用于计算数据包校验码，需要回过头去开始校验，并且可能需要跳过最后的校验码长度。
            position小于0时，数据流从当前位置开始计算校验；
            position大于等于0时，数据流移到该位置开始计算校验，最后由count决定可能差几个字节不参与计算；
            </remarks>
            <param name="stream"></param>
            <param name="position">如果大于等于0，则表示从该位置开始计算</param>
            <param name="count">字节数偏移量，一般用负数表示</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.ComputeModbus(System.Byte[],System.Int32,System.Int32)">
            <summary>Modbus版Crc校验</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.ComputeModbus(System.IO.Stream,System.Int64)">
            <summary>Modbus版Crc校验</summary>
            <param name="stream">数据流</param>
            <param name="position">回到该位置开始</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Crc32">
             <summary>CRC32校验</summary>
             <remarks>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:NewLife.Security.Crc32.Table">
            <summary>校验表</summary>
        </member>
        <member name="F:NewLife.Security.Crc32.crc">
            <summary>校验值</summary>
        </member>
        <member name="P:NewLife.Security.Crc32.Value">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Int32)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验</summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验</summary>
            <param name="stream"></param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Security.Crc32.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>计算校验码</summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc32.Compute(System.IO.Stream,System.Int32)">
            <summary>计算数据流校验码</summary>
            <param name="stream"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc32.ComputeRange(System.IO.Stream,System.Int64,System.Int32)">
            <summary>计算数据流校验码，指定起始位置和字节数偏移量</summary>
            <remarks>
            一般用于计算数据包校验码，需要回过头去开始校验，并且可能需要跳过最后的校验码长度。
            position小于0时，数据流从当前位置开始计算校验；
            position大于等于0时，数据流移到该位置开始计算校验，最后由count决定可能差几个字节不参与计算；
            </remarks>
            <param name="stream"></param>
            <param name="position">如果大于等于0，则表示从该位置开始计算</param>
            <param name="count">字节数偏移量，一般用负数表示</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.DSAHelper">
            <summary>DSA算法</summary>
        </member>
        <member name="M:NewLife.Security.DSAHelper.GenerateKey(System.Int32)">
            <summary>产生非对称密钥对（私钥和公钥）</summary>
            <param name="keySize">密钥长度，默认1024位强密钥</param>
            <returns>私钥和公钥</returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.Sign(System.Byte[],System.String)">
            <summary>签名</summary>
            <param name="buf"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.Verify(System.Byte[],System.String,System.Byte[])">
            <summary>验证</summary>
            <param name="buf"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.FromXmlStringX(System.Security.Cryptography.DSACryptoServiceProvider,System.String)">
            <summary>从Xml加载DSA密钥</summary>
            <param name="rsa"></param>
            <param name="xmlString"></param>
        </member>
        <member name="M:NewLife.Security.DSAHelper.ToXmlStringX(System.Security.Cryptography.DSACryptoServiceProvider,System.Boolean)">
            <summary>保存DSA密钥到Xml</summary>
            <param name="rsa"></param>
            <param name="includePrivateParameters"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.IPasswordProvider">
            <summary>密码提供者</summary>
        </member>
        <member name="M:NewLife.Security.IPasswordProvider.Hash(System.String)">
            <summary>对密码进行散列处理，此处可以加盐，结果保存在数据库</summary>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.IPasswordProvider.Verify(System.String,System.String)">
            <summary>验证密码散列，包括加盐判断</summary>
            <param name="password"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.PasswordProvider">
            <summary>默认密码提供者</summary>
        </member>
        <member name="M:NewLife.Security.PasswordProvider.Hash(System.String)">
            <summary>对密码进行散列处理，此处可以加盐，结果保存在数据库</summary>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.PasswordProvider.Verify(System.String,System.String)">
            <summary>验证密码散列，包括加盐判断</summary>
            <param name="password"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.MD5PasswordProvider">
            <summary>MD5密码提供者</summary>
        </member>
        <member name="M:NewLife.Security.MD5PasswordProvider.Hash(System.String)">
            <summary>对密码进行散列处理，此处可以加盐，结果保存在数据库</summary>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.MD5PasswordProvider.Verify(System.String,System.String)">
            <summary>验证密码散列，包括加盐判断</summary>
            <param name="password"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.SaltPasswordProvider">
            <summary>盐值密码提供者</summary>
        </member>
        <member name="P:NewLife.Security.SaltPasswordProvider.Algorithm">
            <summary>算法。支持md5/sha1/sha512</summary>
        </member>
        <member name="P:NewLife.Security.SaltPasswordProvider.SaltTime">
            <summary>使用Unix秒作为盐值。该值为允许的最大时间差，默认0，不使用时间盐值，而是使用随机字符串</summary>
            <remarks>一般在传输中使用，避免临时盐值被截取作为它用，建议值30秒。不仅仅是传输耗时，还有两端时间差</remarks>
        </member>
        <member name="M:NewLife.Security.SaltPasswordProvider.Hash(System.String)">
            <summary>对密码进行散列处理，此处可以加盐，结果保存在数据库</summary>
            <param name="password">密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.SaltPasswordProvider.CreateSalt">
            <summary>创建盐值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.SaltPasswordProvider.Verify(System.String,System.String)">
            <summary>验证密码散列，包括加盐判断</summary>
            <param name="password"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Murmur128">
            <summary>高性能低碰撞Murmur128哈希算法</summary>
            <remarks>
            Redis等大量使用，比MD5要好
            </remarks>
        </member>
        <member name="P:NewLife.Security.Murmur128.Seed">
            <summary>种子</summary>
        </member>
        <member name="P:NewLife.Security.Murmur128.HashSize">
            <summary>哈希大小</summary>
        </member>
        <member name="M:NewLife.Security.Murmur128.#ctor(System.UInt32)">
            <summary>实例化</summary>
            <param name="seed"></param>
        </member>
        <member name="M:NewLife.Security.Murmur128.Initialize">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Security.Murmur128.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>哈希核心</summary>
            <param name="array"></param>
            <param name="ibStart"></param>
            <param name="cbSize"></param>
        </member>
        <member name="M:NewLife.Security.Murmur128.HashFinal">
            <summary>哈希结束</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.PKCS7PaddingTransform">
            <summary>PKCS7填充</summary>
        </member>
        <member name="P:NewLife.Security.PKCS7PaddingTransform.CanReuseTransform">
            <summary>获取一个值，该值指示是否可重复使用当前转换。</summary>
        </member>
        <member name="P:NewLife.Security.PKCS7PaddingTransform.CanTransformMultipleBlocks">
            <summary>获取一个值，该值指示是否可以转换多个块。</summary>
        </member>
        <member name="P:NewLife.Security.PKCS7PaddingTransform.InputBlockSize">
            <summary>获取输入块大小。</summary>
        </member>
        <member name="P:NewLife.Security.PKCS7PaddingTransform.OutputBlockSize">
            <summary>获取输出块大小。</summary>
        </member>
        <member name="M:NewLife.Security.PKCS7PaddingTransform.#ctor(System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>实例化</summary>
            <param name="transform"></param>
            <param name="mode"></param>
            <param name="encryptMode"></param>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:NewLife.Security.PKCS7PaddingTransform.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Security.PKCS7PaddingTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>转换输入字节数组的指定区域，并将所得到的转换复制到输出字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <param name="outputBuffer"></param>
            <param name="outputOffset"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.PKCS7PaddingTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>转换指定字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.ProtectedKey">
            <summary>数据保护者。保护连接字符串中的密码</summary>
        </member>
        <member name="P:NewLife.Security.ProtectedKey.Secret">
            <summary>保护数据的密钥</summary>
        </member>
        <member name="P:NewLife.Security.ProtectedKey.Algorithm">
            <summary>算法。默认AES</summary>
        </member>
        <member name="P:NewLife.Security.ProtectedKey.HideString">
            <summary>隐藏字符串</summary>
        </member>
        <member name="P:NewLife.Security.ProtectedKey.Names">
            <summary>密码名字</summary>
        </member>
        <member name="P:NewLife.Security.ProtectedKey.Instance">
            <summary>全局实例。从环境变量和配置文件读取ProtectedKey密钥</summary>
        </member>
        <member name="M:NewLife.Security.ProtectedKey.Protect(System.String)">
            <summary>保护连接字符串中的密码</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ProtectedKey.Unprotect(System.String)">
            <summary>解保护连接字符串中的密码</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ProtectedKey.Hide(System.String)">
            <summary>隐藏连接字符串中的密码</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Rand">
            <summary>随机数</summary>
        </member>
        <member name="M:NewLife.Security.Rand.Next(System.Int32)">
            <summary>返回一个小于所指定最大值的非负随机数</summary>
            <param name="max">返回的随机数的上界（随机数不能取该上界值）</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.Next(System.Int32,System.Int32)">
            <summary>返回一个指定范围内的随机数</summary>
            <remarks>
            调用平均耗时37.76ns，其中GC耗时77.56%
            </remarks>
            <param name="min">返回的随机数的下界（随机数可取该下界值）</param>
            <param name="max">返回的随机数的上界（随机数不能取该上界值）</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.NextBytes(System.Int32)">
            <summary>返回指定长度随机字节数组</summary>
            <remarks>
            调用平均耗时5.46ns，其中GC耗时15%
            </remarks>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.NextBytes(System.Random,System.Int32)">
            <summary>
            返回随机数填充的指定长度的数组
            </summary>
            <param name="random"></param>
            <param name="length">数组长度</param>
            <returns>随机数填充的指定长度的数组</returns>
        </member>
        <member name="M:NewLife.Security.Rand.NextString(System.Int32,System.Boolean)">
            <summary>返回指定长度随机字符串</summary>
            <param name="length">长度</param>
            <param name="symbol">是否包含符号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.Fill``1(``0)">
            <summary>随机填充指定对象的属性。可用于构造随机数据进行测试</summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.RC4">
            <summary>RC4对称加密算法</summary>
            <remarks>
            RC4于1987年提出，和DES算法一样，是一种对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。
            但不同于DES的是，RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。
            
            RC4算法的特点是算法简单，运行速度快，而且密钥长度是可变的，可变范围为1-256字节(8-2048比特)，
            在如今技术支持的前提下，当密钥长度为128比特时，用暴力法搜索密钥已经不太可行，所以可以预见RC4的密钥范围任然可以在今后相当长的时间里抵御暴力搜索密钥的攻击。
            实际上，如今也没有找到对于128bit密钥长度的RC4加密算法的有效攻击方法。
            </remarks>
        </member>
        <member name="M:NewLife.Security.RC4.Encrypt(System.Byte[],System.Byte[])">
            <summary>加密</summary>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RC4.GetKey(System.Byte[],System.Int32)">
            <summary>打乱密码</summary>  
            <param name="pass">密码</param>  
            <param name="len">密码箱长度</param>  
            <returns>打乱后的密码</returns>  
        </member>
        <member name="T:NewLife.Security.RSAHelper">
            <summary>RSA算法</summary>
            <remarks>
            RSA加密或签名小数据块时，密文长度128，速度也很快。
            </remarks>
        </member>
        <member name="M:NewLife.Security.RSAHelper.GenerateKey(System.Int32)">
            <summary>产生非对称密钥对</summary>
            <remarks>
            RSAParameters的各个字段采用大端字节序，转为BigInteger的之前一定要倒序。
            RSA加密后密文最小长度就是密钥长度，所以1024密钥最小密文长度是128字节。
            </remarks>
            <param name="keySize">密钥长度，默认1024位强密钥</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.GenerateParameters(System.Int32)">
            <summary>产生非对称密钥对</summary>
            <remarks>
            RSAParameters的各个字段采用大端字节序，转为BigInteger的之前一定要倒序。
            RSA加密后密文最小长度就是密钥长度，所以1024密钥最小密文长度是128字节。
            </remarks>
            <param name="keySize">密钥长度，默认1024位强密钥</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.WriteParameters(System.Security.Cryptography.RSAParameters)">
            <summary>RSA参数转为Base64密钥</summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.ReadParameters(System.String)">
            <summary>根据Base64密钥创建RSA参数</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Create(System.String)">
            <summary>创建RSA对象，支持Xml密钥和Pem密钥</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Encrypt(System.Byte[],System.String,System.Boolean)">
            <summary>RSA公钥加密。仅用于加密少量数据</summary>
            <remarks>
            (PKCS # 1 v2) 的 OAEP 填充	模数大小-2-2 * hLen，其中 hLen 是哈希的大小。
            直接加密 (PKCS # 1 1.5 版)	模数大小-11。 (11 个字节是可能的最小填充。 )
            </remarks>
            <param name="data">数据明文</param>
            <param name="pubKey">公钥</param>
            <param name="fOAEP">如果为 true，则使用 OAEP 填充（仅可用于运行 Windows XP 及更高版本的计算机）执行直接 System.Security.Cryptography.RSA加密；否则，如果为 false，则使用 PKCS#1 v1.5 填充。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Decrypt(System.Byte[],System.String,System.Boolean)">
            <summary>RSA私钥解密。仅用于加密少量数据</summary>
            <remarks>
            (PKCS # 1 v2) 的 OAEP 填充	模数大小-2-2 * hLen，其中 hLen 是哈希的大小。
            直接加密 (PKCS # 1 1.5 版)	模数大小-11。 (11 个字节是可能的最小填充。 )
            </remarks>
            <param name="data">数据密文</param>
            <param name="priKey">私钥</param>
            <param name="fOAEP">如果为 true，则使用 OAEP 填充（仅可用于运行 Microsoft Windows XP 及更高版本的计算机）执行直接 System.Security.Cryptography.RSA解密；否则，如果为 false 则使用 PKCS#1 v1.5 填充。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Sign(System.Byte[],System.String)">
            <summary>签名，MD5散列</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Verify(System.Byte[],System.String,System.Byte[])">
            <summary>验证，MD5散列</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.SignSha256(System.Byte[],System.String)">
            <summary>RS256</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.VerifySha256(System.Byte[],System.String,System.Byte[])">
            <summary>RS256</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.SignSha384(System.Byte[],System.String)">
            <summary>RS384</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.VerifySha384(System.Byte[],System.String,System.Byte[])">
            <summary>RS384</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.SignSha512(System.Byte[],System.String)">
            <summary>RS512</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.VerifySha512(System.Byte[],System.String,System.Byte[])">
            <summary>RS512</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.ReadPem(System.String)">
            <summary>读取PEM文件到RSA参数</summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.ZerosPaddingTransform">
            <summary>Zero填充</summary>
        </member>
        <member name="P:NewLife.Security.ZerosPaddingTransform.CanReuseTransform">
            <summary>获取一个值，该值指示是否可重复使用当前转换。</summary>
        </member>
        <member name="P:NewLife.Security.ZerosPaddingTransform.CanTransformMultipleBlocks">
            <summary>获取一个值，该值指示是否可以转换多个块。</summary>
        </member>
        <member name="P:NewLife.Security.ZerosPaddingTransform.InputBlockSize">
            <summary>获取输入块大小。</summary>
        </member>
        <member name="P:NewLife.Security.ZerosPaddingTransform.OutputBlockSize">
            <summary>获取输出块大小。</summary>
        </member>
        <member name="M:NewLife.Security.ZerosPaddingTransform.#ctor(System.Security.Cryptography.ICryptoTransform,System.Boolean)">
            <summary>实例化</summary>
            <param name="transform"></param>
            <param name="encryptMode"></param>
        </member>
        <member name="M:NewLife.Security.ZerosPaddingTransform.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Security.ZerosPaddingTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>转换输入字节数组的指定区域，并将所得到的转换复制到输出字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <param name="outputBuffer"></param>
            <param name="outputOffset"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ZerosPaddingTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>转换指定字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.SecurityHelper">
            <summary>安全算法</summary>
            <remarks>
            文档 https://newlifex.com/core/security_helper
            </remarks>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5(System.Byte[])">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5(System.String,System.Text.Encoding)">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <param name="encoding">字符串编码，默认Default</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5_16(System.String,System.Text.Encoding)">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <param name="encoding">字符串编码，默认Default</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5(System.IO.FileInfo)">
            <summary>计算文件的MD5散列</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Crc(System.Byte[])">
            <summary>Crc散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Crc16(System.Byte[])">
            <summary>Crc16散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA1(System.Byte[],System.Byte[])">
            <summary>SHA128</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA256(System.Byte[],System.Byte[])">
            <summary>SHA256</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA384(System.Byte[],System.Byte[])">
            <summary>SHA384</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA512(System.Byte[],System.Byte[])">
            <summary>SHA512</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Murmur128(System.Byte[],System.UInt32)">
            <summary>Murmur128哈希</summary>
            <param name="data"></param>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Encrypt(System.Security.Cryptography.SymmetricAlgorithm,System.IO.Stream,System.IO.Stream)">
            <summary>对称加密算法扩展</summary>
            <remarks>注意：CryptoStream会把 outstream 数据流关闭</remarks>
            <param name="sa"></param>
            <param name="instream"></param>
            <param name="outstream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Encrypt(System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode)">
            <summary>对称加密算法扩展</summary>
            <remarks>CBC填充依赖IV，要求加解密的IV一致，而ECB填充则不需要</remarks>
            <param name="sa">算法</param>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <param name="mode">模式。.Net默认CBC，Java默认ECB</param>
            <param name="padding">填充算法。默认PKCS7，等同Java的PKCS5</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Decrypt(System.Security.Cryptography.SymmetricAlgorithm,System.IO.Stream,System.IO.Stream)">
            <summary>对称解密算法扩展
            <para>注意：CryptoStream会把 instream 数据流关闭</para>
            </summary>
            <param name="sa"></param>
            <param name="instream"></param>
            <param name="outstream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Decrypt(System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode)">
            <summary>对称解密算法扩展</summary>
            <remarks>CBC填充依赖IV，要求加解密的IV一致，而ECB填充则不需要</remarks>
            <param name="sa">算法</param>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <param name="mode">模式。.Net默认CBC，Java默认ECB</param>
            <param name="padding">填充算法。默认PKCS7，等同Java的PKCS5</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Transform(System.Security.Cryptography.ICryptoTransform,System.Byte[])">
            <summary>转换数据（内部加解密）</summary>
            <param name="transform"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.RC4(System.Byte[],System.Byte[])">
            <summary>RC4对称加密算法</summary>
            <param name="data"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Binary">
            <summary>二进制序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.EncodeInt">
            <summary>使用7位编码整数。默认false不使用</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.IsLittleEndian">
            <summary>小端字节序。默认false大端</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.UseFieldSize">
            <summary>使用指定大小的FieldSizeAttribute特性，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.UseRef">
            <summary>使用对象引用，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.SizeWidth">
            <summary>大小宽度。可选0/1/2/4，默认0表示压缩编码整数</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.TrimZero">
            <summary>解析字符串时，是否清空两头的0字节，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.Version">
            <summary>协议版本。用于支持多版本协议序列化，配合FieldSize特性使用。例如JT/T808的2011/2019</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.FullTime">
            <summary>使用完整的时间格式。完整格式使用8个字节保存毫秒数，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.AddHandler(NewLife.Serialization.IBinaryHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.GetHandler``1">
            <summary>获取处理器</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteSize(System.Int32)">
            <summary>写入大小，如果有FieldSize则返回，否则写入编码的大小并返回-1</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteEncoded(System.Int32)">
            <summary>写7位压缩编码整数</summary>
            <remarks>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </remarks>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt16">
            <summary>以压缩格式读取16位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt32">
            <summary>以压缩格式读取32位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt64">
            <summary>以压缩格式读取64位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadUInt16">
            <summary>读取无符号短整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadInt16">
            <summary>读取短整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadUInt32">
            <summary>读取无符号整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadInt32">
            <summary>读取整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteByte(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteUInt16(System.UInt16)">
            <summary>写入无符号短整数</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteInt16(System.Int16)">
            <summary>写入短整数</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteUInt32(System.UInt32)">
            <summary>写入无符号整数</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteInt32(System.Int32)">
            <summary>写入整数</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.FromBCD(System.Byte)">
            <summary>BCD字节转十进制数字</summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ToBCD(System.Int32)">
            <summary>十进制数字转BCD字节</summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadBCD(System.Int32)">
            <summary>读取指定长度的BCD字符串。BCD每个字节存放两个数字</summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteBCD(System.String,System.Int32)">
            <summary>写入指定长度的BCD字符串。BCD每个字节存放两个数字</summary>
            <param name="value"></param>
            <param name="max"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteFixedString(System.String,System.Int32)">
            <summary>写入定长字符串。多余截取，少则补零</summary>
            <param name="value"></param>
            <param name="max"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadFixedString(System.Int32)">
            <summary>读取定长字符串。多余截取，少则补零</summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.EndOfStream">
            <summary>是否已达到末尾</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.CheckRemain(System.Int32)">
            <summary>检查剩余量是否足够</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastRead``1(System.IO.Stream,System.Boolean)">
            <summary>快速读取</summary>
            <typeparam name="T"></typeparam>
            <param name="stream">数据流</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastWrite(System.Object,System.Boolean)">
            <summary>快速写入</summary>
            <param name="value">对象</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastWrite(System.Object,System.IO.Stream,System.Boolean)">
            <summary>快速写入</summary>
            <param name="value">对象</param>
            <param name="stream">目标数据流</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryColor">
            <summary>颜色处理器。</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryComposite">
            <summary>复合对象处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryDictionary">
            <summary>字典数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryFont">
            <summary>字体处理器。</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryFont.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryFont.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryFont.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryGeneral">
            <summary>二进制基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte)">
            <summary>将一个无符号字节写入</summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[])">
            <summary>将字节数组写入，如果设置了UseSize，则先写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[],System.Int32)">
            <summary>写入字节数组，自动计算长度</summary>
            <param name="buffer">缓冲区</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int16)">
            <summary>将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int32)">
            <summary>将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int64)">
            <summary>将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteIntBytes(System.Byte[])">
            <summary>判断字节顺序</summary>
            <param name="buffer">缓冲区</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt16)">
            <summary>将 2 字节无符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt32)">
            <summary>将 4 字节无符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt64)">
            <summary>将 8 字节无符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Single)">
            <summary>将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Double)">
            <summary>将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Decimal)">
            <summary>将一个十进制值写入当前流，并将流位置提升十六个字节。</summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Char)">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Char[],System.Int32,System.Int32)">
            <summary>将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadByte">
            <summary>从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadIntBytes(System.Int32)">
            <summary>读取整数的字节数组，某些写入器（如二进制写入器）可能需要改变字节顺序</summary>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt64">
            <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt16">
            <summary>使用 Little-Endian 编码从当前流中读取 2 字节无符号整数，并将流的位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt32">
            <summary>从当前流中读取 4 字节无符号整数并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt64">
            <summary>从当前流中读取 8 字节无符号整数并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadSingle">
            <summary>从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadDouble">
            <summary>从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadChar">
            <summary>从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadString">
            <summary>从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadDecimal">
            <summary>从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt16">
            <summary>以压缩格式读取16位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt32">
            <summary>以压缩格式读取32位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt64">
            <summary>以压缩格式读取64位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int16)">
            <summary>
            以7位压缩格式写入16位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int32)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int64)">
            <summary>
            以7位压缩格式写入64位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryList">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryNormal">
            <summary>常用类型编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.Write(System.Byte[],System.Int32)">
            <summary>写入字节数组，自动计算长度</summary>
            <param name="buffer">缓冲区</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.ReadChars(System.Int32)">
            <summary>从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。</summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.FieldSizeAttribute">
            <summary>字段大小特性。</summary>
            <remarks>
            可以通过Size指定字符串或数组的固有大小，为0表示自动计算；
            也可以通过指定参考字段ReferenceName，然后从其中获取大小。
            支持_Header._Questions形式的多层次引用字段。
            
            支持针对单个成员使用多个FieldSize特性，各自指定不同Version版本，以支持不同版本协议的序列化。
            例如JT/T808协议，2011/2019版的相同字段使用不同长度。
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.Size">
            <summary>大小。使用<see cref="P:NewLife.Serialization.FieldSizeAttribute.ReferenceName"/>时，作为偏移量；0表示自动计算大小</summary>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.SizeWidth">
            <summary>大小宽度。特定个数的字节表示长度，自动计算时（Size=0）使用，可选0/1/2/4</summary>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.ReferenceName">
            <summary>参考大小字段名，其中存储了实际大小，使用时获取</summary>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.Version">
            <summary>协议版本。用于支持多版本协议序列化。例如JT/T808的2011/2019</summary>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.Int32)">
            <summary>通过Size指定字符串或数组的固有大小，为0表示自动计算</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String,System.Int32)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
            <param name="size">在参考字段值基础上的增量，可以是正数负数</param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.Int32,System.String)">
            <summary>指定大小，指定协议版本，用于支持多版本协议序列化</summary>
            <param name="size"></param>
            <param name="version"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.FindReference(System.Object,System.Reflection.MemberInfo,System.Object@)">
            <summary>找到所引用的参考字段</summary>
            <param name="target">目标对象</param>
            <param name="member">目标对象的成员</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.SetReferenceSize(System.Object,System.Reflection.MemberInfo,System.Text.Encoding)">
            <summary>设置目标对象的引用大小值</summary>
            <param name="target">目标对象</param>
            <param name="member"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.TryGetReferenceSize(System.Object,System.Reflection.MemberInfo,System.Int32@)">
            <summary>获取目标对象的引用大小值</summary>
            <param name="target">目标对象</param>
            <param name="member"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IBinary">
            <summary>二进制序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.EncodeInt">
            <summary>编码整数</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.IsLittleEndian">
            <summary>小端字节序。默认false大端</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.IBinary.Write(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IBinary.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.IBinary.WriteSize(System.Int32)">
            <summary>写入大小</summary>
            <param name="size">要写入的大小值</param>
            <returns>返回特性指定的固定长度，如果没有则返回-1</returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IBinaryHandler">
            <summary>二进制读写处理器接口</summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryHandlerBase">
            <summary>二进制读写处理器基类</summary>
        </member>
        <member name="T:NewLife.Serialization.AccessorAttribute">
            <summary>成员访问特性。使用自定义逻辑序列化成员</summary>
        </member>
        <member name="M:NewLife.Serialization.AccessorAttribute.Read(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>从数据流中读取消息</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.AccessorAttribute.Write(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>把消息写入到数据流中</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
        </member>
        <member name="T:NewLife.Serialization.AccessorContext">
            <summary>序列化访问上下文</summary>
        </member>
        <member name="P:NewLife.Serialization.AccessorContext.Host">
            <summary>宿主</summary>
        </member>
        <member name="P:NewLife.Serialization.AccessorContext.Type">
            <summary>对象类型</summary>
        </member>
        <member name="P:NewLife.Serialization.AccessorContext.Value">
            <summary>目标对象</summary>
        </member>
        <member name="P:NewLife.Serialization.AccessorContext.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.AccessorContext.UserState">
            <summary>用户对象。存放序列化过程中使用的用户自定义对象</summary>
        </member>
        <member name="T:NewLife.Serialization.FixedStringAttribute">
            <summary>定长字符串序列化特性</summary>
        </member>
        <member name="P:NewLife.Serialization.FixedStringAttribute.Length">
            <summary>长度</summary>
        </member>
        <member name="M:NewLife.Serialization.FixedStringAttribute.#ctor(System.Int32)">
            <summary>定长字符串序列化</summary>
            <param name="length"></param>
        </member>
        <member name="M:NewLife.Serialization.FixedStringAttribute.Read(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>从数据流中读取消息</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.FixedStringAttribute.Write(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>把消息写入到数据流中</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
        </member>
        <member name="T:NewLife.Serialization.FullStringAttribute">
            <summary>完全字符串序列化特性。指示数据流剩下部分全部作为字符串读写</summary>
        </member>
        <member name="M:NewLife.Serialization.FullStringAttribute.Read(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>从数据流中读取消息</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.FullStringAttribute.Write(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>把消息写入到数据流中</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
        </member>
        <member name="T:NewLife.Serialization.IAccessor">
            <summary>数据流序列化访问器。接口实现者可以在这里完全自定义序列化行为</summary>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Read(System.IO.Stream,System.Object)">
            <summary>从数据流中读取消息</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Write(System.IO.Stream,System.Object)">
            <summary>把消息写入到数据流中</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:NewLife.Serialization.IAccessor`1">
            <summary>自定义数据序列化访问器。数据T支持Span/Memory等，接口实现者可以在这里完全自定义序列化行为</summary>
        </member>
        <member name="M:NewLife.Serialization.IAccessor`1.Read(`0,System.Object)">
            <summary>从数据中读取消息</summary>
            <param name="data">数据</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor`1.Write(`0,System.Object)">
            <summary>把消息写入到数据中</summary>
            <param name="data">数据</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:NewLife.Serialization.AccessorHelper">
            <summary>访问器助手</summary>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.ToPacket(NewLife.Serialization.IAccessor,System.Object)">
            <summary>支持访问器的对象转数据包</summary>
            <param name="accessor">访问器</param>
            <param name="context">上下文</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.AccessorRead(System.Type,NewLife.Data.Packet,System.Object)">
            <summary>通过访问器读取</summary>
            <param name="type"></param>
            <param name="pk"></param>
            <param name="context">上下文</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.ToEntity``1(NewLife.Data.Packet,System.Object)">
            <summary>通过访问器转换数据包为实体对象</summary>
            <typeparam name="T"></typeparam>
            <param name="pk"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IFormatterX">
            <summary>序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Hosts">
            <summary>主对象</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Encoding">
            <summary>字符串编码，默认utf-8</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.UseProperty">
            <summary>序列化属性而不是字段。默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.UserState">
            <summary>用户对象。存放序列化过程中使用的用户自定义对象</summary>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="T:NewLife.Serialization.IHandler`1">
            <summary>序列化处理器接口</summary>
            <typeparam name="THost"></typeparam>
        </member>
        <member name="P:NewLife.Serialization.IHandler`1.Host">
            <summary>宿主读写器</summary>
        </member>
        <member name="P:NewLife.Serialization.IHandler`1.Priority">
            <summary>优先级</summary>
        </member>
        <member name="M:NewLife.Serialization.IHandler`1.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IHandler`1.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.FormatterBase">
            <summary>序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Stream">
            <summary>数据流。默认实例化一个内存数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Hosts">
            <summary>主对象</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Encoding">
            <summary>字符串编码，默认utf-8</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.UseProperty">
            <summary>序列化属性而不是字段。默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.UserState">
            <summary>用户对象。存放序列化过程中使用的用户自定义对象</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.GetBytes">
            <summary>获取流里面的数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.GetPacket">
            <summary>获取流里面的数据包</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Serialization.HandlerBase`2">
            <summary>读写处理器基类</summary>
        </member>
        <member name="P:NewLife.Serialization.HandlerBase`2.Host">
            <summary>宿主读写器</summary>
        </member>
        <member name="P:NewLife.Serialization.HandlerBase`2.Priority">
            <summary>优先级</summary>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Serialization.Interface.IMemberAccessor">
            <summary>成员序列化访问器。接口实现者可以在这里完全自定义序列化行为</summary>
        </member>
        <member name="M:NewLife.Serialization.Interface.IMemberAccessor.Read(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>从数据流中读取消息</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.Interface.IMemberAccessor.Write(NewLife.Serialization.IFormatterX,NewLife.Serialization.AccessorContext)">
            <summary>把消息写入到数据流中</summary>
            <param name="formatter">序列化</param>
            <param name="context">上下文</param>
        </member>
        <member name="T:NewLife.Serialization.IJson">
            <summary>IJson序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IJson.Indented">
            <summary>是否缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.IJson.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.IJson.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IJson.Write(System.Text.StringBuilder,System.Object)">
            <summary>写入</summary>
            <param name="sb"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IJson.Read(System.String)">
            <summary>读取</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJson.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IJsonHandler">
            <summary>IJson读写处理器接口</summary>
        </member>
        <member name="M:NewLife.Serialization.IJsonHandler.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="T:NewLife.Serialization.JsonHandlerBase">
            <summary>IJson读写处理器基类</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonHandlerBase.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHandlerBase.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="T:NewLife.Serialization.IJsonHost">
            <summary>Json序列化接口</summary>
            <remarks>
            文档 https://newlifex.com/core/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.IJsonHost.ServiceProvider">
            <summary>服务提供者。用于反序列化时构造内部成员对象</summary>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Write(System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否缩进。默认false</param>
            <param name="nullValue">是否写空值。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Write(System.Object,NewLife.Serialization.JsonOptions)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="jsonOptions">序列化选项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Read(System.String,System.Type)">
            <summary>从Json字符串中读取对象</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Convert(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Parse(System.String)">
            <summary>分析Json字符串得到字典或列表</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Decode(System.String)">
            <summary>分析Json字符串得到字典</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonHelper">
            <summary>Json助手</summary>
            <remarks>
            文档 https://newlifex.com/core/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.JsonHelper.Default">
            <summary>默认实现</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJson(System.Object,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否缩进</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJson(System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否换行缩进。默认false</param>
            <param name="nullValue">是否写空值。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJson(System.Object,NewLife.Serialization.JsonOptions)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="jsonOptions">序列化选项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJsonEntity(System.String,System.Type)">
            <summary>从Json字符串中读取对象</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJsonEntity``1(System.String)">
            <summary>从Json字符串中读取对象</summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Read``1(NewLife.Serialization.IJsonHost,System.String)">
            <summary>从Json字符串中反序列化对象</summary>
            <typeparam name="T"></typeparam>
            <param name="jsonHost"></param>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Format(System.String)">
            <summary>格式化Json文本</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Convert``1(System.Object)">
            <summary>Json类型对象转换实体类</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Convert``1(NewLife.Serialization.IJsonHost,System.Object)">
            <summary>Json类型对象转换实体类</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Parse(System.String)">
            <summary>分析Json字符串得到字典或列表</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.DecodeJson(System.String)">
            <summary>分析Json字符串得到字典</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.FastJson">
            <summary>轻量级FastJson序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.FastJson.ServiceProvider">
            <summary>服务提供者。用于反序列化时构造内部成员对象</summary>
        </member>
        <member name="M:NewLife.Serialization.FastJson.Write(System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否缩进。默认false</param>
            <param name="nullValue">是否写空值。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FastJson.Write(System.Object,NewLife.Serialization.JsonOptions)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="jsonOptions">序列化选项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FastJson.Read(System.String,System.Type)">
            <summary>从Json字符串中读取对象</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FastJson.Convert(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FastJson.Parse(System.String)">
            <summary>分析Json字符串得到字典或列表</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FastJson.Decode(System.String)">
            <summary>分析Json字符串得到字典</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Json">
            <summary>Json序列化</summary>
            <remarks>
            文档 https://newlifex.com/core/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.Json.Indented">
            <summary>是否缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.AddHandler(NewLife.Serialization.IJsonHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.GetHandler``1">
            <summary>获取处理器</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.Text.StringBuilder,System.Object)">
            <summary>写入</summary>
            <param name="sb"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Json.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Read(System.String)">
            <summary>读取</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonArray">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonComposite">
            <summary>复合对象处理器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonComposite.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonDictionary">
            <summary>Json序列化字典</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonDictionary.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonDictionary.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonDictionary.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonGeneral">
            <summary>Json基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonOptions">
            <summary>Json序列化选项</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonOptions.CamelCase">
            <summary>使用驼峰命名。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonOptions.IgnoreNullValues">
            <summary>忽略空值。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonOptions.IgnoreCycles">
            <summary>忽略循环引用。遇到循环引用时写{}，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonOptions.WriteIndented">
            <summary>缩进。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonOptions.FullTime">
            <summary>使用完整的时间格式。如：2022-11-29T14:13:17.8763881+08:00，默认false</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonParser">
            <summary>Json分析器</summary>
            <remarks>
            文档 https://newlifex.com/core/json
            </remarks>
        </member>
        <member name="T:NewLife.Serialization.JsonParser.Token">
            <summary>标识符</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Curly_Open">
            <summary>左大括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Curly_Close">
            <summary>右大括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Squared_Open">
            <summary>左方括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Squared_Close">
            <summary>右方括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Colon">
            <summary>冒号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Comma">
            <summary>逗号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.String">
            <summary>字符串</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Number">
            <summary>数字</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.True">
            <summary>布尔真</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.False">
            <summary>布尔真</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Comment">
            <summary>单行注释</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Comment_Open">
            <summary>多行注释开始</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Comment_Close">
            <summary>多行注释结束</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Null">
            <summary>空值</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="json"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.Decode(System.String)">
            <summary>解码</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.Decode">
            <summary>解码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.SkipToken">
            <summary>读取一个Token</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader">
            <summary>Json读取器</summary>
            <remarks>
            文档 https://newlifex.com/core/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.UseUTCDateTime">
            <summary>是否使用UTC时间</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.Provider">
            <summary>服务提供者</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Read``1(System.String)">
            <summary>读取Json到指定类型</summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Read(System.String,System.Type)">
            <summary>读取Json到指定类型</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ToObject(System.Object,System.Type,System.Object)">
            <summary>Json字典或列表转为具体类型对象</summary>
            <param name="jobj">Json对象</param>
            <param name="type">模板类型</param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseList(System.Collections.Generic.IList{System.Object},System.Type,System.Object)">
            <summary>转为泛型列表</summary>
            <param name="vlist"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseArray(System.Collections.Generic.IList{System.Object},System.Type,System.Object)">
            <summary>转为数组</summary>
            <param name="list"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Collections.IDictionary)">
            <summary>转为泛型字典</summary>
            <param name="dic"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseObject(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Object)">
            <summary>字典转复杂对象，反射属性赋值</summary>
            <param name="dic"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.CreateDateTime(System.Object)">
            <summary>创建时间</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonWriter">
            <summary>Json写入器</summary>
            <remarks>
            文档 https://newlifex.com/core/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Options">
            <summary>配置选项</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.UseUTCDateTime">
            <summary>使用UTC时间。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.LowerCase">
            <summary>使用小写名称</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.CamelCase">
            <summary>使用驼峰命名</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreNullValues">
            <summary>忽略空值。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreReadOnlyProperties">
            <summary>忽略只读属性。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreComment">
            <summary>忽略注释。默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreCycles">
            <summary>忽略循环引用。遇到循环引用时写{}，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.EnumString">
            <summary>枚举使用字符串。默认false使用数字</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Indented">
            <summary>缩进。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Int64AsString">
            <summary>长整型作为字符串序列化。避免长整型传输给前端时精度丢失，只有值真的超过前端接受范围时才会进行转换，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.ByteArrayAsHex">
            <summary>字节数组序列化为HEX。默认false，使用base64</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IndentedLength">
            <summary>缩进字符数。默认2</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.MaxDepth">
            <summary>最大序列化深度。超过时不再序列化，而不是抛出异常，默认5</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.ToJson(System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>对象序列化为Json字符串</summary>
            <param name="obj"></param>
            <param name="indented">是否缩进。默认false</param>
            <param name="nullValue">是否写控制。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.ToJson(System.Object,NewLife.Serialization.JsonOptions)">
            <summary>对象序列化为Json字符串</summary>
            <param name="obj"></param>
            <param name="jsonOptions">序列化选项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Object)">
            <summary>写入对象</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.GetString">
            <summary>获取结果</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.FormatName(System.String)">
            <summary>根据小写和驼峰格式化名称</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter._level">
            <summary>当前缩进层级</summary>
        </member>
        <member name="T:NewLife.Serialization.SerialHelper">
            <summary>序列化助手</summary>
        </member>
        <member name="M:NewLife.Serialization.SerialHelper.GetName(System.Reflection.PropertyInfo)">
            <summary>获取序列化名称</summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.SerialHelper.BuildModelClass(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>依据 Json/Xml 字典生成实体模型类</summary>
            <param name="dic"></param>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IXml">
            <summary>二进制序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IXml.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="P:NewLife.Serialization.IXml.UseComment">
            <summary>使用注释</summary>
        </member>
        <member name="M:NewLife.Serialization.IXml.Write(System.Object,System.String,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="name">名称</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IXml.GetWriter">
            <summary>获取Xml写入器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IXml.GetReader">
            <summary>获取Xml读取器</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IXmlHandler">
            <summary>二进制读写处理器接口</summary>
        </member>
        <member name="T:NewLife.Serialization.XmlHandlerBase">
            <summary>Xml读写处理器基类</summary>
        </member>
        <member name="T:NewLife.Serialization.Xml">
            <summary>Xml序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.Depth">
            <summary>深度</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.UseAttribute">
            <summary>使用特性</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.UseComment">
            <summary>使用注释</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.EnumString">
            <summary>枚举使用字符串。false时使用数字，默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.Setting">
            <summary>XML写入设置</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.CurrentName">
            <summary>当前名称</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.AddHandler(NewLife.Serialization.IXmlHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Write(System.Object,System.String,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="name">名称</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.WriteStart(System.Type)">
            <summary>写入开头</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Xml.WriteEnd">
            <summary>写入结尾</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetWriter">
            <summary>获取Xml写入器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.ReadStart(System.Type)">
            <summary>读取开始</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Xml.ReadEnd">
            <summary>读取结束</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetReader">
            <summary>获取Xml读取器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetString">
            <summary>获取字符串</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlComposite">
            <summary>Xml复合对象处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.GetMembers(System.Type)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlGeneral">
            <summary>Xml基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlList">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlList.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlList.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlList.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlParser">
            <summary>Xml解析器，得到字典和数组</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlParser.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="xml"></param>
        </member>
        <member name="M:NewLife.Serialization.XmlParser.Decode(System.String)">
            <summary>解码</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Setting">
            <summary>核心设置</summary>
            <remarks>
            文档 https://newlifex.com/core/setting
            </remarks>
        </member>
        <member name="P:NewLife.Setting.Debug">
            <summary>是否启用全局调试。默认启用</summary>
        </member>
        <member name="P:NewLife.Setting.LogLevel">
            <summary>日志等级，只输出大于等于该级别的日志，All/Debug/Info/Warn/Error/Fatal，默认Info</summary>
        </member>
        <member name="P:NewLife.Setting.LogPath">
            <summary>文件日志目录。默认Log子目录</summary>
        </member>
        <member name="P:NewLife.Setting.LogFileMaxBytes">
            <summary>日志文件上限。超过上限后拆分新日志文件，默认10MB，0表示不限制大小</summary>
        </member>
        <member name="P:NewLife.Setting.LogFileBackups">
            <summary>日志文件备份。超过备份数后，最旧的文件将被删除，网络安全法要求至少保存6个月日志，默认200，0表示不限制个数</summary>
        </member>
        <member name="P:NewLife.Setting.LogFileFormat">
            <summary>日志文件格式。默认{0:yyyy_MM_dd}.log，支持日志等级如 {1}_{0:yyyy_MM_dd}.log</summary>
        </member>
        <member name="P:NewLife.Setting.NetworkLog">
            <summary>网络日志。本地子网日志广播udp://255.255.255.255:514，或者http://xxx:80/log</summary>
        </member>
        <member name="P:NewLife.Setting.UtcIntervalHours">
            <summary>日志记录时间UTC校正，单位：小时。默认0表示使用的是本地时间，使用UTC时间的系统转换成本地时间则相差8小时</summary>
        </member>
        <member name="P:NewLife.Setting.DataPath">
            <summary>数据目录。本地数据库目录，默认Data子目录</summary>
        </member>
        <member name="P:NewLife.Setting.BackupPath">
            <summary>备份目录。备份数据库时存放的目录，默认Backup子目录</summary>
        </member>
        <member name="P:NewLife.Setting.PluginPath">
            <summary>插件目录</summary>
        </member>
        <member name="P:NewLife.Setting.PluginServer">
            <summary>插件服务器。将从该网页上根据关键字分析链接并下载插件</summary>
        </member>
        <member name="P:NewLife.Setting.AssemblyResolve">
            <summary>辅助解析程序集。程序集加载过程中，被依赖程序集未能解析时，是否协助解析，默认false</summary>
        </member>
        <member name="P:NewLife.Setting.ServiceAddress">
            <summary>服务地址。用户访问的外网地址，反向代理之外，用于内部构造其它Url（如SSO），或者向注册中心登记，多地址逗号隔开</summary>
        </member>
        <member name="M:NewLife.Setting.OnLoaded">
            <summary>加载完成后</summary>
        </member>
        <member name="M:NewLife.Setting.GetPluginPath">
            <summary>获取插件目录</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.Cron">
            <summary>轻量级Cron表达式</summary>
            <remarks>
            基本构成：秒+分+时+天+月+星期+年
            每段构成：
                * 所有可能的值，该类型片段全部可选
                , 列出枚举值
                - 范围，横杠表示的一个区间可选
                / 指定数值的增量，在上述可选数字内，间隔多少选一个
                ? 不指定值，仅日期和星期域支持该字符
                # 确定每个月第几个星期几，L表示倒数，仅星期域支持该字符
                数字，具体某个数值可选
                逗号多选，逗号分隔的多个数字或区间可选
            </remarks>
            <example>
            */2 每两秒一次
            0,1,2 * * * * 每分钟的0秒1秒2秒各一次
            5/20 * * * * 每分钟的5秒25秒45秒各一次
            * 1-10,13,25/3 * * * 每小时的1分4分7分10分13分25分，每一秒各一次
            0 0 0 1 * * 每个月1日的0点整
            0 0 2 * * 1-5 每个工作日的凌晨2点
            0 0 0 ? ? 1-7#1 每月第一周的任意一天（周一~周日）的0点整
            0 0 0 ? ? 3-5#L2 每个月倒数第二个星期三到星期五的0点整
            
            星期部分采用Linux和.NET风格，0表示周日，1表示周一。
            可设置Sunday为1，1表示周日，2表示周一。
            
            文档 https://newlifex.com/core/cron
            参考文档 https://help.aliyun.com/document_detail/64769.html
            </example>
        </member>
        <member name="P:NewLife.Threading.Cron.Seconds">
            <summary>秒数集合</summary>
        </member>
        <member name="P:NewLife.Threading.Cron.Minutes">
            <summary>分钟集合</summary>
        </member>
        <member name="P:NewLife.Threading.Cron.Hours">
            <summary>小时集合</summary>
        </member>
        <member name="P:NewLife.Threading.Cron.DaysOfMonth">
            <summary>日期集合</summary>
        </member>
        <member name="P:NewLife.Threading.Cron.Months">
            <summary>月份集合</summary>
        </member>
        <member name="P:NewLife.Threading.Cron.DaysOfWeek">
            <summary>星期集合。key是星期数，value是第几个，负数表示倒数</summary>
        </member>
        <member name="P:NewLife.Threading.Cron.Sunday">
            <summary>星期天偏移量。周日对应的数字，默认0。1表示周日时，2表示周一</summary>
        </member>
        <member name="M:NewLife.Threading.Cron.#ctor">
            <summary>实例化Cron表达式</summary>
        </member>
        <member name="M:NewLife.Threading.Cron.#ctor(System.String)">
            <summary>实例化Cron表达式</summary>
            <param name="expression"></param>
        </member>
        <member name="M:NewLife.Threading.Cron.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.Cron.IsTime(System.DateTime)">
            <summary>指定时间是否位于表达式之内</summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.Cron.Parse(System.String)">
            <summary>分析表达式</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.Cron.GetNext(System.DateTime)">
            <summary>获得指定时间之后的下一次执行时间，不含指定时间</summary>
            <remarks>
            如果指定时间带有毫秒，则向前对齐。如09:14.123的"15 * * *"下一次是10:15而不是09：15
            </remarks>
            <param name="time">从该时间秒的下一秒算起的下一个执行时间</param>
            <returns>下一次执行时间（秒级），如果没有匹配则返回最小时间</returns>
        </member>
        <member name="M:NewLife.Threading.Cron.GetPrevious(System.DateTime)">
            <summary>获得与指定时间时间符合表达式的最远时间（秒级）</summary>
            <param name="time"></param>
        </member>
        <member name="M:NewLife.Threading.Cron.GetNext(System.String[],System.DateTime)">
            <summary>对一批Cron表达式，获取下一次执行时间</summary>
            <param name="crons"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.Cron.GetPrevious(System.String[],System.DateTime)">
            <summary>对一批Cron表达式，获取前一次执行时间</summary>
            <param name="crons"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.ThreadPoolX">
            <summary>线程池助手</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Init">
            <summary>初始化线程池
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(System.Action)">
            <summary>带异常处理的线程池任务调度，不允许异常抛出，以免造成应用程序退出，同时不会捕获上下文</summary>
            <param name="callback"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem``1(System.Action{``0},``0)">
            <summary>带异常处理的线程池任务调度，不允许异常抛出，以免造成应用程序退出，同时不会捕获上下文</summary>
            <param name="callback"></param>
            <param name="state"></param>
        </member>
        <member name="T:NewLife.Threading.TimerScheduler">
            <summary>定时器调度器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Create(System.String)">
            <summary>创建指定名称的调度器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Default">
            <summary>默认调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Current">
            <summary>当前调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.GlobalTimeProvider">
            <summary>全局时间提供者。影响所有调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Count">
            <summary>定时器个数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.MaxCost">
            <summary>最大耗时。超过时报警告日志，默认500ms</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.TimeProvider">
            <summary>时间提供者。该调度器下所有绝对定时器，均从此获取当前时间</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Add(NewLife.Threading.TimerX)">
            <summary>把定时器加入队列</summary>
            <param name="timer"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Remove(NewLife.Threading.TimerX,System.String)">
            <summary>从队列删除定时器</summary>
            <param name="timer"></param>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Wake">
            <summary>唤醒处理</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Process(System.Object)">
            <summary>调度主程序</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.CheckTime(NewLife.Threading.TimerX,System.Int64)">
            <summary>检查定时器是否到期</summary>
            <param name="timer"></param>
            <param name="now"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Execute(System.Object)">
            <summary>处理每一个定时器</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.ExecuteAsync(System.Object)">
            <summary>处理每一个定时器</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.GetNow">
            <summary>获取当前时间。该调度器下所有绝对定时器，均从此获取当前时间</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Threading.TimerX">
            <summary>不可重入的定时器，支持Cron</summary>
            <remarks>
            文档 https://newlifex.com/core/timerx
            
            为了避免系统的Timer可重入的问题，差别在于本地调用完成后才开始计算时间间隔。这实际上也是经常用到的。
            
            因为挂载在静态列表上，必须从外部主动调用<see cref="M:System.IDisposable.Dispose"/>才能销毁定时器。
            但是要注意GC回收定时器实例。
            
            该定时器不能放入太多任务，否则适得其反！
            
            TimerX必须维持对象，否则Scheduler也没有维持对象时，大家很容易一起被GC回收。
            </remarks>
        </member>
        <member name="P:NewLife.Threading.TimerX.Id">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Scheduler">
            <summary>所属调度器</summary>
        </member>
        <member name="F:NewLife.Threading.TimerX.Target">
            <summary>目标对象。弱引用，使得调用方对象可以被GC回收</summary>
        </member>
        <member name="F:NewLife.Threading.TimerX.Method">
            <summary>委托方法</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.State">
            <summary>获取/设置 用户数据</summary>
        </member>
        <member name="F:NewLife.Threading.TimerX._baseTime">
            <summary>基准时间。开机时间</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.NextTick">
            <summary>下一次执行时间。开机以来嘀嗒数，无惧时间回拨问题</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.NextTime">
            <summary>获取/设置 下一次调用时间</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Timers">
            <summary>获取/设置 调用次数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Period">
            <summary>获取/设置 间隔周期。毫秒，设为0或-1则只调用一次</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Async">
            <summary>获取/设置 异步执行任务。默认false</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Absolutely">
            <summary>获取/设置 绝对精确时间执行。默认false</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Calling">
            <summary>调用中</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Cost">
            <summary>平均耗时。毫秒</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.CanExecute">
            <summary>判断任务是否执行的委托。一般跟异步配合使用，避免频繁从线程池借出线程</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Crons">
            <summary>Cron表达式，实现复杂的定时逻辑</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Cron">
            <summary>Cron表达式，实现复杂的定时逻辑</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Tracer">
            <summary>链路追踪。追踪每一次定时事件</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.TracerName">
            <summary>链路追踪名称。默认使用方法名</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Current">
            <summary>当前定时器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32,System.String)">
            <summary>实例化一个不可重入的定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="dueTime">多久之后开始。毫秒</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.Int32,System.Int32,System.String)">
            <summary>实例化一个不可重入的定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="dueTime">多久之后开始。毫秒</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.TimerCallback,System.Object,System.DateTime,System.Int32,System.String)">
            <summary>实例化一个绝对定时器，指定时刻执行，跟当前时间和SetNext无关</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="startTime">绝对开始时间</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.DateTime,System.Int32,System.String)">
            <summary>实例化一个绝对定时器，指定时刻执行，跟当前时间和SetNext无关</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="startTime">绝对开始时间</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.TimerCallback,System.Object,System.String,System.String)">
            <summary>实例化一个Cron定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="cronExpression">Cron表达式。支持多个表达式，分号分隔</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.String,System.String)">
            <summary>实例化一个Cron定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="cronExpression">Cron表达式。支持多个表达式，分号分隔</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.Dispose">
            <summary>销毁定时器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="F:NewLife.Threading.TimerX.hasSetNext">
            <summary>是否已设置下一次时间</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.SetNext(System.Int32)">
            <summary>设置下一次运行时间</summary>
            <param name="ms">小于等于0表示马上调度</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.SetAndGetNextTime">
            <summary>设置下一次执行时间，并获取间隔</summary>
            <returns>返回下一次执行的间隔时间，不能小于等于0，否则定时器被销毁</returns>
        </member>
        <member name="M:NewLife.Threading.TimerX.Change(System.TimeSpan,System.TimeSpan)">
            <summary>更改计时器的启动时间和方法调用之间的时间间隔，使用 TimeSpan 值度量时间间隔。</summary>
            <param name="dueTime">一个 TimeSpan，表示在调用构造 ITimer 时指定的回调方法之前的延迟时间量。 指定 InfiniteTimeSpan 可防止重新启动计时器。 指定 Zero 可立即重新启动计时器。</param>
            <param name="period">构造 Timer 时指定的回调方法调用之间的时间间隔。 指定 InfiniteTimeSpan 可以禁用定期终止。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.TimerX.Delay(System.Threading.TimerCallback,System.Int32)">
            <summary>延迟执行一个委托。特别要小心，很可能委托还没被执行，对象就被gc回收了</summary>
            <param name="callback"></param>
            <param name="ms"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerX.Now">
            <summary>当前时间。定时读取系统时间，避免频繁读取系统时间造成性能瓶颈</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.JwtEncodeDelegate">
            <summary>Jwt编码委托</summary>
            <param name="data"></param>
            <param name="secrect"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.JwtDecodeDelegate">
            <summary>Jwt解码委托</summary>
            <param name="data"></param>
            <param name="secrect"></param>
            <param name="signature"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.JwtBuilder">
            <summary>JSON Web Token</summary>
            <remarks>
            主要问题：
            1，JWT默认不加密，但可以加密。生成原始令牌后，可以使用该令牌再次对其进行加密。
            2，当JWT未加密时，私密数据无法通过JWT传输。
            3，JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。
            4，JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。
            5，JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。
            6，为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。
            </remarks>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Issuer">
            <summary>颁发者</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Subject">
            <summary>主体所有人。可以存放userid/roleid等，作为用户唯一标识</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Audience">
            <summary>受众</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Expire">
            <summary>有效期。默认2小时</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.NotBefore">
            <summary>生效时间，在此之前是无效的</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.IssuedAt">
            <summary>颁发时间</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Id">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Algorithm">
            <summary>算法。默认HS256</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Type">
            <summary>令牌类型。默认JWT</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Secret">
            <summary>密钥</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.Encode(System.Object)">
            <summary>编码目标对象，生成令牌</summary>
            <param name="payload"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.Parse(System.String)">
            <summary>分析令牌</summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.TryDecode(System.String,System.String@)">
            <summary>解码令牌，得到目标对象</summary>
            <param name="token"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.RegisterAlgorithm(System.String,NewLife.Web.JwtEncodeDelegate,NewLife.Web.JwtDecodeDelegate)">
            <summary>注册算法的编解码实现</summary>
            <param name="algorithm"></param>
            <param name="encode"></param>
            <param name="decode"></param>
        </member>
        <member name="T:NewLife.Web.Link">
            <summary>超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Web.Link.FullName">
            <summary>全名</summary>
        </member>
        <member name="P:NewLife.Web.Link.Url">
            <summary>超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.RawUrl">
            <summary>原始超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.Title">
            <summary>标题</summary>
        </member>
        <member name="P:NewLife.Web.Link.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Web.Link.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Web.Link.Hash">
            <summary>哈希</summary>
        </member>
        <member name="P:NewLife.Web.Link.Html">
            <summary>原始Html</summary>
        </member>
        <member name="M:NewLife.Web.Link.Parse(System.String,System.String,System.Func{NewLife.Web.Link,System.Boolean})">
            <summary>分析HTML中的链接</summary>
            <param name="html">Html文本</param>
            <param name="baseUrl">基础Url，用于生成超链接的完整Url</param>
            <param name="filter">用于基础过滤的过滤器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Link.Parse(System.String)">
            <summary>分解文件</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Link.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.PluginHelper">
            <summary>插件助手</summary>
        </member>
        <member name="P:NewLife.Web.PluginHelper.CreateClient">
            <summary>创建客户端。便于外部自定义</summary>
        </member>
        <member name="M:NewLife.Web.PluginHelper.LoadPlugin(System.String,System.String,System.String,System.String,System.String)">
            <summary>加载插件</summary>
            <param name="typeName">插件类型</param>
            <param name="disname">显示名</param>
            <param name="dll">DLL文件</param>
            <param name="linkName">链接名。要在下载页面中搜索的链接名</param>
            <param name="urls">提供下载地址的多个目标页面</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.TokenModel">
            <summary>访问令牌模型</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.AccessToken">
            <summary>访问令牌</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.TokenType">
            <summary>令牌类型</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.ExpireIn">
            <summary>过期时间。秒</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.RefreshToken">
            <summary>刷新令牌</summary>
        </member>
        <member name="T:NewLife.Web.TokenProvider">
            <summary>令牌提供者</summary>
            <remarks>
            文档 https://newlifex.com/core/token_provider
            </remarks>
        </member>
        <member name="P:NewLife.Web.TokenProvider.Key">
            <summary>密钥。签发方用私钥，验证方用公钥</summary>
        </member>
        <member name="M:NewLife.Web.TokenProvider.ReadKey(System.String,System.Boolean)">
            <summary>读取密钥</summary>
            <param name="file">文件</param>
            <param name="generate">是否生成</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.Encode(System.String,System.DateTime)">
            <summary>编码用户和有效期得到令牌</summary>
            <param name="user">用户</param>
            <param name="expire">有效期</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.Decode(System.String,System.DateTime@)">
            <summary>令牌解码得到用户和有效期</summary>
            <param name="token">令牌</param>
            <param name="expire">有效期</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.TryDecode(System.String,System.String@,System.DateTime@)">
            <summary>尝试解码令牌，即使失败，也会返回用户信息和有效时间</summary>
            <param name="token">令牌</param>
            <param name="user">用户信息</param>
            <param name="expire">有效时间</param>
            <returns>解码结果，成功或失败</returns>
        </member>
        <member name="T:NewLife.Web.UriInfo">
            <summary>资源定位。无限制解析Url地址</summary>
        </member>
        <member name="P:NewLife.Web.UriInfo.Scheme">
            <summary>协议</summary>
        </member>
        <member name="P:NewLife.Web.UriInfo.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Web.UriInfo.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Web.UriInfo.AbsolutePath">
            <summary>路径</summary>
        </member>
        <member name="P:NewLife.Web.UriInfo.Query">
            <summary>查询</summary>
        </member>
        <member name="P:NewLife.Web.UriInfo.PathAndQuery">
            <summary>路径与查询</summary>
        </member>
        <member name="M:NewLife.Web.UriInfo.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="value"></param>
        </member>
        <member name="P:NewLife.Web.UriInfo.Authority">
            <summary>主机与端口。省略默认端口</summary>
        </member>
        <member name="M:NewLife.Web.UriInfo.Parse(System.String)">
            <summary>解析Url字符串</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Web.UriInfo.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.WebClientX">
            <summary>扩展的Web客户端</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Timeout">
            <summary>超时，默认30000毫秒</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.AuthKey">
            <summary>验证密钥。适配CDN的URL验证，在url后面增加auth_key={timestamp-rand-uid-md5hash}</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.LastLink">
            <summary>最后使用的连接名</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.EnsureCreate">
            <summary>创建客户端会话</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.SendAsync(System.String,System.Net.Http.HttpContent)">
            <summary>发送请求，获取响应</summary>
            <param name="address"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadStringAsync(System.String)">
            <summary>下载字符串</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadFileAsync(System.String,System.String)">
            <summary>下载文件</summary>
            <param name="address"></param>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetHtml(System.String)">
            <summary>获取指定地址的Html，自动处理文本编码</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetLinks(System.String)">
            <summary>获取指定地址的Html，分析所有超链接</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadLink(System.String,System.String,System.String)">
            <summary>分析指定页面指定名称的链接，并下载到目标目录，返回目标文件</summary>
            <remarks>
            根据版本或时间降序排序选择
            </remarks>
            <param name="urls">指定页面</param>
            <param name="name">页面上指定名称的链接</param>
            <param name="destdir">要下载到的目标目录</param>
            <returns>返回已下载的文件，无效时返回空</returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadLinkAndExtract(System.String,System.String,System.String,System.Boolean)">
            <summary>分析指定页面指定名称的链接，并下载到目标目录，解压Zip后返回目标文件</summary>
            <param name="urls">提供下载地址的多个目标页面</param>
            <param name="name">页面上指定名称的链接</param>
            <param name="destdir">要下载到的目标目录</param>
            <param name="overwrite">是否覆盖目标同名文件</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.WebClientX.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Windows.ConsoleHelper">
            <summary>
            控制台帮助类，用于控制控制台的快速编辑、关闭按钮。
            </summary>
        </member>
        <member name="M:NewLife.Windows.ConsoleHelper.DisableQuickEditMode">
            <summary>
            退出编辑模式
            </summary>
        </member>
        <member name="M:NewLife.Windows.ConsoleHelper.DisableCloseButton(System.String)">
            <summary>
            禁用关闭按钮
            </summary>
            <param name="cmdTitle">控制台标题，程序名称</param>
        </member>
        <member name="M:NewLife.Windows.ConsoleHelper.DisableCloseButton(System.IntPtr)">
            <summary>
            禁用关闭按钮
            </summary>
            <param name="windowHandle">窗口句柄</param>
        </member>
        <member name="M:NewLife.Windows.ConsoleHelper.CloseConsole(System.Object,System.ConsoleCancelEventArgs)">
            <summary>
            关闭控制台
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:NewLife.Windows.PowerLineStatus">
            <summary>系统电源状态</summary>
        </member>
        <member name="F:NewLife.Windows.PowerLineStatus.Offline">
            <summary>脱机状态</summary>
        </member>
        <member name="F:NewLife.Windows.PowerLineStatus.Online">
            <summary>联机状态</summary>
        </member>
        <member name="F:NewLife.Windows.PowerLineStatus.Unknown">
            <summary>电源状态未知</summary>
        </member>
        <member name="T:NewLife.Windows.BatteryChargeStatus">
            <summary>充电状态信息</summary>
        </member>
        <member name="F:NewLife.Windows.BatteryChargeStatus.High">
            <summary>指示电池能量级别较高</summary>
        </member>
        <member name="F:NewLife.Windows.BatteryChargeStatus.Low">
            <summary>指示电池能量级别较低</summary>
        </member>
        <member name="F:NewLife.Windows.BatteryChargeStatus.Critical">
            <summary>指示电池能量严重不足</summary>
        </member>
        <member name="F:NewLife.Windows.BatteryChargeStatus.Charging">
            <summary>指示电池正在充电</summary>
        </member>
        <member name="F:NewLife.Windows.BatteryChargeStatus.NoSystemBattery">
            <summary>指示没有电池存在</summary>
        </member>
        <member name="F:NewLife.Windows.BatteryChargeStatus.Unknown">
            <summary>指示未知电池状态</summary>
        </member>
        <member name="T:NewLife.Windows.PowerStatus">
            <summary>电源状态</summary>
        </member>
        <member name="P:NewLife.Windows.PowerStatus.PowerLineStatus">
            <summary>当前的系统电源状态</summary>
        </member>
        <member name="P:NewLife.Windows.PowerStatus.BatteryChargeStatus">
            <summary>当前的电池电量状态</summary>
        </member>
        <member name="P:NewLife.Windows.PowerStatus.BatteryFullLifetime">
            <summary>报告的主电池电源的完全充电寿命（以秒为单位）</summary>
        </member>
        <member name="P:NewLife.Windows.PowerStatus.BatteryLifePercent">
            <summary>电池剩余电量的近似量</summary>
        </member>
        <member name="P:NewLife.Windows.PowerStatus.BatteryLifeRemaining">
            <summary>电池的剩余使用时间的近似秒数</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfig`1">
            <summary>Xml配置文件基类</summary>
            <remarks>
            标准用法：TConfig.Current
            
            配置实体类通过<see cref="T:NewLife.Xml.XmlConfigFileAttribute"/>特性指定配置文件路径以及自动更新时间。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            
            考虑到自动刷新，不提供LoadFile和SaveFile等方法，可通过扩展方法ToXmlFileEntity和ToXmlFile实现。
            
            用户也可以通过配置实体类的静态构造函数修改基类的<see cref="P:NewLife.Xml.XmlConfig`1._.ConfigFile"/>和<see cref="P:NewLife.Xml.XmlConfig`1._.ReloadTime"/>来动态配置加载信息。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfig`1._">
            <summary>一些设置。派生类可以在自己的静态构造函数中指定</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ConfigFile">
            <summary>配置文件路径</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.SaveNew">
            <summary>没有配置文件时是否保存新配置。默认true</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.ConfigFile">
            <summary>配置文件</summary>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.lastWrite">
            <summary>最后写入时间</summary>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.expire">
            <summary>过期时间。如果在这个时间之后再次访问，将检查文件修改时间</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.IsUpdated">
            <summary>是否已更新。通过文件写入时间判断</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.SetExpire">
            <summary>设置过期重新加载配置的时间</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Load(System.String)">
            <summary>加载指定配置文件</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Save(System.String)">
            <summary>保存到配置文件中去</summary>
            <param name="filename"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnSaving(System.String,System.String,System.String)">
            <summary>
            在持久化配置文件时执行
            如果重写该方法 请注意调用父类 以免造成配置文件不能正常持久化。
            </summary>
            <param name="filename">配置文件全路径</param>
            <param name="oldXml">老配置文件的内容</param>
            <param name="newXml">新配置文件的内容</param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.SaveAsync">
            <summary>异步保存</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnNew">
            <summary>新创建配置文件时执行</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfigFileAttribute">
            <summary>Xml配置文件特性</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.FileName">
            <summary>配置文件名</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String)">
            <summary>指定配置文件名</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String,System.Int32)">
            <summary>指定配置文件名和重新加载时间（毫秒）</summary>
            <param name="fileName"></param>
            <param name="reloadTime"></param>
        </member>
        <member name="T:NewLife.Xml.XmlHelper">
            <summary>Xml辅助类</summary>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.Text.Encoding,System.Boolean,System.Boolean)">
            <summary>序列化为Xml字符串</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <param name="useAttribute">是否使用特性输出</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.Text.Encoding,System.Boolean,System.Boolean,System.Boolean)">
            <summary>序列化为Xml字符串</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <param name="useAttribute">是否使用特性输出</param>
            <param name="omitXmlDeclaration">忽略XML声明</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)">
            <summary>序列化为Xml数据流</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="stream">目标数据流</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <param name="useAttribute">是否使用特性输出</param>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFile(System.Object,System.String,System.Text.Encoding,System.Boolean)">
            <summary>序列化为Xml文件</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="file">目标Xml文件</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.String)">
            <summary>字符串转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="xml">Xml字符串</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.String,System.Type)">
            <summary>字符串转为Xml实体对象</summary>
            <param name="xml">Xml字符串</param>
            <param name="type">实体类型</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.IO.Stream,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="stream">数据流</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.IO.Stream,System.Type,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <param name="stream">数据流</param>
            <param name="type">实体类型</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFileEntity``1(System.String,System.Text.Encoding)">
            <summary>Xml文件转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="file">Xml文件</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlDictionary(System.String)">
            <summary>简单Xml转为字符串字典</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>字符串字典转为Xml</summary>
            <param name="dic"></param>
            <param name="rootName"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Yun.OssClient">
            <summary>阿里云文件存储</summary>
            <remarks>
            文档 https://newlifex.com/core/oss
            </remarks>
        </member>
        <member name="P:NewLife.Yun.OssClient.Server">
            <summary>访问域名。Endpoint</summary>
        </member>
        <member name="P:NewLife.Yun.OssClient.AppId">
            <summary>访问密钥。AccessKeyId</summary>
        </member>
        <member name="P:NewLife.Yun.OssClient.Secret">
            <summary>访问密钥。AccessKeySecret</summary>
        </member>
        <member name="P:NewLife.Yun.OssClient.BucketName">
            <summary>存储空间</summary>
        </member>
        <member name="P:NewLife.Yun.OssClient.CanGetUrl">
            <summary>是否支持获取文件直接访问Url</summary>
        </member>
        <member name="P:NewLife.Yun.OssClient.CanDelete">
            <summary>是否支持删除</summary>
        </member>
        <member name="P:NewLife.Yun.OssClient.CanSearch">
            <summary>是否支持搜索</summary>
        </member>
        <member name="M:NewLife.Yun.OssClient.InvokeAsync``1(System.Net.Http.HttpMethod,System.String,System.Object)">
            <summary>异步调用命令</summary>
            <param name="method"></param>
            <param name="action"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.ListBuckets">
            <summary>列出所有存储空间名称</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.ListBuckets(System.String,System.String,System.Int32)">
            <summary>列出所有存储空间明细，支持过滤</summary>
            <param name="prefix"></param>
            <param name="marker"></param>
            <param name="maxKeys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.ListObjects">
            <summary>列出所有文件名称</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.ListObjects(System.String,System.String,System.Int32)">
            <summary>列出所有文件明细，支持过滤</summary>
            <param name="prefix"></param>
            <param name="marker"></param>
            <param name="maxKeys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.Put(System.String,NewLife.Data.Packet)">
            <summary>上传文件</summary>
            <param name="objectName">对象文件名</param>
            <param name="data">数据内容</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.Get(System.String)">
            <summary>获取文件</summary>
            <param name="objectName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.GetUrl(System.String)">
            <summary>获取文件直接访问Url</summary>
            <param name="id">对象文件名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.Delete(System.String)">
            <summary>删除文件</summary>
            <param name="objectName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.OssClient.Search(System.String,System.Int32,System.Int32)">
            <summary>搜索文件</summary>
            <param name="pattern">匹配模式。如/202304/*.jpg</param>
            <param name="start">开始序号。0开始</param>
            <param name="count">最大个数</param>
            <returns></returns>
        </member>
        <member name="T:System.Collections.Generic.CollectionHelper">
            <summary>集合扩展</summary>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>集合转为数组，加锁确保安全</summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToKeyArray``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32)">
            <summary>集合转为数组</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToValueArray``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32)">
            <summary>集合转为数组</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToDictionary(System.Object)">
            <summary>目标匿名参数对象转为名值字典</summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.Merge(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object,System.Boolean,System.String[])">
            <summary>合并字典参数</summary>
            <param name="dic">字典</param>
            <param name="target">目标对象</param>
            <param name="overwrite">是否覆盖同名参数</param>
            <param name="excludes">排除项</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToNullable``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>转为可空字典</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.Take``1(System.Collections.Generic.Queue{``0},System.Int32)">
            <summary>从队列里面获取指定个数元素</summary>
            <typeparam name="T"></typeparam>
            <param name="collection">消费集合</param>
            <param name="count">元素个数</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.Take``1(System.Collections.Concurrent.IProducerConsumerCollection{``0},System.Int32)">
            <summary>从消费集合里面获取指定个数元素</summary>
            <typeparam name="T"></typeparam>
            <param name="collection">消费集合</param>
            <param name="count">元素个数</param>
            <returns></returns>
        </member>
        <member name="T:System.Collections.Generic.ListExtension">
            <summary>扩展List，支持遍历中修改元素</summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtension.Find``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>线程安全，搜索并返回第一个，支持遍历中修改元素</summary>
            <param name="list">实体列表</param>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtension.FindAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>线程安全，搜索并返回第一个，支持遍历中修改元素</summary>
            <param name="list">实体列表</param>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="T:System.Index">
            <summary></summary>
        </member>
        <member name="F:System.Index._value">
            <summary></summary>
        </member>
        <member name="P:System.Index.Start">
            <summary></summary>
        </member>
        <member name="P:System.Index.End">
            <summary></summary>
        </member>
        <member name="P:System.Index.Value">
            <summary></summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary></summary>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary></summary>
            <param name="value"></param>
            <param name="fromEnd"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary></summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary></summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary></summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary></summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary></summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary></summary>
            <param name="value"></param>
        </member>
        <member name="M:System.Index.ToString">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="T:System.Range">
            <summary></summary>
        </member>
        <member name="P:System.Range.Start">
            <summary></summary>
        </member>
        <member name="P:System.Range.End">
            <summary></summary>
        </member>
        <member name="P:System.Range.All">
            <summary></summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary></summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary></summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary></summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:System.Range.ToString">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary></summary>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary></summary>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary></summary>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:System.TimeProvider">
            <summary>提供时间的抽象</summary>
        </member>
        <member name="P:System.TimeProvider.System">
            <summary>获取一个 TimeProvider ，它提供基于 UtcNow的时钟、基于 的 Local时区、基于 的 Stopwatch高性能时间戳和基于 的 Timer计时器。</summary>
        </member>
        <member name="P:System.TimeProvider.LocalTimeZone">
            <summary>根据此 TimeProvider的时间概念获取本地时区。</summary>
        </member>
        <member name="P:System.TimeProvider.TimestampFrequency">
            <summary>获取 的频率 GetTimestamp() 作为每秒时钟周期数。</summary>
        </member>
        <member name="M:System.TimeProvider.GetUtcNow">
            <summary>根据此 TimeProvider的时间概念，获取当前协调世界时 (UTC) 日期和时间，偏移量为零。</summary>
            <returns></returns>
        </member>
        <member name="M:System.TimeProvider.GetLocalNow">
            <summary>根据基于 TimeProvider的时间概念 GetUtcNow()获取当前日期和时间，偏移量设置为 LocalTimeZone与协调世界时 (UTC) 的偏移量。</summary>
            <returns></returns>
        </member>
        <member name="M:System.TimeProvider.GetTimestamp">
            <summary>获取当前高频值，该值旨在测量计时器机制中精度较高的小时间间隔。</summary>
            <returns></returns>
        </member>
        <member name="M:System.TimeProvider.GetElapsedTime(System.Int64,System.Int64)">
            <summary>获取使用 GetTimestamp()检索到的两个时间戳之间的已用时间。</summary>
            <param name="startingTimestamp"></param>
            <param name="endingTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimeProvider.GetElapsedTime(System.Int64)">
            <summary>获取自使用 GetTimestamp()检索值以来startingTimestamp的运行时间。</summary>
            <param name="startingTimestamp"></param>
            <returns></returns>
        </member>
        <member name="T:System.Utility">
            <summary>工具类</summary>
            <remarks>
            文档 https://newlifex.com/core/utility
            
            采用静态架构，允许外部重载工具类的各种实现<seealso cref="T:System.DefaultConvert"/>。
            所有类型转换均支持默认值，默认值为该default(T)，在转换失败时返回默认值。
            </remarks>
        </member>
        <member name="P:System.Utility.Convert">
            <summary>类型转换提供者</summary>
            <remarks>重载默认提供者<seealso cref="T:System.DefaultConvert"/>并赋值给<see cref="P:System.Utility.Convert"/>可改变所有类型转换的行为</remarks>
        </member>
        <member name="M:System.Utility.ToInt(System.Object,System.Int32)">
            <summary>转为整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix秒不转UTC）</summary>
            <remarks>Int16/UInt32/Int64等，可以先转为最常用的Int32后再二次处理</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToLong(System.Object,System.Int64)">
            <summary>转为长整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix毫秒不转UTC）</summary>
            <remarks></remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDouble(System.Object,System.Double)">
            <summary>转为浮点数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）</summary>
            <remarks>Single可以先转为最常用的Double后再二次处理</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDecimal(System.Object,System.Decimal)">
            <summary>转为高精度浮点数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）</summary>
            <remarks>Single可以先转为最常用的Double后再二次处理</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToBoolean(System.Object,System.Boolean)">
            <summary>转为布尔型，转换失败时返回默认值。支持大小写True/False、0和非零</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTime(System.Object)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒不考虑UTC转本地）</summary>
            <remarks>
            整数转时间日期时，取1970-01-01加上指定秒数，不考虑UTC时间和本地时间。
            长整数转时间日期时，取1970-01-01加上指定毫秒数，不考虑UTC时间和本地时间。
            在网络中传输时间日期时，特别是物联网设备到云平台的通信，一般取客户端本地UTC时间，转为长整型传输，服务端再转为本地时间。
            因为设备和服务端可能不在同一时区，甚至多个设备也没有处于同一个时区。
            </remarks>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTime(System.Object,System.DateTime)">
            <summary>转为时间日期，转换失败时返回默认值。支持字符串、整数（Unix秒不考虑UTC转本地）</summary>
            <remarks>
            整数转时间日期时，取1970-01-01加上指定秒数，不考虑UTC时间和本地时间。
            长整数转时间日期时，取1970-01-01加上指定毫秒数，不考虑UTC时间和本地时间。
            在网络中传输时间日期时，特别是物联网设备到云平台的通信，一般取客户端本地UTC时间，转为长整型传输，服务端再转为本地时间。
            因为设备和服务端可能不在同一时区，甚至多个设备也没有处于同一个时区。
            
            <see cref="F:System.DateTime.MinValue"/>不是常量无法做默认值。
            </remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTimeOffset(System.Object)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTimeOffset(System.Object,System.DateTimeOffset)">
            <summary>转为时间日期，转换失败时返回默认值</summary>
            <remarks><see cref="F:System.DateTimeOffset.MinValue"/>不是常量无法做默认值</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.Trim(System.DateTime,System.String)">
            <summary>去掉时间日期秒后面部分，可指定毫秒ms、分m、小时h</summary>
            <param name="value">时间日期</param>
            <param name="format">格式字符串，默认s格式化到秒，ms格式化到毫秒</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.Trim(System.DateTimeOffset,System.String)">
            <summary>去掉时间日期秒后面部分，可指定毫秒</summary>
            <param name="value">时间日期</param>
            <param name="format">格式字符串，默认s格式化到秒，ms格式化到毫秒</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTime)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串，对UTC时间加后缀</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTime,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串，支持指定最小时间的字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时（DateTime.MinValue）显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTime,System.Boolean,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss.fff完整字符串，支持指定最小时间的字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <param name="useMillisecond">是否使用毫秒</param>
            <param name="emptyValue">字符串空值时（DateTime.MinValue）显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTimeOffset,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss +08:00完整字符串，支持指定最小时间的字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时（DateTimeOffset.MinValue）显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTimeOffset,System.Boolean,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss.fff +08:00完整字符串，支持指定最小时间的字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <param name="useMillisecond">是否使用毫秒</param>
            <param name="emptyValue">字符串空值时（DateTimeOffset.MinValue）显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToString(System.DateTime,System.String,System.String)">
            <summary>时间日期转为指定格式字符串</summary>
            <param name="value">待转换对象</param>
            <param name="format">格式化字符串</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToGMK(System.UInt64,System.String)">
            <summary>字节单位字符串</summary>
            <param name="value">数值</param>
            <param name="format">格式化字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToGMK(System.Int64,System.String)">
            <summary>字节单位字符串</summary>
            <param name="value">数值</param>
            <param name="format">格式化字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.GetTrue(System.Exception)">
            <summary>获取内部真实异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.GetMessage(System.Exception)">
            <summary>获取异常消息</summary>
            <param name="ex">异常</param>
            <returns></returns>
        </member>
        <member name="T:System.DefaultConvert">
            <summary>默认转换</summary>
        </member>
        <member name="M:System.DefaultConvert.ToInt(System.Object,System.Int32)">
            <summary>转为整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToLong(System.Object,System.Int64)">
            <summary>转为长整数。支持字符串、全角、字节数组（小端）、时间（Unix毫秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDouble(System.Object,System.Double)">
            <summary>转为浮点数</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDecimal(System.Object,System.Decimal)">
            <summary>转为高精度浮点数</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToBoolean(System.Object,System.Boolean)">
            <summary>转为布尔型。支持大小写True/False、0和非零</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDateTime(System.Object,System.DateTime)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
            <remarks>
            整数（Unix秒）转换后不包含时区信息，需要调用.ToLocalTime()来转换为当前时区时间
            </remarks>
        </member>
        <member name="M:System.DefaultConvert.ToDateTimeOffset(System.Object,System.DateTimeOffset)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDBC(System.String)">
            <summary>全角为半角</summary>
            <remarks>全角半角的关系是相差0xFEE0</remarks>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.Trim(System.DateTime,System.String)">
            <summary>去掉时间日期秒后面部分，可指定毫秒ms、分m、小时h</summary>
            <param name="value">时间日期</param>
            <param name="format">格式字符串，默认s格式化到秒，ms格式化到毫秒</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToFullString(System.DateTime,System.Boolean,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串</summary>
            <param name="value">待转换对象</param>
            <param name="useMillisecond">是否使用毫秒</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToFullString(System.DateTimeOffset,System.Boolean,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串</summary>
            <param name="value">待转换对象</param>
            <param name="useMillisecond">是否使用毫秒</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToString(System.DateTime,System.String,System.String)">
            <summary>时间日期转为指定格式字符串</summary>
            <param name="value">待转换对象</param>
            <param name="format">格式化字符串</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.GetTrue(System.Exception)">
            <summary>获取内部真实异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.GetMessage(System.Exception)">
            <summary>获取异常消息</summary>
            <param name="ex">异常</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToGMK(System.UInt64,System.String)">
            <summary>字节单位字符串</summary>
            <param name="value">数值</param>
            <param name="format">格式化字符串</param>
            <returns></returns>
        </member>
        <member name="T:System.ConcurrentDictionaryExtensions">
            <summary>并发字典扩展</summary>
        </member>
        <member name="M:System.ConcurrentDictionaryExtensions.Remove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>从并发字典中删除</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:System.IO.PathHelper">
            <summary>路径操作帮助</summary>
            <remarks>
            文档 https://newlifex.com/core/path_helper
            
            GetBasePath 依赖BasePath，支持参数和环境变量设置，主要用于存放X组件自身配置和日志等目录。
            GetFullPath 依赖BaseDirectory，默认为应用程序域基础目录，支持参数和环境变量设置，此时跟GetBasePath保持一致。
            
            GetFullPath更多用于表示当前工作目录，不可以轻易修改为Environment.CurrentDirectory。
            在vs运行应用时，Environment.CurrentDirectory是源码文件所在目录，而不是可执行文件目录。
            在StarAgent运行应用时，BasePath和Environment.CurrentDirectory都被修改为工作目录。
            </remarks>
        </member>
        <member name="P:System.IO.PathHelper.BasePath">
            <summary>基础目录。GetBasePath依赖于此，默认为当前应用程序域基础目录。用于X组件内部各目录，专门为函数计算而定制</summary>
            <remarks>
            为了适应函数计算，该路径将支持从命令行参数和环境变量读取
            </remarks>
        </member>
        <member name="P:System.IO.PathHelper.BaseDirectory">
            <summary>基准目录。GetFullPath依赖于此，默认为当前应用程序域基础目录。支持BasePath参数修改</summary>
            <remarks>
            为了适应函数计算，该路径将支持从命令行参数和环境变量读取
            </remarks>
        </member>
        <member name="M:System.IO.PathHelper.GetFullPath(System.String)">
            <summary>获取文件或目录基于应用程序域基目录的全路径，过滤相对目录</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetBasePath(System.String)">
            <summary>获取文件或目录的全路径，过滤相对目录。用于X组件内部各目录，专门为函数计算而定制</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetCurrentPath(System.String)">
            <summary>获取文件或目录基于当前目录的全路径，过滤相对目录</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.EnsureDirectory(System.String,System.Boolean)">
            <summary>确保目录存在，若不存在则创建</summary>
            <remarks>
            斜杠结尾的路径一定是目录，无视第二参数；
            默认是文件，这样子只需要确保上一层目录存在即可，否则如果把文件当成了目录，目录的创建会导致文件无法创建。
            </remarks>
            <param name="path">文件路径或目录路径，斜杠结尾的路径一定是目录，无视第二参数</param>
            <param name="isfile">该路径是否是否文件路径。文件路径需要取目录部分</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CombinePath(System.String,System.String[])">
            <summary>合并多段路径</summary>
            <param name="path"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.AsFile(System.String)">
            <summary>文件路径作为文件信息</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.ReadBytes(System.IO.FileInfo,System.Int32,System.Int32)">
            <summary>从文件中读取数据</summary>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.WriteBytes(System.IO.FileInfo,System.Byte[],System.Int32)">
            <summary>把数据写入文件指定位置</summary>
            <param name="file"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyToIfNewer(System.IO.FileInfo,System.String)">
            <summary>复制到目标文件，目标文件必须已存在，且源文件较新</summary>
            <param name="fi">源文件</param>
            <param name="destFileName">目标文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.OpenRead(System.IO.FileInfo,System.Boolean,System.Action{System.IO.Stream})">
            <summary>打开并读取</summary>
            <param name="file">文件信息</param>
            <param name="compressed">是否压缩</param>
            <param name="func">要对文件流操作的委托</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.OpenWrite(System.IO.FileInfo,System.Boolean,System.Action{System.IO.Stream})">
            <summary>打开并写入</summary>
            <param name="file">文件信息</param>
            <param name="compressed">是否压缩</param>
            <param name="func">要对文件流操作的委托</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.Extract(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>解压缩</summary>
            <param name="fi"></param>
            <param name="destDir"></param>
            <param name="overwrite">是否覆盖目标同名文件</param>
        </member>
        <member name="M:System.IO.PathHelper.Compress(System.IO.FileInfo,System.String)">
            <summary>压缩文件</summary>
            <param name="fi"></param>
            <param name="destFile"></param>
        </member>
        <member name="M:System.IO.PathHelper.AsDirectory(System.String)">
            <summary>路径作为目录信息</summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetAllFiles(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>获取目录内所有符合条件的文件，支持多文件扩展匹配</summary>
            <param name="di">目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyTo(System.IO.DirectoryInfo,System.String,System.String,System.Boolean,System.Action{System.String})">
            <summary>复制目录中的文件</summary>
            <param name="di">源目录</param>
            <param name="destDirName">目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <param name="callback">复制每一个文件之前的回调</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyToIfNewer(System.IO.DirectoryInfo,System.String,System.String,System.Boolean,System.Action{System.String})">
            <summary>对比源目录和目标目录，复制双方都存在且源目录较新的文件</summary>
            <param name="di">源目录</param>
            <param name="destDirName">目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <param name="callback">复制每一个文件之前的回调</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyIfNewer(System.IO.DirectoryInfo,System.String[],System.String,System.Boolean)">
            <summary>从多个目标目录复制较新文件到当前目录</summary>
            <param name="di">当前目录</param>
            <param name="source">多个目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.Compress(System.IO.DirectoryInfo,System.String)">
            <summary>压缩</summary>
            <param name="di"></param>
            <param name="destFile"></param>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>保留供编译器用于跟踪元数据。 开发人员不应在源代码中使用此类。</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>返回可能为空</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>当返回指定值时可能为空</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>返回值</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>实例化</summary>
            <param name="returnValue"></param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>执行方法后指定成员不为空</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>不为空的成员</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>成员不为空</summary>
            <param name="member"></param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>成员不为空</summary>
            <param name="members"></param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>执行方法后指定成员不为空（带条件）</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>返回值</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>不为空的成员</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>成员不为空</summary>
            <param name="returnValue"></param>
            <param name="member"></param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>成员不为空</summary>
            <param name="returnValue"></param>
            <param name="members"></param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>不为空</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>指定参数不为空时返回也不为空</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>指定参数</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="parameterName"></param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>指定在方法返回 ReturnValue 时，即使相应的类型允许，参数也不会为 null。</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>获取返回值条件。</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>使用指定的返回值条件初始化属性。</summary>
            <param name="returnValue"></param>
        </member>
        <member name="T:System.Web.Script.Serialization.ScriptIgnoreAttribute">
            <summary>忽略Json序列化</summary>
        </member>
        <member name="T:System.Threading.ITimer">
            <summary>表示可以更改其到期时间和时间段的计时器。</summary>
        </member>
        <member name="M:System.Threading.ITimer.Change(System.TimeSpan,System.TimeSpan)">
            <summary>更改计时器的启动时间和方法调用之间的时间间隔，使用 TimeSpan 值度量时间间隔。</summary>
            <param name="dueTime">一个 TimeSpan，表示在调用构造 ITimer 时指定的回调方法之前的延迟时间量。 指定 InfiniteTimeSpan 可防止重新启动计时器。 指定 Zero 可立即重新启动计时器。</param>
            <param name="period">构造 Timer 时指定的回调方法调用之间的时间间隔。 指定 InfiniteTimeSpan 可以禁用定期终止。</param>
            <returns></returns>
        </member>
        <member name="T:System.Windows.Forms.ControlHelper">
            <summary>控件助手</summary>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Invoke(System.Windows.Forms.Control,System.Action)">
            <summary>执行无参委托</summary>
            <param name="control"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Invoke``1(System.Windows.Forms.Control,System.Action{``0},``0)">
            <summary>执行单一参数无返回值的委托</summary>
            <typeparam name="T"></typeparam>
            <param name="control"></param>
            <param name="method"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Invoke``2(System.Windows.Forms.Control,System.Action{``0,``1},``0,``1)">
            <summary>执行二参数无返回值的委托</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="control"></param>
            <param name="method"></param>
            <param name="arg"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Append(System.Windows.Forms.TextBoxBase,System.String,System.Int32)">
            <summary>附加文本到文本控件末尾。主要解决非UI线程以及滚动控件等问题</summary>
            <param name="txt">控件</param>
            <param name="msg">消息</param>
            <param name="maxLines">最大行数。超过该行数讲清空控件</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Scroll(System.Windows.Forms.TextBoxBase,System.Boolean)">
            <summary>滚动控件的滚动条</summary>
            <param name="txt">指定控件</param>
            <param name="bottom">是否底端，或者顶端</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.ProcessReturn(System.Windows.Forms.TextBoxBase,System.String@)">
            <summary>处理回车，移到行首</summary>
            <param name="txt"></param>
            <param name="m"></param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.SetDefaultStyle(System.Windows.Forms.Control,System.Int32)">
            <summary>设置默认样式，包括字体、前景色、背景色</summary>
            <param name="control">控件</param>
            <param name="size">字体大小</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.SetFontSize(System.Windows.Forms.Control,System.Int32)">
            <summary>设置字体大小</summary>
            <param name="control"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.ColourDefault(System.Windows.Forms.RichTextBox,System.Int32)">
            <summary>采用默认着色方案进行着色</summary>
            <param name="rtb">文本控件</param>
            <param name="start">开始位置</param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.ChangeCppColor(System.Windows.Forms.RichTextBox,System.Int32)">
            <summary>改变C++类名方法名颜色</summary>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Colour(System.Windows.Forms.RichTextBox,System.Text.RegularExpressions.Regex,System.Int32,System.Drawing.Color[])">
            <summary>着色文本控件的内容</summary>
            <param name="rtb">文本控件</param>
            <param name="reg">正则表达式</param>
            <param name="start">开始位置</param>
            <param name="colors">颜色数组</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Colour(System.Windows.Forms.RichTextBox,System.String,System.Int32,System.Drawing.Color[])">
            <summary>着色文本控件的内容</summary>
            <param name="rtb">文本控件</param>
            <param name="reg">正则表达式</param>
            <param name="start">开始位置</param>
            <param name="colors">颜色数组</param>
            <returns></returns>
        </member>
        <member name="P:System.Windows.Forms.ControlHelper.Dpi">
            <summary>当前Dpi</summary>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.FixDpi(System.Windows.Forms.ListView)">
            <summary>修正ListView的Dpi</summary>
            <param name="lv"></param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.FixDpi(System.Windows.Forms.Form)">
            <summary>修正窗体的Dpi</summary>
            <param name="frm"></param>
        </member>
        <member name="T:SM4">
            <summary>SM4（国密4）</summary>
        </member>
        <member name="M:SM4.Create">
            <summary>实例化SM4</summary>
        </member>
        <member name="M:SM4.#ctor">
            <summary>实例化SM4</summary>
        </member>
        <member name="M:SM4.GenerateIV">
            <summary>生成IV</summary>
        </member>
        <member name="M:SM4.GenerateKey">
            <summary>生成密钥</summary>
        </member>
        <member name="M:SM4.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>生成加密器</summary>
            <param name="key"></param>
            <param name="iv"></param>
            <returns></returns>
        </member>
        <member name="M:SM4.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>生成解密器</summary>
            <param name="key"></param>
            <param name="iv"></param>
            <returns></returns>
        </member>
        <member name="T:SM4Transform">
            <summary>SM4无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。</summary>
            <remarks>
            我国国家密码管理局在20012年公布了无线局域网产品使用的SM4密码算法——商用密码算法。
            它是分组算法当中的一种，算法特点是设计简沽，结构有特点，安全高效。
            数据分组长度为128比特，密钥长度为128 比特。加密算法与密钥扩展算法都采用32轮迭代结构。
            SM4密码算法以字节(8位)和字(32位)作为单位进行数据处理。
            SM4密码算法是对合运算，因此解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。
            </remarks>
        </member>
        <member name="F:SM4Transform.rk">
            <summary>roundKeys</summary>
        </member>
        <member name="P:SM4Transform.CanReuseTransform">
            <summary>获取一个值，该值指示是否可重复使用当前转换。</summary>
        </member>
        <member name="P:SM4Transform.CanTransformMultipleBlocks">
            <summary>获取一个值，该值指示是否可以转换多个块。</summary>
        </member>
        <member name="P:SM4Transform.InputBlockSize">
            <summary>获取输入块大小。</summary>
        </member>
        <member name="P:SM4Transform.OutputBlockSize">
            <summary>获取输出块大小。</summary>
        </member>
        <member name="M:SM4Transform.#ctor(System.Byte[],System.Byte[],System.Boolean)">
            <summary>实例化转换器</summary>
            <param name="key"></param>
            <param name="iv"></param>
            <param name="encryptMode"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:SM4Transform.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:SM4Transform.EncryptData(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>块加密数据，传入缓冲区必须是整块数据</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="outputBuffer"></param>
            <param name="outputOffset"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:SM4Transform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>转换输入字节数组的指定区域，并将所得到的转换复制到输出字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <param name="outputBuffer"></param>
            <param name="outputOffset"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:SM4Transform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>转换指定字节数组的指定区域。</summary>
            <param name="inputBuffer"></param>
            <param name="inputOffset"></param>
            <param name="inputCount"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
    </members>
</doc>
